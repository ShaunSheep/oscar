<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>波尔克</title>
    <url>/ye-jincheng-website/blog/2021/02/website_nickname/</url>
    <content><![CDATA[<h1 id="bo-er-ke"><a href="#波尔克" class="headerlink" title="波尔克"></a>波尔克<a href="#bo-er-ke" class="header-anchor">#</a></h1><h1 id="jie-shao"><a href="#介绍" class="headerlink" title="介绍"></a>介绍<a href="#jie-shao" class="header-anchor">#</a></h1><p>个人网站一直部署在阿里云，服务器用了小三年，上个月到期忘续费，云服务器上的文章资料没能及时导出，最后被阿里清空了，甚是心疼。于是花了一天时间，使用码云仓库搭一个小型静态网站，免费，简单，便捷，关键是动静分离，空间够用。这篇文章主要包含了个人网站的技术架构和常见问题。包括使用的oss管理平台、域名管理、评论管理、文章编辑与发布、网站编辑管理等功能的设计与实现。<a id="more"></a></p>
<h1 id="wang-zhan-jia-gou"><a href="#网站架构" class="headerlink" title="网站架构"></a>网站架构<a href="#wang-zhan-jia-gou" class="header-anchor">#</a></h1><table>
<thead>
<tr>
<th>名称</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>typora</td>
<td>markdown编辑器</td>
</tr>
<tr>
<td>hexo</td>
<td>博客服务</td>
</tr>
<tr>
<td>nodejs</td>
<td>hexo编译环境</td>
</tr>
<tr>
<td>gitee</td>
<td>码云代码仓库</td>
</tr>
<tr>
<td>next</td>
<td>hexo主题</td>
</tr>
<tr>
<td>七牛云</td>
<td>oss图片文件仓库</td>
</tr>
<tr>
<td>阿里云域名</td>
<td>域名转发、cdn转发</td>
</tr>
<tr>
<td>hexo-toc</td>
<td>文档插件显示二级目录，响应点击事件</td>
</tr>
<tr>
<td>hexo-admin</td>
<td>管理后台</td>
</tr>
<tr>
<td>hexo-renderer-markdown-it-plus</td>
<td>markdown解析插件</td>
</tr>
<tr>
<td>leanclound</td>
<td>阅读量统计插件，如何配置<a href="https://blog.csdn.net/lijing742180/article/details/87928554">参考文章</a></td>
</tr>
<tr>
<td>Mpic</td>
<td>图床发布工具，自动发布七牛</td>
</tr>
</tbody></table>
<h1 id="mo-ban-jia-gou"><a href="#模板架构" class="headerlink" title="模板架构"></a>模板架构<a href="#mo-ban-jia-gou" class="header-anchor">#</a></h1><table>
<thead>
<tr>
<th>模板名称</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>android-xx-Tips</td>
<td>Android百问百答模板</td>
</tr>
<tr>
<td>book-note-model</td>
<td>读书笔记模板</td>
</tr>
<tr>
<td>draft</td>
<td>草稿模板</td>
</tr>
<tr>
<td>page</td>
<td>页面模板</td>
</tr>
<tr>
<td>post</td>
<td>文章模板</td>
</tr>
</tbody></table>
<h1 id="an-zhuang-jiao-cheng"><a href="#安装教程" class="headerlink" title="安装教程"></a>安装教程<a href="#an-zhuang-jiao-cheng" class="header-anchor">#</a></h1><h2 id="nodejs-an-zhuang-jiao-cheng"><a href="#nodejs安装教程" class="headerlink" title="nodejs安装教程"></a>nodejs安装教程<a href="#nodejs-an-zhuang-jiao-cheng" class="header-anchor">#</a></h2><p>步骤太简单了，难点就是找到合适版本、合适渠道的安装包，推荐国内使用方式2node中文网的方式下载安装</p>
<table>
<thead>
<tr>
<th>方式</th>
<th>缺点</th>
<th>优点</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://nodejs.org/zh-cn/">node官网</a>，点击链接下载，一路next同意协议安装</td>
<td>国外服务器下载慢</td>
<td>最新安装包</td>
</tr>
<tr>
<td><a href="http://nodejs.cn/">node中文网</a>，点击链接下载，一路next同意协议安装</td>
<td>安装包版本落后1-2个版本</td>
<td>国内服务器下载快</td>
</tr>
</tbody></table>
<h2 id="ma-yun-pei-zhi-wang-zhan-jiao-cheng"><a href="#码云配置网站教程" class="headerlink" title="码云配置网站教程"></a>码云配置网站教程<a href="#ma-yun-pei-zhi-wang-zhan-jiao-cheng" class="header-anchor">#</a></h2><h2 id="git-shi-yong-jiao-cheng"><a href="#git使用教程" class="headerlink" title="git使用教程"></a>git使用教程<a href="#git-shi-yong-jiao-cheng" class="header-anchor">#</a></h2><h2 id="hexo-shi-yong-jiao-cheng"><a href="#hexo使用教程" class="headerlink" title="hexo使用教程"></a>hexo使用教程<a href="#hexo-shi-yong-jiao-cheng" class="header-anchor">#</a></h2><p>hexo官网有详细步骤，小白可以参考百度上的安装教程博客</p>
<table>
<thead>
<tr>
<th>方式</th>
<th>步骤</th>
<th>缺点</th>
<th>优点</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://hexo.io/zh-cn/docs/">hexo官网</a>，权威hexo安装步骤</td>
<td>npm install -g hexo-cli；</td>
<td>不适合小白用户，命令行操作居多</td>
<td>简洁，明了，歧义少</td>
</tr>
<tr>
<td>搜索引擎“hexo安装步骤”</td>
<td><a href="https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html">《参考》</a></td>
<td>遇到问题较难解答</td>
<td>傻瓜式，上手快</td>
</tr>
</tbody></table>
<h1 id="hexo-chang-jian-zhi-ling"><a href="#hexo常见指令" class="headerlink" title="hexo常见指令"></a>hexo常见指令<a href="#hexo-chang-jian-zhi-ling" class="header-anchor">#</a></h1><table>
<thead>
<tr>
<th>指令</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>hexo init</td>
<td>在当前目录下创建工程</td>
</tr>
<tr>
<td>_config.yml</td>
<td>deploy:   type: git   repository: <a href="mailto:&#x67;&#105;&#x74;&#64;&#x67;&#x69;&#x74;&#104;&#117;&#98;&#x2e;&#99;&#111;&#x6d;">&#x67;&#105;&#x74;&#64;&#x67;&#x69;&#x74;&#104;&#117;&#98;&#x2e;&#99;&#111;&#x6d;</a>:liuxianan/liuxianan.github.io.git   branch: master</td>
</tr>
<tr>
<td>hexo clean</td>
<td>清除缓存</td>
</tr>
<tr>
<td>hexo g</td>
<td>生成web</td>
</tr>
<tr>
<td>hexo s</td>
<td>启动web服务并预览，在浏览器输入 <a href="http://localhost:4000/">http://localhost:4000</a></td>
</tr>
<tr>
<td>hexo d</td>
<td>发布pulic 目录下的静态页面至github</td>
</tr>
<tr>
<td>git clone url themes/yilia</td>
<td>下载指定主题到根目录/thems/yilia/ 下</td>
</tr>
<tr>
<td>hexo new “postName”</td>
<td>新建文章，hexo n</td>
</tr>
<tr>
<td>hexo new page “pageName”</td>
<td>#新建页面</td>
</tr>
<tr>
<td>hexo generate</td>
<td>生成静态页面至public目录，hexo g</td>
</tr>
<tr>
<td>hexo server</td>
<td>开启预览访问端口（默认端口4000，’ctrl + c’关闭server）</td>
</tr>
<tr>
<td>hexo deploy</td>
<td>hexo d</td>
</tr>
<tr>
<td>hexo s -g</td>
<td>生成并本地预览</td>
</tr>
</tbody></table>
<h1 id="markdwon-shi-yong-ji-qiao"><a href="#markdwon使用技巧" class="headerlink" title="markdwon使用技巧"></a>markdwon使用技巧<a href="#markdwon-shi-yong-ji-qiao" class="header-anchor">#</a></h1><h2 id="suo-fang-tu-pian-si-chong-chong-ji-qiao"><a href="#缩放图片四种种技巧" class="headerlink" title="缩放图片四种种技巧"></a>缩放图片四种种技巧<a href="#suo-fang-tu-pian-si-chong-chong-ji-qiao" class="header-anchor">#</a></h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;img src=&quot;&quot; width=&quot;50%&quot; height=&quot;50%&quot;&gt;</span><br><span class="line">![test image size](url)&#123;:class=&quot;img-responsive&quot;&#125;</span><br><span class="line">![test image size](url)&#123;:height=&quot;50%&quot; width=&quot;50%&quot;&#125;</span><br><span class="line">![test image size](url)&#123;:height=&quot;100px&quot; width=&quot;400px&quot;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="she-zhi-zi-ti-yan-se"><a href="#设置字体颜色" class="headerlink" title="设置字体颜色"></a>设置字体颜色<a href="#she-zhi-zi-ti-yan-se" class="header-anchor">#</a></h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">style</span>=<span class="string">&quot;color:green&quot;</span>&gt;</span>**数学日记**<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="shi-yong-shu-xue-gong-shi"><a href="#使用数学公式" class="headerlink" title="使用数学公式"></a>使用数学公式<a href="#shi-yong-shu-xue-gong-shi" class="header-anchor">#</a></h2><table>
<thead>
<tr>
<th>文档名称</th>
<th>优点</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://katex.org/docs/supported.html#accents">KaTeX公式文档</a></td>
<td>网站清新，简洁，数学公式非常全，导航详细</td>
<td></td>
</tr>
<tr>
<td>CTEX公式文档</td>
<td>导航较为隐晦，除了数学公式外还有其他公式</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h1 id="chang-jian-wen-ti"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题<a href="#chang-jian-wen-ti" class="header-anchor">#</a></h1><h2 id="ma-yun-bu-shu-hexo-zhan-dian-css-yang-shi-bu-xian-shi"><a href="#码云部署hexo站点-css样式不显示？" class="headerlink" title="码云部署hexo站点 css样式不显示？"></a><strong>码云部署hexo站点 css样式不显示？</strong><a href="#ma-yun-bu-shu-hexo-zhan-dian-css-yang-shi-bu-xian-shi" class="header-anchor">#</a></h2><p>原因：仓库地址与个性地址url不一致<br>解决：修改_config.yml<br>    ​<code>xml     url: https://ipvb.gitee.io/blog     root: /blog     ​</code></p>
<p>其他码云部署的问题参考<a href="https://gitee.com/help/articles/4136#article-header3">这里</a></p>
<h2 id="hexo-ru-he-suo-fang-tu-pian"><a href="#hexo如何缩放图片" class="headerlink" title="hexo如何缩放图片"></a>hexo如何缩放图片<a href="#hexo-ru-he-suo-fang-tu-pian" class="header-anchor">#</a></h2><p><code>&lt;img src=&quot;&quot; width=&quot;50%&quot; height=&quot;50%&quot;&gt;</code></p>
<h2 id="hexo-ru-he-an-zhuang-zhu-ti"><a href="#hexo如何安装主题" class="headerlink" title="hexo如何安装主题"></a>hexo如何安装主题<a href="#hexo-ru-he-an-zhuang-zhu-ti" class="header-anchor">#</a></h2><ol>
<li><p>找到合适的主题列表，推荐以下2个：</p>
<p><a href="https://www.zhihu.com/question/24422335">有哪些好看的 Hexo 主题？</a></p>
<p><a href="https://hexo.io/themes/">hexo.thems</a></p>
</li>
<li><p>安装主题至根目录，例如找到next主题，将其克隆岛根目录/thesms/next下</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">git clone https:<span class="comment">//github.com/iissnan/hexo-theme-next themes/next</span></span><br></pre></td></tr></table></figure></li>
<li><p>阅读<a href="https://github.com/iissnan/hexo-theme-next">next文档</a></p>
<ol>
<li>引用主题：在config.yml中修改主题名称：<code>theme: next</code></li>
<li>发布时遇到 bug<code>&#123;% extends '_layout.swig' %&#125;</code>；输入指令解决：<code>npm i hexo-renderer-swig</code></li>
</ol>
</li>
</ol>
<h2 id="hexo-bu-xian-shi-er-ji-mu-lu"><a href="#hexo不显示二级目录？" class="headerlink" title="hexo不显示二级目录？"></a>hexo不显示二级目录？<a href="#hexo-bu-xian-shi-er-ji-mu-lu" class="header-anchor">#</a></h2><p>原因：hexo解析目录是按照1级，1级下面找2级，2级下面找3级的顺序查找目录的，如果只有2级，没有1级，是会显示错误的。</p>
<p>解决：先写1级标题，再写2级标题，先写大标题，再写小标题。</p>
<p>原因：markdown解析问题</p>
<p>解决：参考<a href="https://www.cnblogs.com/Createsequence/p/14150758.html">渲染错误解决和超链接乱码解决方案</a>、参考<a href="https://convivae.top/posts/hexo-bo-ke-cai-keng/#%E6%96%B9%E6%B3%95-2">markdown-it的bug</a></p>
<h2 id="hexo-dian-ji-er-ji-mu-lu-bu-tiao-zhuan"><a href="#hexo点击二级目录不跳转" class="headerlink" title="hexo点击二级目录不跳转?"></a>hexo点击二级目录不跳转?<a href="#hexo-dian-ji-er-ji-mu-lu-bu-tiao-zhuan" class="header-anchor">#</a></h2><p>原因：markdown解析问题</p>
<p>解决：参考<a href="https://www.cnblogs.com/Createsequence/p/14150758.html">渲染错误解决和超链接乱码解决方案</a>、参考<a href="https://convivae.top/posts/hexo-bo-ke-cai-keng/#%E6%96%B9%E6%B3%95-2">markdown-it的bug</a></p>
<h2 id="hexo-zi-dong-fa-bu-tu-pian-zhi-qi-niu-yun"><a href="#hexo自动发布图片至七牛云？" class="headerlink" title="hexo自动发布图片至七牛云？"></a>hexo自动发布图片至七牛云？<a href="#hexo-zi-dong-fa-bu-tu-pian-zhi-qi-niu-yun" class="header-anchor">#</a></h2><p>阿里云-域名管理-解析设置-添加记录-设置以下参数</p>
<table>
<thead>
<tr>
<th>键</th>
<th>值</th>
</tr>
</thead>
<tbody><tr>
<td>记录类型</td>
<td>CNAME</td>
</tr>
<tr>
<td>主机记录</td>
<td>如cdn</td>
</tr>
<tr>
<td>记录值</td>
<td>从七牛云后台获取</td>
</tr>
</tbody></table>
<p>七牛云-域名管理-加速域名设置值如cdn.yangchaofan.cn；cdn就是主机记录值；创建完毕后，获得一个CNAME值，记住该值，填写至阿里云域名记录值中。</p>
<p><a href="https://portal.qiniu.com/kodo/overview"></a></p>
<h2 id="next-ru-he-da-kai-bai-du-fen-xiang"><a href="#next如何打开百度分享？" class="headerlink" title="next如何打开百度分享？"></a>next如何打开百度分享？<a href="#next-ru-he-da-kai-bai-du-fen-xiang" class="header-anchor">#</a></h2><p>主题文件中插入以下代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">baidushare:</span><br><span class="line">  type: button</span><br><span class="line">  baidushare: <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h2 id="next-ru-he-tian-jia-sou-suo-gong-neng"><a href="#next如何添加搜索功能？" class="headerlink" title="next如何添加搜索功能？"></a>next如何添加搜索功能？<a href="#next-ru-he-tian-jia-sou-suo-gong-neng" class="header-anchor">#</a></h2><p>安装插件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>
<p>编辑全局配置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: <span class="number">10000</span></span><br></pre></td></tr></table></figure>
<p>编辑主题配置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">local_search:</span><br><span class="line">  enable: <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h2 id="next-ru-he-tian-jia-ping-lun-gong-neng"><a href="#next如何添加评论功能？" class="headerlink" title="next如何添加评论功能？"></a>next如何添加评论功能？<a href="#next-ru-he-tian-jia-ping-lun-gong-neng" class="header-anchor">#</a></h2><p>翻墙打开<a href="https://livere.com/">来比力官网</a>，注册填写域名，copy代码块中的data-uid</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- 来必力City版安装代码 --&gt;</span><br><span class="line">&lt;div id=<span class="string">&quot;lv-container&quot;</span> data-id=<span class="string">&quot;city&quot;</span> data-uid=<span class="string">&quot;这里是id&quot;</span>&gt;</span><br><span class="line">	&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">   (<span class="function"><span class="keyword">function</span>(<span class="params">d, s</span>) </span>&#123;</span><br><span class="line">       <span class="keyword">var</span> j, e = d.getElementsByTagName(s)[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">typeof</span> LivereTower === <span class="string">&#x27;function&#x27;</span>) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line"></span><br><span class="line">       j = d.createElement(s);</span><br><span class="line">       j.src = <span class="string">&#x27;https://cdn-city.livere.com/js/embed.dist.js&#x27;</span>;</span><br><span class="line">       j.async = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">       e.parentNode.insertBefore(j, e);</span><br><span class="line">   &#125;)(<span class="built_in">document</span>, <span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">	&lt;/script&gt;</span><br><span class="line">&lt;noscript&gt; 为正常使用来必力评论功能请激活JavaScript&lt;/noscript&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;!-- City版安装代码已完成 --&gt;</span><br></pre></td></tr></table></figure>
<p>配置完成后可以在评论<a href="https://livere.com/insight/communite">后台</a>管理评论内容。</p>
<h2 id="next-ru-he-tian-jia-zhi-ding-gong-neng"><a href="#next如何添加置顶功能？" class="headerlink" title="next如何添加置顶功能？"></a>next如何添加置顶功能？<a href="#next-ru-he-tian-jia-zhi-ding-gong-neng" class="header-anchor">#</a></h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm uninstall hexo-generator-index --save</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install hexo-generator-index-pin-top --save</span></span><br></pre></td></tr></table></figure>
<p>文章插入top属性，top数值按大小倒序排序</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">title: 置顶</span><br><span class="line">date: 2019-09-09 09:09:09</span><br><span class="line">top: true</span><br><span class="line">top: 1</span><br></pre></td></tr></table></figure>
<p>设置置顶样式：</p>
<p>打开：<code>/blog/themes/next/layout/_macro</code>目录下的<code>post.swig</code>文件，定位到<code>&lt;div class=&quot;post-meta&quot;&gt;</code>标签下，插入如下代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;post-meta&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-time&quot;</span>&gt;</span></span><br><span class="line">在此之下插入代码，包含在 span块内        </span><br><span class="line">          &#123;% if post.top %&#125;</span><br><span class="line">            <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-thumb-tack&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">7D26CD</span>&gt;</span>置顶<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-divider&quot;</span>&gt;</span>|<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">          &#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<h2 id="next-ru-he-tiao-zhuan-zhi-zhan-nei-xiang-dui-lu-jing"><a href="#next如何跳转至站内相对路径？" class="headerlink" title="next如何跳转至站内相对路径？"></a>next如何跳转至站内相对路径？<a href="#next-ru-he-tiao-zhuan-zhi-zhan-nei-xiang-dui-lu-jing" class="header-anchor">#</a></h2><h2 id="hexo-ru-he-chuang-jian-mo-ban"><a href="#hexo如何创建模板？" class="headerlink" title="hexo如何创建模板？"></a>hexo如何创建模板？<a href="#hexo-ru-he-chuang-jian-mo-ban" class="header-anchor">#</a></h2><p><strong>模板有什么用？</strong></p>
<p>模板可以当做一类文章的格式，按照指定格式批量创建文章，减少重复内容的编写工作。如创建读书笔记模板、创建一类任务计划模板。</p>
<p><strong>创建模板步骤？</strong></p>
<ul>
<li>新建md文件，文件头插入以下内容，并将文件移动至<code>根目录/scaffolds</code> 下</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">title: 《超效学习方法解码》心得</span><br><span class="line">date: <span class="number">2021</span>-<span class="number">02</span>-<span class="number">17</span> <span class="number">11</span>:<span class="number">37</span>:<span class="number">23</span></span><br><span class="line">entitle:</span><br><span class="line">tags:</span><br><span class="line">categories:</span><br></pre></td></tr></table></figure>
<ul>
<li>使用指令读取模板创建文章</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> hexo new 模板名称 <span class="string">&quot;title&quot;</span></span></span><br><span class="line">hexo new book-note-model &quot;《超效学习方法解码》心得&quot;</span><br></pre></td></tr></table></figure>
<h2 id="hexo-ru-he-chuang-jian-cao-gao"><a href="#hexo如何创建草稿？" class="headerlink" title="hexo如何创建草稿？"></a>hexo如何创建草稿？<a href="#hexo-ru-he-chuang-jian-cao-gao" class="header-anchor">#</a></h2><p><strong>草稿的用途？</strong></p>
<p>文章写到一半，未完成，并不想发布。可以向存到指定位置。hexo提供了_drafts目录存放草稿。</p>
<p><strong>创建草稿的步骤？</strong></p>
<ul>
<li>​创建草稿</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> hexo new draft <span class="string">&quot;title&quot;</span></span></span><br><span class="line">hexo new draft &quot;Android性能优化百问百答&quot;</span><br><span class="line">INFO  Validating config</span><br><span class="line">INFO  Created: </span><br><span class="line">D:\workspace\gitblog\hexoblogcode\source\_drafts\Android性能优化百问百答.md</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>发布草稿</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> hexo publish 布局类型 <span class="string">&quot;title&quot;</span></span></span><br><span class="line">hexo publish draft &quot;Android性能优化百问百答&quot;</span><br><span class="line">INFO  Validating config</span><br><span class="line">INFO  Published: D:\workspace\gitblog\hexoblogcode\source\_posts\Android性能优化百问百答.md</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="next-wen-zhang-zi-gua-ying-ping-mu-kuan-du"><a href="#next文章自适应屏幕宽度" class="headerlink" title="next文章自适应屏幕宽度"></a>next文章自适应屏幕宽度<a href="#next-wen-zhang-zi-gua-ying-ping-mu-kuan-du" class="header-anchor">#</a></h2><p><code>\themes\next\source/css/_schemes/Picses/_layout.styl</code>在文件末尾添加代码</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">// 以下为新增代码！！修改post宽度</span><br><span class="line"><span class="selector-tag">header</span>&#123; <span class="attribute">width</span>: <span class="number">80%</span> <span class="meta">!important</span>; &#125;</span><br><span class="line"><span class="selector-tag">header</span><span class="selector-class">.post-header</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: auto <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-class">.main-inner</span> &#123; <span class="attribute">width</span>: <span class="number">80%</span>; &#125;</span><br><span class="line"><span class="selector-class">.content-wrap</span> &#123; <span class="attribute">width</span>: <span class="built_in">calc</span>(<span class="number">100%</span> - <span class="number">260px</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.header</span> &#123;</span><br><span class="line">  +tablet() &#123;</span><br><span class="line">    <span class="attribute">width</span>: auto <span class="meta">!important</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  +mobile() &#123;</span><br><span class="line">    <span class="attribute">width</span>: auto <span class="meta">!important</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-class">.main-inner</span> &#123;</span><br><span class="line">  +tablet() &#123;</span><br><span class="line">    <span class="attribute">width</span>: auto <span class="meta">!important</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  +mobile() &#123;</span><br><span class="line">    <span class="attribute">width</span>: auto <span class="meta">!important</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.content-wrap</span> &#123;</span><br><span class="line">  +tablet() &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span> <span class="meta">!important</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  +mobile() &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span> <span class="meta">!important</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="next-tian-jia-tou-xiang"><a href="#next添加头像" class="headerlink" title="next添加头像"></a>next添加头像<a href="#next-tian-jia-tou-xiang" class="header-anchor">#</a></h2><p>打开themes/next/_config.yml</p>
<p>打开并放入头像/themes/next/source/images/</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">avatar: /images/avatar_2.gif</span><br></pre></td></tr></table></figure>
<h1 id="shi-yong-shuo-ming"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明<a href="#shi-yong-shuo-ming" class="header-anchor">#</a></h1><ol>
<li> 定时使用typora编写markdown文章：编写markdown文件</li>
<li> 导出成html，发布在hexo：使用hexo s</li>
<li> hexo推送到码云指定仓库地址：hexo d</li>
<li> 将阿里云的域名解析至码云仓库地址：配置域名解析</li>
<li> 通过公网域名访问我的网站</li>
</ol>
<h1 id="zhi-chi"><a href="#支持" class="headerlink" title="支持"></a>支持<a href="#zhi-chi" class="header-anchor">#</a></h1><ol>
<li> <a href="https://support.typora.io/Resize-Image/">typora使用手册</a></li>
<li> <a href="https://gitee.com/help">Gitee 官方提供的使用手册</a></li>
<li> <a href="https://portal.qiniu.com/kodo/overview">七牛云</a> </li>
<li> <a href="https://homenew.console.aliyun.com/home/dashboard/ProductAndService">阿里云</a> </li>
<li> <a href="https://hexo.io/zh-cn/docs">hexo中文文档</a></li>
<li> <a href="http://theme-next.iissnan.com/third-party-services.html#comment-system">next中文文档</a></li>
<li> <a href="https://console.leancloud.cn/apps">leanclound统计云</a></li>
<li> <a href="https://livere.com/insight/communite">来比力评论云</a></li>
</ol>
]]></content>
      <categories>
        <category>杂谈</category>
        <category>日记</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>2015-2021学习计划</title>
    <url>/ye-jincheng-website/blog/2015/08/learing-plan/</url>
    <content><![CDATA[<h1 id="2015-2021-xue-xi-ji-hua-ji-xiao-jie"><a href="#2015-2021学习计划及小结" class="headerlink" title="2015-2021学习计划及小结"></a>2015-2021学习计划及小结<a href="#2015-2021-xue-xi-ji-hua-ji-xiao-jie" class="header-anchor">#</a></h1><h1 id="gai-shu"><a href="#概述" class="headerlink" title="概述"></a>概述<a href="#gai-shu" class="header-anchor">#</a></h1><p>这里存放2015年-2021年的学习内容，包括已经学习的，正在学习的，</p>
<p>内容为：音频课程、视频课程、电子书、实体书、专栏课程、认证课程等。</p>
<p>内容来源自kindle、知乎、极客学院、慕课网、阿里云大学、光环国际、黑马培训、拉钩培训、三节课培训等</p>
<p>个人网站到期，很多资料未及时存档，只能根据自己的历史笔记一点点更新了。</p>
<p>每一条内容为：完成状态+任务名称+任务完成详情</p>
<p>已完成的任务显示如下，完成态+任务名称+删除线+点击跳转至文章总结或项目总结</p>
<ul>
<li><input checked disabled type="checkbox"> <del><a href>任务名称</a></del></li>
</ul>
<p>未完成的任务显示为，未完成态+任务名称</p>
<ul>
<li><input disabled type="checkbox"> 任务名称</li>
</ul>
<a id="more"></a>

<h1 id="2021"><a href="#2021" class="headerlink" title="2021"></a>2021<a href="#2021" class="header-anchor">#</a></h1><ul>
<li><input disabled type="checkbox"> 《数学思想概论》</li>
<li><input disabled type="checkbox"> 《划归与归纳》</li>
<li><input disabled type="checkbox"> 《结构思考力用思维导图》</li>
<li><input disabled type="checkbox"> 《情报分析合集》</li>
<li><input checked disabled type="checkbox"> <del>《如何高效学习》</del></li>
</ul>
<ul>
<li><input checked disabled type="checkbox"> 《极客时间-朱云技术管理课》</li>
<li><input checked disabled type="checkbox"> 《软件测试技术与模板》</li>
<li><input checked disabled type="checkbox"> <del>《超效学方法解码》</del></li>
<li><input checked disabled type="checkbox"> <del>《学习革命的解读》</del></li>
<li><input checked disabled type="checkbox"> 《改变你一生的学习计划》</li>
<li><input checked disabled type="checkbox"> 《当代学习理论十三讲》</li>
<li><input checked disabled type="checkbox"> 《新学习革命》</li>
<li><input checked disabled type="checkbox"> 《思维导图的运用》</li>
<li><input checked disabled type="checkbox"> 《7s倍速学习法》</li>
<li><input checked disabled type="checkbox"> 《攻克7大学习问题》</li>
<li><input checked disabled type="checkbox"> <del>《高效学习方法全集》</del></li>
</ul>
<h1 id="2020"><a href="#2020" class="headerlink" title="2020"></a>2020<a href="#2020" class="header-anchor">#</a></h1><p>存档资料恢复中</p>
<ul>
<li><input checked disabled type="checkbox"> 《九章算法2020》</li>
<li><input checked disabled type="checkbox"> 《得到：有效管理健康》</li>
<li><input checked disabled type="checkbox"> 《得到：大脑健康课》</li>
<li><input checked disabled type="checkbox"> 《Android自定义控件实战》</li>
<li><input checked disabled type="checkbox"> 《拉勾网：Android34讲》</li>
<li><input checked disabled type="checkbox"> 《Android进阶解密》</li>
<li><input checked disabled type="checkbox"> 《Android高效进阶数据AI》</li>
<li><input checked disabled type="checkbox"> 《极客时间-Java核心36讲》</li>
<li><input checked disabled type="checkbox"> 《极客时间-JVM原理》</li>
<li><input checked disabled type="checkbox"> 《慕课：Gradle3.0自动化项目构建技术精讲+实战》</li>
<li><input checked disabled type="checkbox"> 《慕课：Android代码混淆与加固技术》</li>
<li><input checked disabled type="checkbox"> 《慕课：Android图案解锁》</li>
<li><input checked disabled type="checkbox"> 《慕课：自定义实现日历控件》</li>
<li><input checked disabled type="checkbox"> 《慕课：Android高级特效-索引》</li>
<li><input checked disabled type="checkbox"> 《慕课：Android美女拼图小游戏》</li>
<li><input checked disabled type="checkbox"> 《慕课：打造个性的图片预览与多点触控》</li>
<li><input checked disabled type="checkbox"> 《慕课：Android电商活动中的刮刮卡》</li>
<li><input checked disabled type="checkbox"> 《慕课：Android自定义任意层级树形控件》</li>
</ul>
<h1 id="2015-2019"><a href="#2015-2019" class="headerlink" title="2015-2019"></a>2015-2019<a href="#2015-2019" class="header-anchor">#</a></h1><p>存档资料恢复中</p>
<ul>
<li><input checked disabled type="checkbox"> 《kindle：论语》</li>
<li><input checked disabled type="checkbox"> 《Java疯狂讲义》</li>
<li><input checked disabled type="checkbox"> 《Effice java》</li>
<li><input checked disabled type="checkbox"> 《重构》</li>
<li><input checked disabled type="checkbox"> 《代码整洁之道》</li>
<li><input checked disabled type="checkbox"> 《Android103例》</li>
<li><input checked disabled type="checkbox"> 《AndroidAPP研发录》</li>
<li><input checked disabled type="checkbox"> 《Android深入理解卷I-III》</li>
<li><input checked disabled type="checkbox"> 《Android源码设计模式》</li>
<li><input checked disabled type="checkbox"> 《Android埋点解决方案》</li>
<li><input checked disabled type="checkbox"> 《大话设计模式》</li>
<li><input checked disabled type="checkbox"> 《Android应用性能优化最佳实践》</li>
<li><input checked disabled type="checkbox"> 《Android开发高手课》</li>
<li><input checked disabled type="checkbox"> 《慕课：java设计模式Debug》</li>
<li><input checked disabled type="checkbox"> 《慕课：音视频WebRTC实时互动直播技术入门与实战》</li>
<li><input checked disabled type="checkbox"> 《慕课：《从0打造音视频直播系统》》</li>
<li><input checked disabled type="checkbox"> 《慕课：Top团队大牛带你玩转Android性能分析与优化》</li>
<li><input checked disabled type="checkbox"> 《慕课：BAT大牛 带你深度剖析Android 10大开源框架》</li>
<li><input checked disabled type="checkbox"> 《慕课：Jetpack全组件实战 开发短视频应用App》</li>
<li><input checked disabled type="checkbox"> 《慕课：主流开发方案实战京东移动端APP》</li>
<li><input checked disabled type="checkbox"> 《慕课：企业级Android应用架构设计与开发》</li>
<li><input checked disabled type="checkbox"> 《慕课：Android应用发展趋势必备武器 热修复与插件化》</li>
<li><input checked disabled type="checkbox"> 《慕课：剖析Framework面试 冲击Android高级职位》</li>
<li><input checked disabled type="checkbox"> 《慕课：Kotlin系统入门与进阶》</li>
<li><input checked disabled type="checkbox"> 《慕课：Java并发编程与高并发解决方案》</li>
<li><input checked disabled type="checkbox"> 《慕课：Android实现跨进程通信》</li>
<li><input checked disabled type="checkbox"> 《慕课：Android网络安全之加解密》</li>
<li><input checked disabled type="checkbox"> 《Socket网络编程进阶与实战》</li>
</ul>
]]></content>
      <categories>
        <category>规划</category>
        <category>个人教育</category>
      </categories>
      <tags>
        <tag>个人教育</tag>
      </tags>
  </entry>
  <entry>
    <title>mtk-log</title>
    <url>/ye-jincheng-website/blog/2021/02/mtk-log/</url>
    <content><![CDATA[<h1 id="mtk-log"><a href="#MTK-log" class="headerlink" title="MTK log"></a><a href="https://www.pianshen.com/article/4121163154/">MTK log</a><a href="#mtk-log" class="header-anchor">#</a></h1><h2 id="jie-shao"><a href="#介绍" class="headerlink" title="介绍"></a>介绍<a href="#jie-shao" class="header-anchor">#</a></h2><p>mtklog是由log生成工具MTKLogger生成的一系列问题追踪文件，其主要作用就是对系统或者应用产生的异常进行快速定位，从而解决问题。</p>
<p>log文件名称为：<br>crash_log ：崩溃日志，主要输出 程序崩溃造成的crash log<br>events_log：事件日志，主要输出记录各个activity周期及事件<br>kernel_log：底层驱动，按键，低内存相关log<br>sys_log：系统日志，Exception定位点<br>radio_log：输出通话，网络状态变化<br>main_log：详尽输出每一步的log</p>
<a id="more"></a>

<h2 id="kai-qi-he-guan-bi"><a href="#开启和关闭" class="headerlink" title="开启和关闭"></a>开启和关闭<a href="#kai-qi-he-guan-bi" class="header-anchor">#</a></h2><p>（1）在拨号盘界面输入*#9646633# ：<br>（2）进入EngineerMode的第一个Telephony界面：<br>（3）向左滑动进入Log and Debugging界面：<br>（4）点击MTKLogger 菜单：点击log设置图标可进入log设置界面，如果我只要打印MobileLog可将ModemLog，NetworkLog，GPSlog关闭，点击蓝底色1 即可：<br>（5）点击开始（红色播放按键）按键：<br>（6）log 开启：<br>（7）当我们已经发现异常时，当关闭log，并截图记录时间点，下拉进入下拉栏界面，点击MTKLogger is running：<br>（8）点击停止按键</p>
<h2 id="log-zong-lan"><a href="#Log总览" class="headerlink" title="Log总览**"></a>Log总览**<a href="#log-zong-lan" class="header-anchor">#</a></h2><ul>
<li><strong>Android Log</strong></li>
</ul>
<ol>
<li>Android java层和native层 log</li>
<li>main log、system log、radio log、event log</li>
</ol>
<ul>
<li><strong>Kernel Log</strong></li>
</ul>
<ol>
<li>Linux Kernel内核和驱动log</li>
<li>UART Log</li>
</ol>
<ul>
<li><strong>Exception Datebase(db)</strong></li>
</ul>
<p>系统死机/重启等问题发生时候的原始RAW data</p>
<h2 id="log-tools"><a href="#Log-Tools" class="headerlink" title="Log Tools"></a><strong>Log Tools</strong><a href="#log-tools" class="header-anchor">#</a></h2><ul>
<li>mtklogger</li>
<li>PC tool</li>
</ul>
<p><img src="http://cdn.yangchaofan.cn/blog/20210227/br8ouvYv45G7.jpg?imageslim" alt="mark"></p>
<h3 id="shou-ji-duan-mtklogger"><a href="#手机端mtklogger" class="headerlink" title="手机端mtklogger"></a><strong>手机端mtklogger</strong><a href="#shou-ji-duan-mtklogger" class="header-anchor">#</a></h3><p><img src="http://cdn.yangchaofan.cn/blog/20210227/DiGViDp5mmch.png?imageslim" alt="mark"></p>
<p><img src="http://cdn.yangchaofan.cn/blog/20210227/qgVnqzd6p6IJ.png?imageslim" alt="mark"></p>
<h4 id="ge-ren-you-hua"><a href="#个人优化" class="headerlink" title="个人优化"></a><strong>个人优化</strong><a href="#ge-ren-you-hua" class="header-anchor">#</a></h4><h5 id="mtklog-zhua-qu-wan-zheng-kernel-log"><a href="#mtklog抓取完整kernel-log" class="headerlink" title="mtklog抓取完整kernel log"></a><strong>mtklog抓取完整kernel log</strong><a href="#mtklog-zhua-qu-wan-zheng-kernel-log" class="header-anchor">#</a></h5><ul>
<li><strong>默认抓不全原因</strong></li>
</ul>
<p>由于Mobilelog service运行要在android system init阶段，而从kernel启动到这个阶段，kernel log已经在不断地送入log ring buffer，log量大的情况下ring buffer就会被覆盖</p>
<p>默认抓取到的kernel_log.boot不是从0s开始，对于研发debug阶段,只能靠抓取uart log来获取0s开始的log，非常影响debug效率</p>
<ul>
<li><strong>解决方法</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alps&#x2F;kernel-3.18&#x2F;init&#x2F;Kconfig</span><br><span class="line">config LOG_BUF_SHIFT</span><br><span class="line">       default 17  --- &gt; 21   2^21&#x3D;2MB buffer</span><br><span class="line"></span><br><span class="line">alps&#x2F;system&#x2F;core&#x2F;liblog&#x2F;include&#x2F;private&#x2F;android_logger.h</span><br><span class="line">#define LOG_BUFFER_SIZE (2048 * 1024)    #log和logd一致</span><br><span class="line">123456</span><br></pre></td></tr></table></figure>
<h3 id="dian-nao-duan-pc-tool"><a href="#电脑端PC-tool" class="headerlink" title="电脑端PC tool"></a><strong>电脑端PC tool</strong><a href="#dian-nao-duan-pc-tool" class="header-anchor">#</a></h3><h4 id="adb"><a href="#adb" class="headerlink" title="adb"></a><strong>adb</strong><a href="#adb" class="header-anchor">#</a></h4><h5 id="logcat"><a href="#logcat" class="headerlink" title="logcat"></a><strong>logcat</strong><a href="#logcat" class="header-anchor">#</a></h5><ul>
<li><strong>介绍</strong></li>
</ul>
<p>logcat是android中的一个命令行工具，可以用于得到程序的log信息</p>
<p>常见的日志纪录方法包括：</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">v(String,String) (vervbose)</td>
<td align="left">显示全部信息</td>
</tr>
<tr>
<td align="left">d(String,String)(debug)</td>
<td align="left">显示调试信息</td>
</tr>
<tr>
<td align="left">i(String,String)(information)</td>
<td align="left">显示一般信息</td>
</tr>
<tr>
<td align="left">w(String,String)(waning)</td>
<td align="left">显示警告信息</td>
</tr>
<tr>
<td align="left">e(String,String)(error)</td>
<td align="left">显示错误信息</td>
</tr>
</tbody></table>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;开发过程中获取log</span><br><span class="line">Log.i(&quot;MyActivity&quot;,&quot;MyClass.getView() - get item number&quot;+position);</span><br><span class="line">&#x2F;&#x2F;adb获取log</span><br><span class="line">adb logcat</span><br><span class="line">1234</span><br></pre></td></tr></table></figure>
<p>adb logcat输出的日志格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">I&#x2F;ActivityManager( 1754): Waited long enough for: ServiceRecord&#123;2b24178c u0 com.google.android.gms&#x2F;.checkin.CheckinService&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>实例</strong></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb logcat –b radio</span><br><span class="line">adb logcat –b system</span><br><span class="line">adb logcat –b events</span><br><span class="line">adb logcat –b main</span><br><span class="line">1234</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>优势</strong></li>
</ul>
<ol>
<li>缓冲区强大，不会因为数据量过大而丢失log</li>
<li>过滤性能好</li>
<li>语法简洁，使用方便</li>
</ol>
<h5 id="ti-qu-db"><a href="#提取db" class="headerlink" title="提取db"></a><strong>提取db</strong><a href="#ti-qu-db" class="header-anchor">#</a></h5><ul>
<li><strong>位置</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;data&#x2F;aee_exp</span><br><span class="line">&#x2F;data&#x2F;vendor&#x2F;mtklog&#x2F;aee_exp</span><br><span class="line">12</span><br></pre></td></tr></table></figure>
<h4 id="gat"><a href="#GAT" class="headerlink" title="GAT"></a><strong>GAT</strong><a href="#gat" class="header-anchor">#</a></h4><p><img src="http://cdn.yangchaofan.cn/blog/20210227/nwDUjynnBdXh.png?imageslim" alt="mark"></p>
<ul>
<li><strong>BugReport</strong></li>
</ul>
<p><img src="http://cdn.yangchaofan.cn/blog/20210227/VRnI24X9QxKP.png?imageslim" alt="mark"></p>
<ul>
<li><strong>DB puller</strong></li>
</ul>
<p><img src="http://cdn.yangchaofan.cn/blog/20210227/POXrsi3L2V0k.png?imageslim" alt="mark"></p>
<ul>
<li><strong>Mediatek LogView</strong></li>
</ul>
<p><img src="http://cdn.yangchaofan.cn/blog/20210227/59zvGw73P6Qr.png?imageslim" alt="mark"></p>
<h2 id="ge-chong-mode-zhua-mobile-log"><a href="#各种mode抓mobile-log" class="headerlink" title="各种mode抓mobile log"></a><strong>各种mode抓mobile log</strong><a href="#ge-chong-mode-zhua-mobile-log" class="header-anchor">#</a></h2><h3 id="normal-mode"><a href="#Normal-mode" class="headerlink" title="Normal mode"></a><strong>Normal mode</strong><a href="#normal-mode" class="header-anchor">#</a></h3><ol>
<li>GAT (user版本只能抓main log，eng版本还能抓到kernel log)</li>
<li>mtklogger(user版本通过*#<em>#3646633#</em>#*进入工模选择)，会暂时录制到/data/log_temp下，等SD卡ready后再copy到mtklog/mobilelog/APLog路径下</li>
</ol>
<h3 id="meta-mode-pc-meta-tool"><a href="#Meta-mode-PC-meta-tool" class="headerlink" title="Meta mode(PC meta tool)"></a><strong>Meta mode(PC meta tool)</strong><a href="#meta-mode-pc-meta-tool" class="header-anchor">#</a></h3><ul>
<li>会先录制到/data/log_temp/meta/下，等外卡ready后再copy到sdcard1/mtklog/mobilelog/APLog路径下，然后删除源文件(data/log_temp)。</li>
</ul>
<h3 id="factory-mode-power-down-key"><a href="#Factory-mode-power-down-key" class="headerlink" title="Factory mode(power + down key)"></a><strong>Factory mode(power + down key)</strong><a href="#factory-mode-power-down-key" class="header-anchor">#</a></h3><ul>
<li>同Meta mode</li>
</ul>
<h3 id="recovery-mode-power-up-key"><a href="#Recovery-mode-power-up-key" class="headerlink" title="Recovery mode(power + up key)"></a><strong>Recovery mode(power + up key)</strong><a href="#recovery-mode-power-up-key" class="header-anchor">#</a></h3><ol>
<li>先存在tmp/recovery.log，Reboot进入normal后存在cache/recovery</li>
<li>user 版本需要下载eng的recovery.img和boot.img才能抓log</li>
</ol>
<h3 id="ipo-mode"><a href="#IPO-mode" class="headerlink" title="IPO mode"></a><strong>IPO mode</strong><a href="#ipo-mode" class="header-anchor">#</a></h3><ol>
<li>设置IPO关机后，关机期间的log会录制到/data/log_temp/ipo/下，等再次开机后再copy到/mtklog/mobilelog/APLog路径下，然后删除源文件。</li>
<li>GAT</li>
</ol>
<h2 id="ge-chong-chang-jing-zhua-log"><a href="#各种场景抓log" class="headerlink" title="各种场景抓log"></a><strong>各种场景抓log</strong><a href="#ge-chong-chang-jing-zhua-log" class="header-anchor">#</a></h2><h3 id="preloader-amp-lk-jie-duan-mei-you-logo-huo-qia-zai-logo-jie-mian-kai-ji-log"><a href="#Preloader-amp-LK阶段（没有logo或卡在logo界面）开机log" class="headerlink" title="Preloader &amp; LK阶段（没有logo或卡在logo界面）开机log"></a><strong>Preloader &amp; LK阶段（没有logo或卡在logo界面）开机log</strong><a href="#preloader-amp-lk-jie-duan-mei-you-logo-huo-qia-zai-logo-jie-mian-kai-ji-log" class="header-anchor">#</a></h3><ul>
<li>抓取uart log</li>
</ul>
<h3 id="kernel-jie-duan-you-logo-huo-kai-ji-dong-hua-kai-ji-log"><a href="#Kernel阶段（有logo或开机动画-开机log" class="headerlink" title="Kernel阶段（有logo或开机动画)开机log"></a>Kernel阶段（有logo或开机动画)开机log<a href="#kernel-jie-duan-you-logo-huo-kai-ji-dong-hua-kai-ji-log" class="header-anchor">#</a></h3><ol>
<li>如果是User版本，先用对应ENG 版本的lk 替换掉user 版本的lk</li>
<li>或者在user load的<code>alps/bootable/bootloader/lk/app/mt_boot/mt_boot.c</code>中，将所有<code>printk.disable_uart=1</code>改成<code>printk.disable_uart=0</code>，然后重新编译lk, download lk 即可。</li>
</ol>
<h3 id="android-jie-duan-you-kai-ji-dong-hua-kai-ji-log"><a href="#Android阶段（有开机动画）开机log" class="headerlink" title="Android阶段（有开机动画）开机log"></a><strong>Android阶段（有开机动画）开机log</strong><a href="#android-jie-duan-you-kai-ji-dong-hua-kai-ji-log" class="header-anchor">#</a></h3><p>Adbd进程起来后，可以使用GAT抓取开机log（录制前先关机）。</p>
<p>若mtklogger可用，可以通过设置mobile log开机自启动录制开机log。</p>
<p>停止录制状态下mtklogger-&gt;settings-&gt;mobile log-&gt;start automticaly</p>
<p>若TP无法使用，可以参考FAQ06939使用adb命令控制mtklogger录制。</p>
<h3 id="user-build-zhua-kai-ji-xiang-dao-huo-zhe-bu-kai-ji-log"><a href="#user-build-抓开机向导或者不开机log" class="headerlink" title="user build 抓开机向导或者不开机log"></a><strong>user build 抓开机向导或者不开机log</strong><a href="#user-build-zhua-kai-ji-xiang-dao-huo-zhe-bu-kai-ji-log" class="header-anchor">#</a></h3><p>编译一版eng版本对应软件，做如下修改：</p>
<p><a href="https://ad.plus/?utm_source=pianshen.com&utm_medium=protag-in_article_video&utm_campaign=brand_logo">Powered by <strong>Ad.Plus</strong></a></p>
<p><video class="pa_video pa_size_640_360" playsinline muted width="640" height="360" style="box-sizing: border-box; display: inline-block; vertical-align: baseline; overflow: hidden; max-width: 100%; height: 225px; transition: height 0s ease-out 0s; width: 400px;"></video></p>
<iframe src="https://imasdk.googleapis.com/js/core/bridge3.444.1_zh.html#goog_420327109" allowfullscreen allow="autoplay" width="640" height="360" style="box-sizing: border-box; height: 225px !important; width: 400px !important; border: 0px; opacity: 1; margin: 0px; padding: 0px; position: relative; color-scheme: light;"></iframe>



<ol>
<li><code>alps/system/core/rootdir/init.rc</code></li>
</ol>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">on property:ro.debuggable=<span class="number">1</span></span><br><span class="line">    <span class="comment"># Give writes to anyone for the trace folder on debug builds.</span></span><br><span class="line">    <span class="comment"># The folder is used to store method traces.</span></span><br><span class="line">    chmod <span class="number">0773</span> /data/misc/trace</span><br><span class="line">    start console</span><br><span class="line">//add begin</span><br><span class="line">on property:ro.debuggable=<span class="number">0</span></span><br><span class="line">    <span class="comment"># Give writes to anyone for the trace folder on debug builds.</span></span><br><span class="line">    <span class="comment"># The folder is used to store method traces.</span></span><br><span class="line">    chmod <span class="number">0773</span> /data/misc/trace</span><br><span class="line">    start console</span><br><span class="line">setprop persist.sys.usb.config mass_storage,adb //add end</span><br><span class="line">123456789101112</span><br></pre></td></tr></table></figure>
<ol>
<li><code>alps/kernel-3.18/drivers/misc/mediatek/mtprof/bootprof.c</code></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MT_PRINTK_UART_CONSOLE</span></span><br><span class="line">    <span class="comment">//mt_disable_uart();</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>
<ol>
<li><code>alps/build/make/core/main.mk</code></li>
</ol>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ifeq</span> (true,<span class="variable">$(<span class="built_in">strip</span> <span class="variable">$(enable_target_debugging)</span>)</span>)  <span class="comment"># Target is more debuggable and adbd is on by default</span></span><br><span class="line">  ADDITIONAL_DEFAULT_PROPERTIES += ro.debuggable=1  <span class="comment"># Enable Dalvik lock contention logging.</span></span><br><span class="line">  ADDITIONAL_BUILD_PROPERTIES += dalvik.vm.lockprof.threshold=500   <span class="comment"># Include the debugging/testing OTA keys in this build.</span></span><br><span class="line">  INCLUDE_TEST_OTA_KEYS := true</span><br><span class="line"><span class="keyword">else</span> <span class="comment"># !enable_target_debugging</span></span><br><span class="line">  <span class="comment"># Target is less debuggable and adbd is off by default</span></span><br><span class="line">  ADDITIONAL_DEFAULT_PROPERTIES += ro.debuggable=1</span><br><span class="line"><span class="keyword">endif</span> <span class="comment"># !enable_target_debugging</span></span><br><span class="line">12345678</span><br></pre></td></tr></table></figure>
<p>编译好后，user版本刷入eng版本的lk+boot， 抓取uart 或者上层log</p>
<p>如需抓取开机向导前的log，由于系统还未正式起来，请焊uart线，uart log中输入<code>adb logcat &amp;</code>将上层log输出到uart log中</p>
<h2 id="aee-yi-chang-ji-zhi"><a href="#AEE异常机制" class="headerlink" title="AEE异常机制"></a><strong>AEE异常机制</strong><a href="#aee-yi-chang-ji-zhi" class="header-anchor">#</a></h2><h3 id="aee-jie-shao"><a href="#AEE介绍" class="headerlink" title="AEE介绍"></a><strong>AEE介绍</strong><a href="#aee-jie-shao" class="header-anchor">#</a></h3><p><code>AEE (Android Exception Engine)</code>是安卓的一个异常捕获和调试信息生成机制。</p>
<p>手机发生错误（异常重启/卡死）时生成db文件（一种被加密过的二进制文件）</p>
<h3 id="why-do-we-need-aee"><a href="#why-do-we-need-AEE" class="headerlink" title="why do we need AEE"></a><strong>why do we need AEE</strong><a href="#why-do-we-need-aee" class="header-anchor">#</a></h3><p>用来保存和记录异常发生时候的所有内存信息，通过调试和仿真这些信息，可以追踪到异常的原因</p>
<h3 id="db-wen-jian-jie-shao"><a href="#DB文件介绍" class="headerlink" title="DB文件介绍"></a><strong>DB文件介绍</strong><a href="#db-wen-jian-jie-shao" class="header-anchor">#</a></h3><table>
<thead>
<tr>
<th align="left"><strong>File</strong></th>
<th align="left"><strong>Description</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>__exp_main.txt</strong></td>
<td align="left">异常类型，调用栈等关键信息</td>
</tr>
<tr>
<td align="left">_exp_detail.txt</td>
<td align="left">详细异常信息</td>
</tr>
<tr>
<td align="left"><strong>SYS_ANDROID_LOG</strong></td>
<td align="left">android buffer log(logcat -d -v time *:v)</td>
</tr>
<tr>
<td align="left"><strong>SYS_KERNEL_LOG</strong></td>
<td align="left">kernel log</td>
</tr>
<tr>
<td align="left"><strong>SYS_LAST_KMSG</strong></td>
<td align="left">上次重启前的kernel log</td>
</tr>
<tr>
<td align="left"><strong>SYS_MINI_RDUMP</strong></td>
<td align="left">类似coredump，可以用gdb/trace32调试</td>
</tr>
<tr>
<td align="left">SYS_WDT_LOG</td>
<td align="left">看门狗复位信息</td>
</tr>
<tr>
<td align="left">SYS_REBOOT_REASON</td>
<td align="left">重启时的硬件记录的信息</td>
</tr>
<tr>
<td align="left">SYS_VERSION_INFO</td>
<td align="left">kernel版本，用于和vmlinux对比，只有匹配的vmlinux才能用于分析这个异常</td>
</tr>
<tr>
<td align="left">SYS_ANDROID_EVENT_LOG</td>
<td align="left">android event log(logcat -b events -v time -d *:v)</td>
</tr>
<tr>
<td align="left">SYS_ANDROID_RADIO_LOG</td>
<td align="left">android buffer log(logcat -b radio -v time -d *:v)</td>
</tr>
<tr>
<td align="left"><strong>PROCESS_COREDUMP</strong></td>
<td align="left">native program core dump</td>
</tr>
<tr>
<td align="left"><strong>SYS_PROPERTIES</strong></td>
<td align="left">system properties</td>
</tr>
<tr>
<td align="left">SWT_JBT_TRACES</td>
<td align="left">/data/anr/.</td>
</tr>
<tr>
<td align="left">ZZ_INTERNAL</td>
<td align="left">基本异常信息</td>
</tr>
<tr>
<td align="left">SYS_CPU_INFO</td>
<td align="left">cpu 信息(top -n 1 -d 1 -m 30 -t)</td>
</tr>
<tr>
<td align="left">SYS_MEMORY_INFO</td>
<td align="left">memory information (/proc/meminfo)</td>
</tr>
</tbody></table>
<ul>
<li><strong>重启原因记录</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">last_reboot_reason</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> fiq_step;</span><br><span class="line">    <span class="keyword">uint32_t</span> exp_type; <span class="comment">/* 0xaeedeadX: X=1 (HWT), X=2 (KE), X=3 (nested panic) */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> reboot_mode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> last_irq_enter[NR_CPUS];</span><br><span class="line">    <span class="keyword">uint64_t</span> jiffies_last_irq_enter[NR_CPUS];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> last_irq_exit[NR_CPUS];</span><br><span class="line">    <span class="keyword">uint64_t</span> jiffies_last_irq_exit[NR_CPUS];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint64_t</span> jiffies_last_sched[NR_CPUS];</span><br><span class="line">    <span class="keyword">char</span> last_sched_comm[NR_CPUS][TASK_COMM_LEN];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint8_t</span> hotplug_data1[NR_CPUS], <span class="keyword">uint8_t</span> hotplug_data2;</span><br><span class="line">    <span class="keyword">uint64_t</span> hotplug_data3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> mcdi_wfi, mcdi_r15, deepidle_data, sodi_data, spm_suspend_data;</span><br><span class="line">    <span class="keyword">uint64_t</span> cpu_dormant[NR_CPUS];</span><br><span class="line">    <span class="keyword">uint32_t</span> clk_data[<span class="number">8</span>], suspend_debug_flag;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint8_t</span> cpu_dvfs_vproc_big, cpu_dvfs_vproc_little, cpu_dvfs_oppidx, cpu_dvfs_status;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint8_t</span> gpu_dvfs_vgpu, gpu_dvfs_oppidx, gpu_dvfs_status;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint64_t</span> ptp_cpu_big_volt, ptp_cpu_little_volt, ptp_gpu_volt, ptp_temp;</span><br><span class="line">    <span class="keyword">uint8_t</span> ptp_status;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint8_t</span> thermal_temp1, thermal_temp2, thermal_temp3, thermal_temp4, thermal_temp5;</span><br><span class="line">    <span class="keyword">uint8_t</span> thermal_status;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *kparams;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728293031323334</span></span><br></pre></td></tr></table></figure>
<h2 id="shi-ji-ying-yong-zong-jie"><a href="#实际应用总结" class="headerlink" title="实际应用总结"></a><strong>实际应用总结</strong><a href="#shi-ji-ying-yong-zong-jie" class="header-anchor">#</a></h2><h3 id="usr-zhuang-tai-bu-tong-xian-xiang-shou-ji-ru-he-zhua-qu-you-xiao-log"><a href="#usr状态，不同现象手机如何抓取有效log" class="headerlink" title="usr状态，不同现象手机如何抓取有效log"></a><strong>usr状态，不同现象手机如何抓取有效log</strong><a href="#usr-zhuang-tai-bu-tong-xian-xiang-shou-ji-ru-he-zhua-qu-you-xiao-log" class="header-anchor">#</a></h3><ol>
<li>可正常开机</li>
</ol>
<p>A：MTKlogger基本足矣</p>
<ol>
<li>卡logo，不开机</li>
</ol>
<p>A：</p>
<ul>
<li>刷入eng的lk和boot，再跳线抓取uart log，并开启logcat抓取从开机到异常出现时的所有底层和上层log</li>
<li>如果偶尔可以开机，第一时间进入系统提取db信息</li>
<li>如上述方式无法提取到关键db，则需要通过flashtool来回读db的原始raw分区，再通过自制expdb解压工具展开</li>
</ul>
<h3 id="debug-jie-duan-shou-ji-ru-he-zhua-qu-you-xiao-log"><a href="#debug阶段，手机如何抓取有效log" class="headerlink" title="debug阶段，手机如何抓取有效log"></a><strong>debug阶段，手机如何抓取有效log</strong><a href="#debug-jie-duan-shou-ji-ru-he-zhua-qu-you-xiao-log" class="header-anchor">#</a></h3><ol>
<li>无ctp情况下如何调试手机</li>
</ol>
<p>A：连接adb，通过adb发送ctp报点与手势，来操作手机</p>
<ol>
<li>无lcd情况下如何调试手机</li>
</ol>
<p>A：使用GAT工具，实时抓取手机内部frame buffer，投影到电脑上，并用adb命令操作手机</p>
<ol>
<li>UART Log量太大，无法找出重要log怎么办</li>
</ol>
<p>A：采用adb logcat方式实时过滤带关键字关键level的log （包括kernel log）</p>
<h3 id="log-fen-xi-yu-diao-shi-ji-qiao"><a href="#Log分析与调试技巧" class="headerlink" title="Log分析与调试技巧"></a><strong>Log分析与调试技巧</strong><a href="#log-fen-xi-yu-diao-shi-ji-qiao" class="header-anchor">#</a></h3><h4 id="android-kai-ji-liu-cheng-tu"><a href="#Android开机流程图" class="headerlink" title="Android开机流程图"></a><strong>Android开机流程图</strong><a href="#android-kai-ji-liu-cheng-tu" class="header-anchor">#</a></h4><p><img src="http://cdn.yangchaofan.cn/blog/20210227/Qm2wlH7QktoL.png?imageslim" alt="mark"></p>
<h4 id="bootprof"><a href="#bootprof" class="headerlink" title="bootprof"></a><strong>bootprof</strong><a href="#bootprof" class="header-anchor">#</a></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell cat &#x2F;proc&#x2F;bootprof or mktlog bootprof file</span><br></pre></td></tr></table></figure>
<p><img src="http://cdn.yangchaofan.cn/blog/20210227/Xchbq9MizBGV.png?imageslim" alt="mark"></p>
<h4 id="shi-ji-an-li-bu-kai-ji-lei"><a href="#实际案例（不开机类）" class="headerlink" title="实际案例（不开机类）"></a><strong>实际案例（不开机类）</strong><a href="#shi-ji-an-li-bu-kai-ji-lei" class="header-anchor">#</a></h4><h5 id="wen-jian-xi-tong-sun-pi-dao-zhi-gua-zai-shi-bai"><a href="#文件系统损坏导致挂载失败" class="headerlink" title="文件系统损坏导致挂载失败"></a><strong>文件系统损坏导致挂载失败</strong><a href="#wen-jian-xi-tong-sun-pi-dao-zhi-gua-zai-shi-bai" class="header-anchor">#</a></h5><p>System mount fail 导致 service 起不来，readback system分区对比看是否文件破坏。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[138:kworker&#x2F;u16:2]device-mapper: verity: 179:30: metadata block 716579 is corrupted</span><br><span class="line">[246:init]JBD2: IO error reading journal superblock</span><br><span class="line">[246:init]EXT4-fs (dm-0): error loading journal</span><br><span class="line">[246:init]fs_mgr: __mount(source&#x3D;&#x2F;dev&#x2F;block&#x2F;dm-0,target&#x3D;&#x2F;system,type&#x3D;ext4)&#x3D;-1  &lt;&lt;&#x3D;&#x3D;&#x3D;文件系统挂载失败</span><br><span class="line">[246:init]EXT4-fs (mmcblk0p31): VFS: Can&#39;t find ext4 filesystem</span><br><span class="line">12345</span><br></pre></td></tr></table></figure>
<p>经常遇到无法开机的问题，低概率、难复现，而且软、硬体跨度大，不易掌握与追踪；</p>
<p>事后分析:</p>
<p>部分有硬件实际损坏、系统映像档被破坏，或用户拔电池导致系统核心文件损坏…等几种原因。其中一部分导致无法开机的问题是由于不当操作使得文件损坏导致的。</p>
<p>PS:产线也会报小概率不开机的问题。</p>
<p>Donwload完整性检查和开机检查客制化</p>
<p>检查kernel log是否有<strong>emmc i/o error</strong>相关log</p>
<p>如果是单机问题检查emmc相关供电或作替换物料交叉实验</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ 5.030802] &lt;0&gt;.(0)[165:mmcqd&#x2F;0]mmcblk0: error -110 transferring data, sector 5448262, nr 442, cmd</span><br><span class="line">response 0x900, card status 0x0</span><br><span class="line">[ 5.032358] &lt;0&gt;.(0)[165:mmcqd&#x2F;0]blk_update_request: I&#x2F;O error, dev mmcblk0, sector 5448262</span><br><span class="line">[ 5.130190] &lt;0&gt;.(0)[179:init]EXT4-fs (dm-0): unable to read superblock</span><br><span class="line">[ 5.131325] &lt;0&gt;.(0)[179:init]fs_mgr: __mount(source&#x3D;&#x2F;dev&#x2F;block&#x2F;dm-0,target&#x3D;&#x2F;system,type&#x3D;ext4)&#x3D;-1  &lt;&lt;&#x3D;&#x3D;&#x3D;文件系统挂载失败</span><br><span class="line">12345</span><br></pre></td></tr></table></figure>
<h5 id="preloader-hang-by-mem-test-fail"><a href="#preloader-hang-by-mem-test-fail" class="headerlink" title="preloader hang by mem test fail"></a><strong>preloader hang by mem test fail</strong><a href="#preloader-hang-by-mem-test-fail" class="header-anchor">#</a></h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[50:31:154] [MEM] complex R&#x2F;W mem test fail :FFFFFFFF</span><br><span class="line">[50:31:155] &lt;ASSERT&gt; memory.c:line 105 0</span><br><span class="line">[50:31:155] PL fatal error</span><br><span class="line">[50:31:155] PL delay for Long Press Reboot</span><br><span class="line">[50:31:159] power key is pressed</span><br><span class="line">[50:36:117] [PLF]Emergency Dwld mode(timeout: 5s)</span><br><span class="line">[50:36:119] mtk_arch_reset at pre-loader!</span><br><span class="line">1234567</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>场景追溯</strong></li>
</ul>
<ol>
<li>此问题发生的背景，是产线样机？研发样机？还是客退机？</li>
<li>问题发生概率如何？有固定的复现路径吗？目前遇到的问题是在什么测试下发生的？</li>
<li>问题发生是在一台机器，还是多台机器都有遇到？—- 如果是单机问题该memory硬件问题可能性大</li>
<li>用料是否为MTK QVL上已经验证OK的？其他项目上是否已经使用过？</li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
        <category>BugFree</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>BugFree</tag>
      </tags>
  </entry>
  <entry>
    <title>BugFree三剑客异常、日志、工具</title>
    <url>/ye-jincheng-website/blog/2021/02/android-bugfree-three-lines/</url>
    <content><![CDATA[<h1 id="bugfree-san-jian-ke-yi-chang-ri-zhi-gong-ju-android-kai-fa-pai-cha-wen-ti-xiao-jie"><a href="#BugFree三剑客异常、日志、工具—Android开发排查问题小结" class="headerlink" title="BugFree三剑客异常、日志、工具—Android开发排查问题小结"></a>BugFree三剑客异常、日志、工具—Android开发排查问题小结<a href="#bugfree-san-jian-ke-yi-chang-ri-zhi-gong-ju-android-kai-fa-pai-cha-wen-ti-xiao-jie" class="header-anchor">#</a></h1><h1 id="qian-yan"><a href="#前言" class="headerlink" title="前言"></a>前言<a href="#qian-yan" class="header-anchor">#</a></h1><p>程序员编写程序、调试代码的时候不可避免的会遇到各种问题，如页面显示不正确，如数据层数据组装操作未按照期望的业务逻辑执行。</p>
<p>造成这些问题的原因大多分为以下几种：有些是条件语句执行错误，有些是Java层的Exception如空指针、集合边界越界问题，有些是较难找到原因的OOM、ANR、Crash、系统SWT重启问题。面对扑面而来的问题，程序员很容易束手无策。笔者结合自己的经验，总结了BugFree中必不可少的三剑客：异常、日志、工具，期望通过这3个“帮手”，帮助各位排查开发难题。</p>
<a id="more"></a>

<h1 id="can-kao-yue-du"><a href="#参考阅读" class="headerlink" title="参考阅读"></a>参考阅读<a href="#can-kao-yue-du" class="header-anchor">#</a></h1><p><a href="/ye-jincheng-website/blog/2021/02/mtk-log/index.html">Mtk Log使用指南</a></p>
<h1 id="yi-chang"><a href="#异常" class="headerlink" title="异常"></a>异常<a href="#yi-chang" class="header-anchor">#</a></h1><h2 id="yi-chang-de-fen-lei"><a href="#异常的分类" class="headerlink" title="异常的分类"></a>异常的分类<a href="#yi-chang-de-fen-lei" class="header-anchor">#</a></h2><p>Android是一个庞大而复杂的系统，涉及多种语言，所以其异常也很复杂。根据android系统架构层次，我们也把android异常层次化，分为JE、NE、KE、EE、其他类别</p>
<table>
<thead>
<tr>
<th>w</th>
<th>w</th>
</tr>
</thead>
<tbody><tr>
<td>JE <br>(Java layer exception)</td>
<td>一般是在应用层和框架层发生的异常，通常是由Java代码，XML代码引起的。比如各种RuntimeException, ANR（Application Not Responding）、SWT（Software Watchdog Timeout）等</td>
</tr>
<tr>
<td>NE <br>(Native layer exception)</td>
<td>发生在Linux用户空间的异常，通常是由C/C++代码和库文件引起的。比如内核发出的NE信号（SIGILL、 SIGABRT、 SIGBUS等）</td>
</tr>
<tr>
<td>KE<br> (Kernel layer execption)</td>
<td>通常指内核故障或内核错误，由于在内核模式下出错，这类异常是非常严重的，往往会导致重启、死机或无法开机等</td>
</tr>
<tr>
<td>EE <br>(External (Modem) exception)</td>
<td>从名字看就能猜到Modem这一部分是比较特殊的，独立的。Modem有自己的内存空间和代码，为手机通讯提供服务，一旦这一部分发生异常，需要MDlog，此log需用AEE-LogVie工具解析，解析是需要对应版本的数据文件</td>
</tr>
</tbody></table>
<h1 id="ri-zhi"><a href="#日志" class="headerlink" title="日志"></a>日志<a href="#ri-zhi" class="header-anchor">#</a></h1><h2 id="yong-tu"><a href="#用途" class="headerlink" title="用途"></a>用途<a href="#yong-tu" class="header-anchor">#</a></h2><h3 id="sou-suo-guan-jian-yi-chang"><a href="#搜索关键异常" class="headerlink" title="搜索关键异常"></a><strong>搜索关键异常</strong><a href="#sou-suo-guan-jian-yi-chang" class="header-anchor">#</a></h3><p><strong>1.常见应用crash</strong></p>
<p>（系统提示***已停止运行） 可以在main log中或crash_log中直接搜索“ fatal exception” ；也可以在event_log中搜索am_crash快速定位到问题</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>原理</th>
</tr>
</thead>
<tbody><tr>
<td>uncaughtException</td>
<td>Android 顶级异常捕获</td>
</tr>
<tr>
<td>Exception</td>
<td>Java 异常基类</td>
</tr>
<tr>
<td>NetworkOnMainThreadException</td>
<td>网络异常</td>
</tr>
<tr>
<td>ANR Warning</td>
<td>ANR TAG</td>
</tr>
<tr>
<td>Application Not Response</td>
<td>ANR TAG</td>
</tr>
<tr>
<td>FATAL</td>
<td>异常 TAG</td>
</tr>
<tr>
<td>ANRManager</td>
<td>ANR TAG</td>
</tr>
<tr>
<td>Log的TAG</td>
<td>Log工具类的TAG</td>
</tr>
</tbody></table>
<p><strong>2.应用闪退</strong></p>
<p>应用闪退一般有如下三种原因：</p>
<p>1).目前遇到最多的主要是因为low memory killer机制在内存达到一定阈值的时候会将大于对应adj进程给kill掉（这个一般在kernel log中搜索关键字“ low memory kill ”就可以确认哪些是因为lmk机制而被kill）;一般此情况下跟性能有关……。 </p>
<p>2). 关联进程被kill导致;</p>
<p><img src="E:\学习资料\mtklog学习\kill.png" alt="kill"></p>
<p>一般在进行闪退分析时可以在events log中搜索关键字” am_kill “或者” in dying proc “等</p>
<p>3).应用本身逻辑有执行finish动作而出现，比如点击锁屏通知进入某个对应界面而界面没有出现，这种情况需要分析对应的main_log、event_log；</p>
<p>a：根据出现闪退时间点在event_log搜索am_resume_activity等am_*_activity相关判断这过程中应用是否有启动和退出的动作。 </p>
<p>b: 在main_log或sys_log搜索“ACT-AM_”相关信息查看对应activy生命周期相关信息。</p>
<p>其次就根据log跟踪对应代码流程……</p>
<h3 id="sou-suo-oom"><a href="#搜索OOM" class="headerlink" title="搜索OOM"></a>搜索OOM<a href="#sou-suo-oom" class="header-anchor">#</a></h3><h4 id="oom-miao-shu"><a href="#OOM描述" class="headerlink" title="OOM描述"></a>OOM描述<a href="#oom-miao-shu" class="header-anchor">#</a></h4><p>Android应用内存管理机制是在Java内存管理机制基础上改进的，所以造成OOM的原因两者差不多，即所有对象都在堆上分配空间，堆是有大小限制的，当分配的对象不能被回收仍然占据堆空间，新分配的对象不能获取足够的堆空间时，就会OOM。为什么会这样呢？这就是GC不足的地方，GC只能回收自己记录（有向树）里面不可达的对象，对可达对象认为是有用的，不会被回收。但是可达对象并非一定是有用对象，他们可能是废弃对象（死对象、冗余对象、电灯泡，僵尸），但却无法被GC回收，占据着进程堆空间，下面是网上的一个对象实例化简图</p>
<img src="http://images2015.cnblogs.com/blog/625153/201704/625153-20170420202014712-1062539791.jpg">



<h4 id="oom-qing-jing"><a href="#OOM情景" class="headerlink" title="OOM情景"></a>OOM情景<a href="#oom-qing-jing" class="header-anchor">#</a></h4><p>资源对象没有回收，如cursor，bitmap等</p>
<p>1通常关闭Cursor的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cursor cursor = mDownloadManager.query(<span class="keyword">new</span> Query());</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cursor.moveToFirst()) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> index = cursor.getColumnIndex(DownloadManager.COLUMN_ID);</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> downloadId = cursor.getLong(index);</span><br><span class="line"></span><br><span class="line">ids.add(downloadId);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">while</span> (cursor.moveToNext());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">cursor.close();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>另外，在adapter中使用cursor时，需在cursor改变的时候先关闭原来的cursor， 但通常我们都是用android提供的CursorAdapter，其changeCursor函数会将原来的Cursor释放掉，并替换为新的Cursor，所以你不用担心原来的Cursor没有被关闭。</p>
<p>2 注册没有对应的去注册，如各种监听</p>
<p>3 生命周期问题引起的无法回收，如果static、线程等</p>
<p>4其他所有发生OOM情景最终都可以认为是对象没有被回收，如，cursor没有close()，bitmap没有recycle()，监听没有unregister…()等等都是因为对象没有被回收，GC认为这些对象是可达的、正在使用的，导致这些应该被回收的对象不能被回收，最终造成OOM。</p>
<p>大多数的回收方法，如close()、recycle()、unregister…()，其实都是把不再使用的对象置为null，这样GC就能回收原来对象所占空间。所以在编程的时候，对全局变量，特别是容器之类的对象和status 修饰对象，要关注其生命周期，不再需要就及时置为null或调用相应的回收方法</p>
<h4 id="oom-de-fen-xi-si-lu"><a href="#OOM的分析思路" class="headerlink" title="OOM的分析思路"></a>OOM的分析思路<a href="#oom-de-fen-xi-si-lu" class="header-anchor">#</a></h4><h5 id="gong-ju-zhun-bei"><a href="#工具准备" class="headerlink" title="工具准备"></a>工具准备<a href="#gong-ju-zhun-bei" class="header-anchor">#</a></h5><p>1.log</p>
<p>2.MAT</p>
<p>3.Profiler</p>
<p>4.hprof</p>
<h5 id="fu-xian-chang-jing"><a href="#复现场景" class="headerlink" title="复现场景"></a>复现场景<a href="#fu-xian-chang-jing" class="header-anchor">#</a></h5><p>1.按log所显示的步骤，多次重复该步骤</p>
<p>2.抓取hrof日志</p>
<p>3.设定怀疑点</p>
<p>4.打印该点的内存大小，如bitmap、集合、集合持有的对象</p>
<h5 id="que-ren-huai-yi-dian"><a href="#确认怀疑点" class="headerlink" title="确认怀疑点"></a>确认怀疑点<a href="#que-ren-huai-yi-dian" class="header-anchor">#</a></h5><p>及时释放掉该对象</p>
<h4 id="oom-fen-lei"><a href="#OOM分类" class="headerlink" title="OOM分类"></a>OOM分类<a href="#oom-fen-lei" class="header-anchor">#</a></h4><p>内存泄露</p>
<ul>
<li>Context泄露</li>
<li>Handler泄露</li>
<li>Cache泄漏</li>
<li>线程未释放导致的泄漏</li>
</ul>
<p>内存抖动</p>
<ul>
<li>频繁创建对象</li>
</ul>
<p>内存溢出</p>
<ul>
<li>可用内存不足</li>
<li>瞬时申请内存超过了系统可分配内存</li>
<li>大图、长图、宽图</li>
<li>序列过多的图片</li>
</ul>
<h4 id="oom-you-hua-si-lu"><a href="#OOM优化思路" class="headerlink" title="OOM优化思路"></a>OOM优化思路<a href="#oom-you-hua-si-lu" class="header-anchor">#</a></h4><p>这些问题大多是比较难解的问题，大部分都是随机的，往往都是很难复现的，找出规律是很重要的！</p>
<p>另外，内存泄露不容易发现，一些轻微的泄露，可能要使用一个月才能发现，所以对自己的模块，要自己去检查有没有OOM，可以下班时挂上monkey，有时候是能跑出来的</p>
<p>从OOM联想到性能问题，性能问题很多是界面刷新、对象生命周期、冗余操作、不必要的线程等引起的……</p>
<h3 id="sou-suo-swt"><a href="#搜索SWT" class="headerlink" title="搜索SWT"></a>搜索SWT<a href="#sou-suo-swt" class="header-anchor">#</a></h3><table>
<thead>
<tr>
<th>序号</th>
<th>步骤</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><img src="http://cdn.yangchaofan.cn/blog/20210227/MTCwv77J4QE9.png"></td>
</tr>
<tr>
<td></td>
<td><img src="http://cdn.yangchaofan.cn/blog/20210227/iedG22YWjV1n.png"></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>具体信息主要查找log文件有sys_log和mtklog\aee_exp\db.fatal.00.SWT\db.fatal.00.SWT.dbg.DEC</p>
<h3 id="sou-suo-si-ji"><a href="#搜索死机" class="headerlink" title="搜索死机"></a>搜索死机<a href="#sou-suo-si-ji" class="header-anchor">#</a></h3><p>这里说的死机就是冻屏，停留在一个界面没反应。死机问题很少遇到，且大多不是一个用层问题，下面简单说下可能造成死机的原因和分析需要信息</p>
<h4 id="gong-ju-zhun-bei"><a href="#工具准备-1" class="headerlink" title="工具准备"></a>工具准备<a href="#gong-ju-zhun-bei" class="header-anchor">#</a></h4><p>MTK提供了多种抓取和查看LOG的工具, 如:mtklogger，GAT，Catcher，LogView，QAAT等，这些工具在文档《MediaTek_Logging_SOP》中都有描述</p>
<p><img src="http://cdn.yangchaofan.cn/blog/20210227/382aVmPG0k6V.jpg?imageslim" alt="mark"></p>
<h5 id="mtklogger"><a href="#Mtklogger" class="headerlink" title="Mtklogger*"></a>Mtklogger*<a href="#mtklogger" class="header-anchor">#</a></h5><p>Mtklogger是抓取log的apk，整合了ModemLog，MobileLog，NetworkLog and SystemLogger，在工程模式操作就可以打相关log了。</p>
<h5 id="gat"><a href="#GAT" class="headerlink" title="GAT"></a><strong>GAT</strong><a href="#gat" class="header-anchor">#</a></h5><p>基于SDK调试开发的GUI工具，新增了Log Recoder，Debug Configuration Setting，DBpuller，adb command，Process Information view，Profiling Tools，LogView，Plug-in Script。是调试和抓log的神器，使用说明阅读文档《GAT_User_Guide(Customer).pdf》</p>
<p>工具获取路径（以W1444版本为例）：</p>
<p>私服SVN：\rd\MTK_TOOL\AndroidTool\W1444\W1444_full.zip\Debugging Tools (Binary)\GAT</p>
<h5 id="catcher"><a href="#Catcher" class="headerlink" title="Catcher"></a><strong>Catcher</strong><a href="#catcher" class="header-anchor">#</a></h5><p>是抓取和解析ModemLog的PC端工具，我们经常使用来查看ModemLog，使用说明阅读文档《Catcher_User_Manual_for_Customer.pdf》</p>
<p>工具获取路径：</p>
<p>私服SVN：\rd\MTK_TOOL\AndroidTool\W1444\W1444_full.zip\Catcher</p>
<h5 id="logview"><a href="#LogView" class="headerlink" title="LogView"></a><strong>LogView</strong><a href="#logview" class="header-anchor">#</a></h5><p>可以查看APlog，Taglog，MTKlog，但最常用的是用来查看NE时产生的AEE DB文件里的log，具体使用参考《GAT_User_Guide(Customer).pdf》</p>
<p>工具获取路径：</p>
<p>此工具已集成到GAT</p>
<h5 id="qaat"><a href="#QAAT" class="headerlink" title="QAAT"></a><strong>QAAT</strong><a href="#qaat" class="header-anchor">#</a></h5><p>快速分析log的工具，涵盖错误类型较广，很多地方都可以用，其实他的原理就是过滤关键字，把各种类型的错误过滤出来，是一个分析LOG非常便捷的工具，具体使用参考《MediaTek_Logging_SOP.pdf》</p>
<p><strong>死机可能原因：</strong></p>
<ol>
<li><p>输入系统或者输入驱动问题</p>
</li>
<li><p>系统逻辑问题或阻塞</p>
</li>
<li><p>Surfacefinger问题</p>
</li>
<li><p>显示系统或LCM驱动问题</p>
</li>
</ol>
<p><strong>相关信息和抓log：</strong></p>
<ol>
<li><p>确认adb是否可用</p>
</li>
<li><p>抓取bugreport，adb bugreport &gt; d:/bugreport.txt</p>
</li>
<li><p>抓取dumpstate信息，adb shell dumpstate &gt; d:/dumpstate.txt</p>
</li>
<li><p>抓取CPU信息，adb shell top –t –m 5 &gt; d:/cpu.txt</p>
</li>
<li><p>确认是否可以拨打电话，adb shell am start –a android.intent.action.CALL tel:10086(看界面是否能够更新)</p>
</li>
<li><p>查看按键和触屏报点，adb shell getevent</p>
</li>
<li><p>抓取Surfacefinger进程信息，先adb shell ps –p找出pid，然后使用adb shell rtt –f bt –p pid &gt; rtt.txt</p>
</li>
</ol>
<h3 id="sou-suo-chong-qi"><a href="#搜索重启" class="headerlink" title="搜索重启"></a>搜索重启<a href="#sou-suo-chong-qi" class="header-anchor">#</a></h3><p>从异常分类来看，重启异常大多数和NE、KE和硬件问题有关，JE方面引起重启死机大多是和系统进程有关，如system_process进程发生了Crash、SWT、JVM Error，AP应用一般是不会引起重启死机的，但偶尔也会</p>
<p>72平台上，发送短信内容为‘==’时会重启</p>
<img src="http://images2015.cnblogs.com/blog/625153/201704/625153-20170420202046243-314090766.jpg">



<p>虽然是Mms引起的，但最终也是System_process挂掉了，导致重启</p>
<p>重启异常分析步骤（JE）：</p>
<ol>
<li><p>确认异常类型（用QAAT跑一下做初步判断，如果是NE、KE让驱动人员帮忙解决）</p>
</li>
<li><p>找到第一时间发生错误的地方，因为后面的错误多半是因为前面错误引起的，那就没有意义</p>
</li>
<li><p>根据JE类型，结合对应工具分析LOG</p>
</li>
</ol>
<h3 id="sou-suo-anr"><a href="#搜索ANR" class="headerlink" title="搜索ANR"></a>搜索ANR<a href="#sou-suo-anr" class="header-anchor">#</a></h3><h4 id="anr-ding-yi"><a href="#ANR定义" class="headerlink" title="ANR定义"></a><strong>ANR定义</strong><a href="#anr-ding-yi" class="header-anchor">#</a></h4><p>Application Not Responding</p>
<h4 id="anr-chong-lei"><a href="#ANR种类" class="headerlink" title="ANR种类"></a><strong>ANR种类</strong><a href="#anr-chong-lei" class="header-anchor">#</a></h4><p><strong>1). Key Dispatch Timeout (8s)</strong></p>
<p>按键或触摸事件在特定时间内无响应（origin:5s）</p>
<p>KEY_DISPATCHING_TIMEOUT = 8*1000</p>
<p><strong>2) .Broadcast Timeout</strong></p>
<p>BroadcastReceiver在特定时间内无法处理完成</p>
<p>BROADCAST_FG_TIMEOUT: 10s</p>
<p>BROADCAST_BG_TIMEOUT: 60s</p>
<p>按键和广播事件时间内未响应，时间限定定义在<strong>ActivityManagerService.java</strong>类中</p>
<p><strong>3).Service Timeout （20s）——-小概率类型</strong></p>
<p>Service在特定的时间内无法处理完成</p>
<p>service时间内未响应时间限定在<strong>ActiveServices.java</strong>类中</p>
<p>SERVICE_TIMEOUT = 20*1000;</p>
<h4 id="anr-yuan-yin"><a href="#ANR原因" class="headerlink" title="ANR原因"></a>ANR原因<a href="#anr-yuan-yin" class="header-anchor">#</a></h4><p>1）应用进程有一个主线程（main thread）和一个信息队列(main message queue) main thead == activity thread</p>
<p>2）主线程负责处理像Draw、Listen、receive等UI事件</p>
<p>3）主线程负责从消息队列中取出信息并分发它</p>
<p>4）主线程在完成当前信息处理之前，不会再取信息队列中的信息</p>
<p>5）如果主线程在处理当前信息时卡住，没有及时分发，ANR就会出现</p>
<h4 id="anr-de-fen-xi-si-lu"><a href="#ANR的分析思路" class="headerlink" title="ANR的分析思路"></a>ANR的分析思路<a href="#anr-de-fen-xi-si-lu" class="header-anchor">#</a></h4><h5 id="gong-ju-zhun-bei"><a href="#工具准备-2" class="headerlink" title="工具准备"></a>工具准备<a href="#gong-ju-zhun-bei" class="header-anchor">#</a></h5><p>1 MTKlog，主要是其中的Aee_exp和MobileLog</p>
<p>2Trace.txt文件（data/anr目录下）或者bugreport日志（使用adb bugreport &gt; bugreport.txt或者GAT工具输出）</p>
<p>3BlockCanary，记录超时后的log</p>
<p>4一般当出现异常（JE\SWT\NE\KE等）时，会在手机中的/data/aee_exp目录下保存异常的db。 对于异常的类型和具体信息，需要通过GAT工具解析db档案</p>
<p>5.bugreport</p>
<p>6.aee_exp</p>
<h5 id="trace-fen-xi-liu-cheng"><a href="#Trace分析流程" class="headerlink" title="Trace分析流程"></a>Trace分析流程<a href="#trace-fen-xi-liu-cheng" class="header-anchor">#</a></h5><table>
<thead>
<tr>
<th>序号</th>
<th>步骤</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><img src="http://cdn.yangchaofan.cn/blog/20210227/iITTadTui5mQ.png?imageslim" alt="mark"></td>
</tr>
<tr>
<td></td>
<td><img src="http://cdn.yangchaofan.cn/blog/20210227/JwYHHTncMMip.png?imageslim" alt="mark"></td>
</tr>
<tr>
<td></td>
<td><img src="http://cdn.yangchaofan.cn/blog/20210227/VkiuF6SpNL7b.png?imageslim" alt="mark"></td>
</tr>
<tr>
<td></td>
<td><img src="http://cdn.yangchaofan.cn/blog/20210227/FwcDyrQFhFAa.png?imageslim" alt="mark"></td>
</tr>
<tr>
<td></td>
<td><img src="http://cdn.yangchaofan.cn/blog/20210227/poTh8Et0Or0w.png?imageslim" alt="mark"></td>
</tr>
<tr>
<td></td>
<td><img src="http://cdn.yangchaofan.cn/blog/20210227/5M4Dwh0H2ugg.png?imageslim" alt="mark"></td>
</tr>
<tr>
<td></td>
<td><img src="http://cdn.yangchaofan.cn/blog/20210227/2H8AlTBdueFO.png?imageslim" alt="mark"></td>
</tr>
<tr>
<td></td>
<td><img src="http://cdn.yangchaofan.cn/blog/20210227/Dl36A6cYlbzF.png?imageslim" alt="mark"></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="anr-jie-jue-fang-an"><a href="#ANR解决方案" class="headerlink" title="ANR解决方案"></a>ANR解决方案<a href="#anr-jie-jue-fang-an" class="header-anchor">#</a></h4><p>1)：UI线程尽量只做跟UI相关的工作</p>
<p>2)：耗时的工作（比如数据库操作，I/O，连接网络或者别的有可能阻碍UI线程的操作）把它放入单独的线程处理</p>
<p>3)：尽量用Handler来处理UIthread和别的thread之间的交互</p>
<h4 id="anr-you-hua-si-lu"><a href="#ANR优化思路" class="headerlink" title="ANR优化思路"></a>ANR优化思路<a href="#anr-you-hua-si-lu" class="header-anchor">#</a></h4><p>优化UI线程的任务：</p>
<p>1)：UI线程尽量只做跟UI相关的工作</p>
<p>2)：耗时的工作（比如数据库操作，I/O，连接网络或者别的有可能阻碍UI线程的操作）把它放入单独的线程处理</p>
<p>3)：尽量用Handler来处理UIthread和别的thread之间的交互</p>
<p>UI线程的主要任务是：</p>
<p>1).Activity:onCreate(), onResume(), onDestroy(), onKeyDown(), onClick()等</p>
<p>2).AsyncTask: onPreExecute(), onProgressUpdate(), onPostExecute(), onCancel等</p>
<p>3).Mainthread handler: handleMessage(), post*(runnable r)等</p>
<h1 id="gong-ju"><a href="#工具" class="headerlink" title="工具"></a>工具<a href="#gong-ju" class="header-anchor">#</a></h1><table>
<thead>
<tr>
<th>工具包名称</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>联发科MTK组件</td>
<td>MTKLogger</td>
</tr>
<tr>
<td></td>
<td>GAT</td>
</tr>
<tr>
<td></td>
<td>LogView</td>
</tr>
<tr>
<td></td>
<td>QAAT</td>
</tr>
<tr>
<td>BlockCanary</td>
<td>开源框架，卡顿日志</td>
</tr>
<tr>
<td>Android SDK</td>
<td>ADB LogCat</td>
</tr>
<tr>
<td></td>
<td>MAT</td>
</tr>
<tr>
<td>Android Studio</td>
<td>Profile</td>
</tr>
<tr>
<td></td>
<td>TraceView</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="adb"><a href="#adb" class="headerlink" title="adb"></a>adb<a href="#adb" class="header-anchor">#</a></h2><ol>
<li>adb logcat&gt;main.txt 重定向log</li>
<li>adb logcat -b main -v time&gt;app.log 打印应用程序的log</li>
<li>adb logcat -bradio -v time&gt; radio.log 打印射频相关的log，SIM STK 也会在里面，modem相关的ATcommand等。</li>
<li>adb logcat -bevents -v time 打印系统事件的日志，比如触屏事件；</li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
        <category>BugFree</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>BugFree</tag>
      </tags>
  </entry>
  <entry>
    <title>《学习革命解读》心得</title>
    <url>/ye-jincheng-website/blog/2021/02/learn-relovation-notes/</url>
    <content><![CDATA[<h1 id="shu-ji"><a href="#书籍" class="headerlink" title="书籍"></a>书籍<a href="#shu-ji" class="header-anchor">#</a></h1><table>
<thead>
<tr>
<th>名称</th>
<th>详情</th>
</tr>
</thead>
<tbody><tr>
<td><strong>封面</strong></td>
<td><img src="http://cdn.yangchaofan.cn/q4YBAFxP4wGABmEDAADtx3MZXfQ102_b.jpg" width="50%" height="50%"></td>
</tr>
<tr>
<td><strong>作者</strong></td>
<td><a href="https://book.douban.com/search/%E5%88%98%E8%A8%80">刘言</a></td>
</tr>
<tr>
<td><strong>出版社</strong></td>
<td>青海人民出版社</td>
</tr>
<tr>
<td><strong>介绍</strong></td>
<td>书籍每一开分为左右两页，左侧为精华总结、心得、名人关于学习的见解，对人有启发；右侧是作者的解读，主要讲了：<br>实用的学习总论如正文的思考训练、数学学习方法；<br>走出学习的困境，消除错误学习观念、消除学习疲劳的方法，消除学习的三大障碍<br>快速学习法的20个事件，如控制大脑学习韵律节奏、通过五官影响学习感受</td>
</tr>
</tbody></table>
<a id="more"></a>

<h1 id="bi-ji"><a href="#笔记" class="headerlink" title="笔记"></a>笔记<a href="#bi-ji" class="header-anchor">#</a></h1><p>印象深刻值书钱的有两部分：数学学习法和思考训练法</p>
<h2 id="si-kao-de-xun-lian"><a href="#思考的训练" class="headerlink" title="思考的训练"></a>思考的训练<a href="#si-kao-de-xun-lian" class="header-anchor">#</a></h2><table>
<thead>
<tr>
<th>训练名称</th>
<th>描述</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>抽象与概括</td>
<td>对一类事物进行分析，总结出主要特征。</td>
<td>1-6岁，抽象概括大多数来自于实物，从苹果数量学习数字的抽象<br>6-12岁，抽象开阔来自于文字、符号，如角的特征是端点、射线、平面</td>
</tr>
<tr>
<td>分类</td>
<td>把具有相同特征的事物归成一类</td>
<td>单调函数有许多函数；反比例函数也包含很多函数</td>
</tr>
<tr>
<td>类比</td>
<td>从一事物的特征而联想到另一事物，并进行比较,通常需要联想+比较</td>
<td>看到鸟，想到飞机，比较鸟和飞机的不同<br>看到圆，想到圆柱体，比较两者不同</td>
</tr>
<tr>
<td>分析与综</td>
<td>思考一个概念时，必须联系其他概念，使用上述方法</td>
<td>做一个数学题，联想该题目有关的基础概念、基本解题思路<br> 数学学习一章节，画出该章的刚要、知识结构；画出与前面章节的联系，建立连接</td>
</tr>
<tr>
<td>绎与推理</td>
<td>根据已知条件，经过思考活动推导出的结论</td>
<td>借助包含关系推导，如数轴上a大于b，b大于c，则a大于c</td>
</tr>
</tbody></table>
<h1 id="shu-xue-xue-xi-fa"><a href="#数学学习法" class="headerlink" title="数学学习法"></a>数学学习法<a href="#shu-xue-xue-xi-fa" class="header-anchor">#</a></h1><p>##定义</p>
<p>描述了学习数学学科的方法</p>
<h2 id="fang-fa"><a href="#方法" class="headerlink" title="方法"></a>方法<a href="#fang-fa" class="header-anchor">#</a></h2><h3 id="fang-fa-gai-lan"><a href="#方法概览" class="headerlink" title="方法概览"></a>方法概览<a href="#fang-fa-gai-lan" class="header-anchor">#</a></h3><table>
<thead>
<tr>
<th>名称</th>
<th>定义</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>数学归纳法</td>
<td>是证明与自然数有关的解题方法，先证明n取第一个值k0，k，k+1，分别证明命题为真，即可证明命题为真</td>
<td>证明等式<br>证明整除<br>证明不等式<br>证明数列通项公式<br>证明先猜想后结论的命题</td>
</tr>
<tr>
<td>分析综合法</td>
<td>从已知条件出发，逐步推理。是综合法。<br>从结论找条件，是分析法。<br></td>
<td>综合法是由已知找未知的解法<br>分析法是由结果找原因的方法<br>由果找因、由因找果的关键是找“可知”、“需知”的联系</td>
</tr>
<tr>
<td>分类讨论法</td>
<td>对象全体无法使用同一种方法去处理。必须分割为不重复、不遗漏的情况，分别求解</td>
<td>需要分类定义的概念如绝对值<br>需要分类描述的性质如幂函数、指数函数、对数函<br>需要对参数进行分类描述<br>图形相对位置的变化</td>
</tr>
<tr>
<td>变更问题法</td>
<td>将问题进行适当的变更，变为容易求解的问题</td>
<td>换元法<br>反证法<br>特殊化法<br>放缩变换，同乘、同除、同加、同减<br>用熟知的定力、公式、命题替换求解目标<br>分解简化欲证明的结论<br>替换等价问题<br>对图形平移、旋转、翻转、压缩变化，改变求解的范围<br>数形结合，用图形描述数字的规律</td>
</tr>
<tr>
<td>反证法</td>
<td>从否定结论出发，经过推理，得到与已知定理相矛盾的结果，并且矛盾的结果是由否定结论导致，故而得到原命题是不容否定的结论。</td>
<td>关于否定性结论的命题<br>唯一性结论的命题<br>至多、至少类结论命题<br>难以直接使用已知条件导出结论的命题</td>
</tr>
<tr>
<td>类比法</td>
<td>两个对象都有相同的属性，其中一个对象还有另外的属性是前提，做出这个对象也有这些属性的判断。</td>
<td>降维类比<br>结构类比<br>简化成比原题简单的类比<br>类比猜想</td>
</tr>
<tr>
<td>配方法</td>
<td>补充恰当的子项可以配成完全平方公式  <img src="http://cdn.yangchaofan.cn/clip_image001.png"></td>
<td>分解因式<br>化简二次根式<br>证明等式<br>证明不等式<br>解方程<br>解不等式<br>求函数的最值<br>解析几何问题<br></td>
</tr>
<tr>
<td>放缩法</td>
<td>处理数式问题，把某些项放大或缩小，舍弃或增加某些项，可以取得简化题目过程求解的效果</td>
<td>求极值<br>计算结果<br>解方程<br>解方程组<br>证明不等式<br></td>
</tr>
<tr>
<td>解析法</td>
<td>通过建立坐标系，把图形问题转化为点的坐标的数值问题</td>
<td>利用距离公式证明线段相等<br>利用定比分点公式证明比例关系<br>利用斜率证明两直线平行<br>利用斜率证明直线垂直<br>两直线夹角的正切公式证明角相等<br>利用两直线的交点坐标结合第三条直线方程证明三线共点<br>换元法</td>
</tr>
<tr>
<td>换元法</td>
<td>把某个数学式子看成新的未知数，将难题转化为已知的定理、公式</td>
<td>将数学式的整体代换<br>将数学式的整体代换<br>平均数代换<br>比值代换<br>对称代换<br>倒数代换<br>三角代换<br>不等量代换<br>常数代换<br>坐标代换</td>
</tr>
<tr>
<td>构造法</td>
<td>针对问题题型，构造该题型的辅助公式、图形</td>
<td>参考构造法策略说明</td>
</tr>
</tbody></table>
<h3 id="gou-zao-fa"><a href="#构造法" class="headerlink" title="构造法"></a>构造法<a href="#gou-zao-fa" class="header-anchor">#</a></h3><h4 id="ding-yi"><a href="#定义" class="headerlink" title="定义"></a>定义<a href="#ding-yi" class="header-anchor">#</a></h4><p>针对问题题型，构造该题型的辅助公式、图形</p>
<h4 id="ce-lue"><a href="#策略" class="headerlink" title="策略"></a>策略<a href="#ce-lue" class="header-anchor">#</a></h4><p>方程</p>
<p>函数</p>
<p>复数</p>
<p>数列</p>
<p>不等式</p>
<p>点</p>
<p>线段</p>
<p>三角形</p>
<p>正方形</p>
<p>圆</p>
<p>长方体</p>
<h3 id="huan-yuan-fa"><a href="#换元法" class="headerlink" title="换元法"></a>换元法<a href="#huan-yuan-fa" class="header-anchor">#</a></h3><h4 id="ding-yi"><a href="#定义-1" class="headerlink" title="定义"></a>定义<a href="#ding-yi" class="header-anchor">#</a></h4><p>把某个数学式子看成新的未知数，将难题转化为已知的定理、公式</p>
<h4 id="ce-lue"><a href="#策略-1" class="headerlink" title="策略"></a>策略<a href="#ce-lue" class="header-anchor">#</a></h4><p>将数学式的部分内容代换</p>
<p>将数学式的整体代换</p>
<p>平均数代换</p>
<p>比值代换</p>
<p>对称代换</p>
<p>倒数代换</p>
<p>三角代换</p>
<p>不等量代换</p>
<p>常数代换</p>
<p>坐标代换</p>
<h3 id="yong-tu"><a href="#用途" class="headerlink" title="用途"></a>用途<a href="#yong-tu" class="header-anchor">#</a></h3><p>解恒等变形的问题</p>
<p>解方程</p>
<p>解方程组</p>
<p>解不等式、证明不等式</p>
<p>求函数极值</p>
<p>解坐标变换</p>
<p>解微积分</p>
<h3 id="jie-xi-fa"><a href="#解析法" class="headerlink" title="解析法"></a>解析法<a href="#jie-xi-fa" class="header-anchor">#</a></h3><h4 id="ding-yi"><a href="#定义-2" class="headerlink" title="定义"></a>定义<a href="#ding-yi" class="header-anchor">#</a></h4><p>通过建立坐标系，把图形问题转化为点的坐标的数值问题</p>
<h4 id="yong-tu"><a href="#用途-1" class="headerlink" title="用途"></a>用途<a href="#yong-tu" class="header-anchor">#</a></h4><p>利用距离公式证明线段相等</p>
<p>利用定比分点公式证明比例关系</p>
<p>利用斜率证明两直线平行</p>
<p>利用斜率证明直线垂直</p>
<p>利用两直线夹角的正切公式证明角相等</p>
<p>利用三角形坐标面积公式证明第三点坐标适合前两点连线方程证明三点共线</p>
<p>利用两直线的交点坐标结合第三条直线方程证明三线共点</p>
<p>换元法</p>
<h3 id="fang-suo-fa"><a href="#放缩法" class="headerlink" title="放缩法"></a>放缩法<a href="#fang-suo-fa" class="header-anchor">#</a></h3><h4 id="ding-yi"><a href="#定义-3" class="headerlink" title="定义"></a>定义<a href="#ding-yi" class="header-anchor">#</a></h4><p>处理数式问题，把某些项放大或缩小，舍弃或增加某些项，可以取得简化题目过程求解的效果</p>
<h4 id="yong-tu"><a href="#用途-2" class="headerlink" title="用途"></a>用途<a href="#yong-tu" class="header-anchor">#</a></h4><p>求极值</p>
<p>计算结果</p>
<p>解方程</p>
<p>解方程组</p>
<p>证明不等式</p>
<h3 id="pei-fang-fa"><a href="#配方法" class="headerlink" title="配方法"></a>配方法<a href="#pei-fang-fa" class="header-anchor">#</a></h3><h4 id="ding-yi"><a href="#定义-4" class="headerlink" title="定义"></a>定义<a href="#ding-yi" class="header-anchor">#</a></h4><p>补充恰当的子项可以配成完全平方公式  <img src="http://cdn.yangchaofan.cn/clip_image001.png"></p>
<h4 id="yong-tu"><a href="#用途-3" class="headerlink" title="用途"></a>用途<a href="#yong-tu" class="header-anchor">#</a></h4><p>分解因式</p>
<p>化简二次根式</p>
<p>证明等式</p>
<p>证明不等式</p>
<p>解方程</p>
<p>解不等式</p>
<p>求函数的最值</p>
<p>解析几何问题</p>
<h3 id="lei-bi-fa"><a href="#类比法" class="headerlink" title="类比法"></a>类比法<a href="#lei-bi-fa" class="header-anchor">#</a></h3><h4 id="ding-yi"><a href="#定义-5" class="headerlink" title="定义"></a>定义<a href="#ding-yi" class="header-anchor">#</a></h4><p>两个对象都有相同的属性，其中一个对象还有另外的属性是前提，做出这个对象也有这些属性的判断。</p>
<h4 id="ce-lue"><a href="#策略-2" class="headerlink" title="策略"></a>策略<a href="#ce-lue" class="header-anchor">#</a></h4><p>降维类比</p>
<p>结构类比</p>
<p>简化成比原题简单的类比</p>
<p>类比猜想</p>
<h3 id="fan-zheng-fa"><a href="#反证法" class="headerlink" title="反证法"></a>反证法<a href="#fan-zheng-fa" class="header-anchor">#</a></h3><h4 id="ding-yi"><a href="#定义-6" class="headerlink" title="定义"></a>定义<a href="#ding-yi" class="header-anchor">#</a></h4><p>从否定结论出发，经过推理，得到与已知定理相矛盾的结果，并且矛盾的结果是由否定结论导致，故而得到原命题是不容否定的结论。</p>
<h4 id="yong-tu"><a href="#用途-4" class="headerlink" title="用途"></a>用途<a href="#yong-tu" class="header-anchor">#</a></h4><p>关于否定性结论的命题</p>
<p>唯一性结论的命题</p>
<p>至多、至少类结论命题</p>
<p>难以直接使用已知条件导出结论的命题<img src="file:///C:/Users/lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image001.png" alt="img"></p>
<h3 id="bian-geng-wen-ti-fa"><a href="#变更问题法" class="headerlink" title="变更问题法"></a>变更问题法<a href="#bian-geng-wen-ti-fa" class="header-anchor">#</a></h3><p>又称化繁为简</p>
<h4 id="ding-yi"><a href="#定义-7" class="headerlink" title="定义"></a>定义<a href="#ding-yi" class="header-anchor">#</a></h4><p>将问题进行适当的变更，变为容易求解的问题</p>
<h4 id="ce-lue"><a href="#策略-3" class="headerlink" title="策略"></a>策略<a href="#ce-lue" class="header-anchor">#</a></h4><p>换元法</p>
<p>反证法</p>
<p>特殊化法</p>
<p>用熟知的定力、公式、命题替换求解目标</p>
<p>分解简化欲证明的结论</p>
<p>替换等价问题</p>
<p>对图形平移、旋转、翻转、压缩变化，改变求解的范围</p>
<p>数形结合，用图形描述数字的规律</p>
<p>放缩变换，同乘、同除、同加、同减</p>
<h3 id="shu-xue-gui-na-fa"><a href="#数学归纳法" class="headerlink" title="数学归纳法"></a>数学归纳法<a href="#shu-xue-gui-na-fa" class="header-anchor">#</a></h3><h4 id="ding-yi"><a href="#定义-8" class="headerlink" title="定义"></a>定义<a href="#ding-yi" class="header-anchor">#</a></h4><p>是证明与自然数有关的解题方法，先证明n取第一个值k0，k，k+1，分别证明命题为真，即可证明命题为真</p>
<h4 id="yong-tu"><a href="#用途-5" class="headerlink" title="用途"></a>用途<a href="#yong-tu" class="header-anchor">#</a></h4><p>证明等式</p>
<p>证明整除</p>
<p>证明不等式</p>
<p>证明数列通项公式</p>
<p>证明先猜想后结论的命题</p>
<h3 id="fen-xi-zong-he-fa"><a href="#分析综合法" class="headerlink" title="分析综合法"></a>分析综合法<a href="#fen-xi-zong-he-fa" class="header-anchor">#</a></h3><h4 id="ding-yi"><a href="#定义-9" class="headerlink" title="定义"></a>定义<a href="#ding-yi" class="header-anchor">#</a></h4><p>从已知条件出发，逐步推理。是综合法。</p>
<p>综合法是由已知找未知的解法</p>
<p>从结论找条件，是分析法。</p>
<p>分析法是由结果找原因的方法。</p>
<h4 id="yong-tu"><a href="#用途-6" class="headerlink" title="用途"></a>用途<a href="#yong-tu" class="header-anchor">#</a></h4><p>由果找因、由因找果的关键是找“可知”、“需知”的联系</p>
<h3 id="fen-lei-tao-lun-fa"><a href="#分类讨论法" class="headerlink" title="分类讨论法"></a>分类讨论法<a href="#fen-lei-tao-lun-fa" class="header-anchor">#</a></h3><h4 id="ding-yi"><a href="#定义-10" class="headerlink" title="定义"></a>定义<a href="#ding-yi" class="header-anchor">#</a></h4><p>对象全体无法使用同一种方法去处理。必须分割为不重复、不遗漏的情况，分别求解。</p>
<h4 id="bu-zou"><a href="#步骤" class="headerlink" title="步骤"></a>步骤<a href="#bu-zou" class="header-anchor">#</a></h4><p>确定标准</p>
<p>恰当分类</p>
<p>逐类讨论</p>
<p>归纳结论</p>
<h4 id="yong-tu"><a href="#用途-7" class="headerlink" title="用途"></a>用途<a href="#yong-tu" class="header-anchor">#</a></h4><p>需要分类定义的概念如绝对值</p>
<p>需要分类描述的性质如幂函数、指数函数、对数函数</p>
<p>需要对参数进行分类描述</p>
<p>图形相对位置的变化</p>
<h3 id="zhi-shi-ti-xi"><a href="#知识体系" class="headerlink" title="知识体系"></a>知识体系<a href="#zhi-shi-ti-xi" class="header-anchor">#</a></h3><h3 id="pei-tu"><a href="#配图" class="headerlink" title="配图"></a>配图<a href="#pei-tu" class="header-anchor">#</a></h3><p>流程图、概念图、思维导图、学科专业配图等</p>
<h1 id="zong-jie"><a href="#总结" class="headerlink" title="总结"></a>总结<a href="#zong-jie" class="header-anchor">#</a></h1><p>本书读了几章，有什么收获，对之前知识点有什么影响，对未来的什么方面有影响</p>
<p>可以把什么知识点用在什么地方，可以获得哪些利益，潜在风险是什么</p>
]]></content>
      <categories>
        <category>家庭教育</category>
        <category>学习方法</category>
      </categories>
      <tags>
        <tag>学习方法</tag>
      </tags>
  </entry>
  <entry>
    <title>《高效学习方法全集》日记</title>
    <url>/ye-jincheng-website/blog/2021/02/super-learn-skills/</url>
    <content><![CDATA[<h1 id="gao-xiao-xue-xi-fang-fa-quan-ji-gao-zhong-ban"><a href="#高效学习方法全集高中版" class="headerlink" title="高效学习方法全集高中版"></a>高效学习方法全集高中版<a href="#gao-xiao-xue-xi-fang-fa-quan-ji-gao-zhong-ban" class="header-anchor">#</a></h1><table>
<thead>
<tr>
<th>名称</th>
<th>详情</th>
</tr>
</thead>
<tbody><tr>
<td><strong>封面</strong></td>
<td><img src="http://cdn.yangchaofan.cn/%E9%AB%98%E6%95%88%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E9%AB%98%E4%B8%AD%E7%89%88.jpg" width="50%" height="50%"></td>
</tr>
<tr>
<td><strong>作者</strong></td>
<td>新教育学习研究机构</td>
</tr>
<tr>
<td><strong>出版社</strong></td>
<td>湖北教育出版社</td>
</tr>
<tr>
<td><strong>介绍</strong></td>
<td>此书有许多状元的学习经验方法总结。譬如预习一节，关于预习的3个目的；譬如复习一节，黄金五分钟和睡前复习法，譬如如何做题一章有做题的禁忌、题目的选择、做题的时机、做题的思考、最后总结等</td>
</tr>
</tbody></table>
<a id="more"></a>

<h1 id="bi-ji"><a href="#笔记" class="headerlink" title="笔记"></a>笔记<a href="#bi-ji" class="header-anchor">#</a></h1><h1 id="yu-xi"><a href="#预习" class="headerlink" title="预习"></a>预习<a href="#yu-xi" class="header-anchor">#</a></h1><p>##定义</p>
<p>是学习的第一步，作为听课的前置条件。</p>
<h2 id="fang-fa"><a href="#方法" class="headerlink" title="方法"></a>方法<a href="#fang-fa" class="header-anchor">#</a></h2><h3 id="yu-xi-de-mu-de"><a href="#预习的目的" class="headerlink" title="预习的目的"></a>预习的目的<a href="#yu-xi-de-mu-de" class="header-anchor">#</a></h3><p>知晓当前章节的知识结构，准确知道老师讲的内容在知识结构的那一位置</p>
<p>跟旧章节知识建立联系，混淆、易错的地方集中精力克服</p>
<p>通过课后题检验预习的结果</p>
<p>跟上老师的节奏，超过老师的节奏，集中精力和时间思考重点、难点</p>
<p>提前知晓课本上有什么</p>
<p>老师讲的内容是否是课本上的，有选择性的记课本上没有的内容笔记</p>
<p>记老师反复提及的笔记</p>
<p>记听不懂的</p>
<h3 id="yu-xi-de-nei-rong"><a href="#预习的内容" class="headerlink" title="预习的内容"></a>预习的内容<a href="#yu-xi-de-nei-rong" class="header-anchor">#</a></h3><p>知识结构</p>
<p>基本概念、定力</p>
<p>复述知识</p>
<p>做课后题，标出错误、不会做、看不懂的地方</p>
<p>整理提问列表</p>
<p>##知识体系</p>
<p>预习-听课-练习-复习-总结</p>
<p>##配图</p>
<p>暂无：流程图、概念图、思维导图、学科专业配图等</p>
<h1 id="ru-he-fu-xi"><a href="#如何复习" class="headerlink" title="如何复习"></a>如何复习<a href="#ru-he-fu-xi" class="header-anchor">#</a></h1><h2 id="ding-yi"><a href="#定义" class="headerlink" title="定义"></a>定义<a href="#ding-yi" class="header-anchor">#</a></h2><p>复习是指学习全流程过程中，复述回忆所处流程的内容，通常在每个步骤都会发生复习行为。</p>
<h2 id="fang-fa"><a href="#方法-1" class="headerlink" title="方法"></a>方法<a href="#fang-fa" class="header-anchor">#</a></h2><p><strong>黄金5分钟：</strong>下课后立刻复习，这节课主要内容是什么，老师是如何引导知识点的，中间是如何推导的，最后是如何总结的，老师用了哪些思维技巧，如何将老师讲的内容放入自己的知识结构</p>
<p><strong>利用目录</strong>，能否根据目录复述</p>
<p><strong>利用知识体系结构</strong>，能复述整张知识体系，每个知识细节，每个知识点的关联</p>
<p><strong>睡前闭眼复习法</strong>：第一节课讲了数学，数学讲了1-5个知识点，第一个知识点是xx；第二即可是历史，讲了法国大革命，背景是，过程是，意义是；第三节课是自习，做了两套题，错题是，错的概念是，解决思路是</p>
<h1 id="ru-he-ting-yin-pin"><a href="#如何听音频" class="headerlink" title="如何听音频"></a>如何听音频<a href="#ru-he-ting-yin-pin" class="header-anchor">#</a></h1><h2 id="ding-yi"><a href="#定义-1" class="headerlink" title="定义"></a>定义<a href="#ding-yi" class="header-anchor">#</a></h2><p>音频作为摄取知识的一种介质，可以重复听，可根据遍数、吸收程度调节音频进度、播放速度</p>
<h2 id="fang-fa"><a href="#方法-2" class="headerlink" title="方法"></a>方法<a href="#fang-fa" class="header-anchor">#</a></h2><p><strong>五遍法</strong></p>
<p>第一遍，光听不看文本</p>
<p>第二遍，把自己听到的东西写下来</p>
<p>第三遍，边方录音，边对照自己写的内容，找出错误的，确实的</p>
<p>第四遍，一边听，一边跟读</p>
<p>第五遍，不看文本，跟着音频朗读</p>
<h1 id="ru-he-xue-shu-xue"><a href="#如何学数学" class="headerlink" title="如何学数学"></a>如何学数学<a href="#ru-he-xue-shu-xue" class="header-anchor">#</a></h1><h2 id="ding-yi"><a href="#定义-2" class="headerlink" title="定义"></a>定义<a href="#ding-yi" class="header-anchor">#</a></h2><p>描述了学习数学的推荐方法</p>
<h2 id="fang-fa"><a href="#方法-3" class="headerlink" title="方法"></a>方法<a href="#fang-fa" class="header-anchor">#</a></h2><p>例题要重读，重复读概念、定理、公式、知识结构</p>
<p>多本书跳着读，同一概念，这本书看不懂，看看其他参考书怎么说的。</p>
<h1 id="ru-he-kao-shi"><a href="#如何考试" class="headerlink" title="如何考试"></a>如何考试<a href="#ru-he-kao-shi" class="header-anchor">#</a></h1><h2 id="ding-yi"><a href="#定义-3" class="headerlink" title="定义"></a>定义<a href="#ding-yi" class="header-anchor">#</a></h2><p>描述了考试的基本原则和策略</p>
<h2 id="fang-fa"><a href="#方法-4" class="headerlink" title="方法"></a>方法<a href="#fang-fa" class="header-anchor">#</a></h2><p>考试的原则：得分优先，随难度、耗时跳过部分</p>
<p>考试的原则: 通揽试卷，简单、难易分布心中有数</p>
<h1 id="ru-he-zuo-ti"><a href="#如何做题" class="headerlink" title="如何做题"></a>如何做题<a href="#ru-he-zuo-ti" class="header-anchor">#</a></h1><h2 id="ding-yi"><a href="#定义-4" class="headerlink" title="定义"></a>定义<a href="#ding-yi" class="header-anchor">#</a></h2><p>描述了做题的流程，做题的基本步骤和注意事项</p>
<h2 id="fang-fa"><a href="#方法-5" class="headerlink" title="方法"></a>方法<a href="#fang-fa" class="header-anchor">#</a></h2><h3 id="zuo-ti-de-jin-ji"><a href="#做题的禁忌" class="headerlink" title="做题的禁忌"></a>做题的禁忌<a href="#zuo-ti-de-jin-ji" class="header-anchor">#</a></h3><p>禁止一道题做15分钟以上</p>
<p>禁止一道题思考3分钟以上</p>
<p>禁止背诵一个段落20分钟以上，超过限定时间就跳过</p>
<h3 id="ti-mu-de-xuan-ze"><a href="#题目的选择" class="headerlink" title="题目的选择"></a>题目的选择<a href="#ti-mu-de-xuan-ze" class="header-anchor">#</a></h3><p>基础题</p>
<p>例题</p>
<p>母题</p>
<p>考试原题</p>
<h3 id="zuo-ti-de-shi-ji"><a href="#做题的时机" class="headerlink" title="做题的时机"></a>做题的时机<a href="#zuo-ti-de-shi-ji" class="header-anchor">#</a></h3><p>预习后</p>
<p>课堂听讲后，复习完毕知识后</p>
<p>老师讲了什么公式、定力，如何推导的，老师讲了哪些例题，例题有哪些解法，例题的解题思路是什么，例题的突破点在哪里</p>
<h3 id="zuo-ti-shi-de-si-kao"><a href="#做题时的思考" class="headerlink" title="做题时的思考"></a>做题时的思考<a href="#zuo-ti-shi-de-si-kao" class="header-anchor">#</a></h3><p>题目是否隐含了命题意图</p>
<p>题目是否隐含了答题方向</p>
<p>该题考查什么知识点，哪一类型知识点</p>
<p>是否碰到过类似的题</p>
<p>此类题型通常可以采用哪种可行方法</p>
<p>此类题的基本解题思路是什么？解题突破点是什么？第一步做什么，第二部做什么。</p>
<p>推导过程是否合理，考虑情况是否全面？</p>
<p>这道题是否有价值，对考试有什么帮助</p>
<p>这一类提问方式是否有规律，是否有固定的答题方法，如提问求角的余弦值，就是考察三余弦定力</p>
<h3 id="zuo-ti-hou-de-zong-jie"><a href="#做题后的总结" class="headerlink" title="做题后的总结"></a>做题后的总结<a href="#zuo-ti-hou-de-zong-jie" class="header-anchor">#</a></h3><p>对题目归类，放入例题、母题、基础题、错题中</p>
<h1 id="zong-jie"><a href="#总结" class="headerlink" title="总结"></a>总结<a href="#zong-jie" class="header-anchor">#</a></h1><p>此书有许多状元的学习经验方法总结。譬如预习、如何做题、如何听音频、如何学数学、如何考试等。可以当做小技术点融入到自己的做题步骤、预习步骤中。</p>
]]></content>
      <categories>
        <category>家庭教育</category>
        <category>学习方法</category>
      </categories>
      <tags>
        <tag>学习方法</tag>
      </tags>
  </entry>
  <entry>
    <title>谈一谈学习法</title>
    <url>/ye-jincheng-website/blog/2021/02/talk-about-learn-skills/</url>
    <content><![CDATA[<h1 id="tan-yi-tan-xue-xi-fa"><a href="#谈一谈学习法" class="headerlink" title="谈一谈学习法"></a>谈一谈学习法<a href="#tan-yi-tan-xue-xi-fa" class="header-anchor">#</a></h1>]]></content>
      <categories>
        <category>家庭教育</category>
        <category>学习方法</category>
      </categories>
      <tags>
        <tag>学习方法</tag>
      </tags>
  </entry>
  <entry>
    <title>《如何高效学习》心得</title>
    <url>/ye-jincheng-website/blog/2021/02/study-more-efficiency/</url>
    <content><![CDATA[<h1 id="ru-he-gao-xiao-xue-xi"><a href="#如何高效学习" class="headerlink" title="如何高效学习"></a>如何高效学习<a href="#ru-he-gao-xiao-xue-xi" class="header-anchor">#</a></h1><table>
<thead>
<tr>
<th><strong>名称</strong></th>
<th><strong>详情</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>封面</strong></td>
<td><img src="http://cdn.yangchaofan.cn/s27172838.jpg" width="25%"></td>
</tr>
<tr>
<td><strong>作者</strong></td>
<td>[<a href="https://book.douban.com/author/625722/">加拿大] 斯科特·扬</a></td>
</tr>
<tr>
<td><strong>出版社</strong></td>
<td>机械工业出版社</td>
</tr>
<tr>
<td><strong>介绍</strong></td>
<td>“学习的最高原则：定义出学习的活动，并做到它们”<br>如何用整体学习法学会作者提倡的整体学习法？如何用比喻记住比喻技术——比喻法-光线摄入眼球，眼球对光的感觉，视网膜的感觉，大脑对光的感觉，大脑中的声音<br><img src="http://cdn.yangchaofan.cn/biyufa.png" width="20%"><br>当我的思维库里有如此多的思维技术，我该如何运用呢？<br>学习理论和学习技术是整体性学习策略的重要组成部分，它俩同等重要，没有先后。<br>我喜欢在这两个技术中融入自己的学习方法，如《学习革命的解读》、《超效学方法解码》、《高效学习方法全集》中的一些方法。<br>将“学习理论”和“学习技术”应用实践到生活中去是非常必要的步骤，我喜欢做一些智力挑战、智力思维训练巩固我的整体性学习策略。<br>我需要选择，选择将哪些技术当作我习惯技术——好比趁手的兵器。<br>我需要问为什么，当前场景下为什么需要使用这种技术，而不用其他技术；<br>我需要练习薄弱的思维，我思维弱项是处理抽象数据、数学公式等，那我就要着重训练内在化、随意信息的处理。<br></td>
</tr>
</tbody></table>
<a id="more"></a>

<h1 id="zheng-ti-xing-xue-xi-ji-zhu"><a href="#整体性学习技术" class="headerlink" title="整体性学习技术"></a>整体性学习技术<a href="#zheng-ti-xing-xue-xi-ji-zhu" class="header-anchor">#</a></h1><h2 id="ding-yi"><a href="#定义" class="headerlink" title="定义"></a>定义<a href="#ding-yi" class="header-anchor">#</a></h2><p>整体性学习是一种学习理论，通过结构-模型-高速公路三种概念描述了大脑是如何运转，是作者斯科特杨结合自身一年通过MIT33门考试得来的学习方法实践。</p>
<h2 id="zu-cheng-bu-fen"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分<a href="#zu-cheng-bu-fen" class="header-anchor">#</a></h2><h3 id="jie-gou"><a href="#结构" class="headerlink" title="结构"></a>结构<a href="#jie-gou" class="header-anchor">#</a></h3><p>结构是指优秀的知识地图，在各个坐标物之间建立尽可能多$N : N$的关系。</p>
<h4 id="hao-de-jie-gou-li-zi"><a href="#好的结构例子" class="headerlink" title="好的结构例子"></a>好的结构例子<a href="#hao-de-jie-gou-li-zi" class="header-anchor">#</a></h4><table>
<thead>
<tr>
<th>名称</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>感知结构</td>
<td>你的五官摄取的声音、视觉图像、情感构成了最直接的感知结构</td>
</tr>
<tr>
<td>关系结构</td>
<td>思维导图、逻辑树、组织结构图等关系，能最简洁的表达出关系结构</td>
</tr>
<tr>
<td>数学结构</td>
<td>成熟的数学结构是最好的模型工具</td>
</tr>
</tbody></table>
<img src="http://cdn.yangchaofan.cn/jiegou.png" width="50%">

<h3 id="mo-xing"><a href="#模型" class="headerlink" title="模型"></a>模型<a href="#mo-xing" class="header-anchor">#</a></h3><p>模型是地图上的坐标物，是简化的地图，是地图上的一个个快照、坐标点。具体来说，模型是压缩过后的概念。<strong>是一份没有建立各个点之间联系的坐标系</strong>。比喻法是最好的建立模型的工具。<img src="http://cdn.yangchaofan.cn/model.png" width="50%"></p>
<p><strong>模型更抽象也是解释更具体的得例子</strong></p>
<img src="http://cdn.yangchaofan.cn/qipan.png" width="50%">

<h3 id="gao-su-gong-lu"><a href="#高速公路" class="headerlink" title="高速公路"></a>高速公路<a href="#gao-su-gong-lu" class="header-anchor">#</a></h3><p>高速公路是将知识地图链接起来的最佳力量。通过使用比喻法、联想法能建立强有力的知识链接。</p>
<img src="http://cdn.yangchaofan.cn/freeway.png" width="50%">

<h2 id="shun-xu"><a href="#顺序" class="headerlink" title="顺序"></a>顺序<a href="#shun-xu" class="header-anchor">#</a></h2><table>
<thead>
<tr>
<th>阶段名称</th>
<th>定义</th>
<th>步骤</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>获取</td>
<td>通过五官摄取知识的必要步骤</td>
<td>简化:规律法、分解小问题、缩小范文等记忆方法在这一步非常关键<br>容量:容量比精读，有的时候更有用，读100本书比读1-2本知道的多<br>速度:30分钟读完一篇文章比1个小时读完，大脑的吸收率前者高后者低<br></td>
<td></td>
</tr>
<tr>
<td>理解</td>
<td>是理解的初级阶段，主要为理解语言表面意思</td>
<td>使用基本的语言能力存储知识</td>
<td>认识数学符号的意义，死记硬背文言文、数学定理等</td>
</tr>
<tr>
<td>拓展</td>
<td>是理解的中级阶段，大多数无法到达这一步<br><font color="red">也是整体性学习方法的真正开始第一步</font><br>运用它解决实际生活问题；了解它的推导过程，背景意义,了解每个组成部分的真实含义；了解可以改变哪些成分，改变会产生怎样变化；了解它与其他概念的相同、不同之处。</td>
<td>深度扩展:在它的内部找寻联系，它的组成部分能产生怎样联系？<br>横向扩展：类似的结论、相反的结论；结论的事实、在其他维度类似的结论…<br>纵向扩展：比喻法、内在和是最好的方法，如奶牛和女人皮肤<br></td>
<td></td>
</tr>
<tr>
<td>纠错</td>
<td>是理解的高级阶段</td>
<td></td>
<td>生物进化模拟公司演化存在问题，要有发现问题的能力<br></td>
</tr>
<tr>
<td>应用</td>
<td>将知识运用于实践</td>
<td></td>
<td>如SMART法管理企业、5W法做策划案，编程做游戏</td>
</tr>
<tr>
<td>测试</td>
<td>主要测试以上各个步骤</td>
<td>测验获取阶段:我以前看过这个知识吗？<br>测验理解阶段:我现在知道知识的字面含义吗<br>测验拓展阶段:我知道知识从哪里推导吗，与那些知识有联系吗?<br>测验纠错阶段:我有发现不恰当的联系并删除吗？<br>测试应用阶段：我将知识用到了生活中哪些方面？</td>
<td></td>
</tr>
<tr>
<td>复盘</td>
<td>以上环节哪一个是弱项；每天用整体学习法，哪一点做得不够好</td>
<td>1.不擅长获取吗？<br>不擅长理解吗？<br>不擅长拓展吗？<br>我今天又做纠错吗<br>我今天有将知识运用到生活吗<br></td>
<td></td>
</tr>
</tbody></table>
<h2 id="huo-qu-zhi-shi"><a href="#获取知识" class="headerlink" title="获取知识"></a>获取知识<a href="#huo-qu-zhi-shi" class="header-anchor">#</a></h2><h3 id="ding-yi"><a href="#定义-1" class="headerlink" title="定义"></a><strong>定义</strong><a href="#ding-yi" class="header-anchor">#</a></h3><p>通过你的五官获取知识，如双眼、眼神经、大脑，将书本、音频、视频内容存入在脑海中。</p>
<h3 id="fang-fa"><a href="#方法" class="headerlink" title="方法"></a>方法<a href="#fang-fa" class="header-anchor">#</a></h3><h4 id="yue-du-fa"><a href="#阅读法" class="headerlink" title="阅读法"></a>阅读法<a href="#yue-du-fa" class="header-anchor">#</a></h4><p><strong>以下方法练习频率：一个月为单位，任意材料，每天15分钟指读法、15分钟练习阅读法、15分钟积极阅读法</strong></p>
<table>
<thead>
<tr>
<th><div style="width: 10%">方法名称 </div></th>
<th><div style="width: 20%">定义    </div></th>
<th><div style="width: 30%">实践步骤 </div></th>
<th><div style="width: 20%">优点 </div></th>
<th><div style="width: 20%"> 缺点 </div></th>
</tr>
</thead>
<tbody><tr>
<td>指读法</td>
<td>手指按着课本，每一行一个字一个字的滑动过去，边滑边用眼睛看</td>
<td><img src="http://cdn.yangchaofan.cn/zhidufa.png" width="50%"></td>
<td>手指提供控制眼睛阅读速度、眼睛聚焦精准的能力</td>
<td>1.前期不熟练的情况下，阅读速度较慢；<br>2.不适合手机、PC、Web，只时和书本</td>
</tr>
<tr>
<td>练习阅读法</td>
<td>训练尽可能快的速度理解内容，而非记住、吸收该内容</td>
<td><strong>3分钟训练法</strong><br>1.挑选课本<br>2.在内容上指定位置开始，设定3分钟闹钟，设为a<br>3.在该位置开始阅读,直到时间结束，计算3分钟阅读的总字数，大约为行数*单行平均字数，设为b<br>4.求出阅读速度 $v=a/b$<br>5.在该位置开始阅读，直到时间结束，尽可能多的记下知识点（不翻书的情况），写到列表中R<br>6.再度一遍教材，记录所有的知识点，写到列表Q中<br>7.比对列表R和Q，写出正确的知识点个数T、错误的知识点个数E<br>8.求出正确率 $t=T/Q$ ,错误率$e=E/Q$</td>
<td>1.可以量化阅读速度、正确率、错误率<br></td>
<td>1.比指读法耗时；<br>2.需要大量练习</td>
</tr>
<tr>
<td>积极阅读法</td>
<td></td>
<td>1.准备:阅读材料、笔记本<br>2.阅读完一页或3分钟，在笔记本回答3个问题<br>3.1这一部分的主题是什么？<br>3.2我怎样才能记住主题部分观点？<br>3.2我如何做才能拓展及应用这部分主题<br></td>
<td>3.1促使你准确获取信息<br>3.2迫使你使用联系法、视觉法、比喻法<br>3.3强迫你应用到不同场景中</td>
<td>非常耗时，需要大量练习</td>
</tr>
</tbody></table>
<p><strong>积极阅读法的例子</strong></p>
<p>读完心理学的条件反射。回答3个问题</p>
<p>1.这一部分的主题是什么？</p>
<ul>
<li>反射的发现者是巴甫洛夫</li>
<li>反射的的条件是刺激引发反应</li>
</ul>
<p>2.我该怎样才能记住这部分观点？</p>
<ul>
<li>相像一幅图画，画中是巴甫洛夫的身体，脖子上长着狗头，嘴巴张开漏出了舌头</li>
</ul>
<p>3.我该怎样拓展这部分主题？</p>
<ul>
<li>听到电视机里的手机铃声，我会不受控制的掏出自己手机查看</li>
</ul>
<h4 id="bi-ji-liu"><a href="#笔记流" class="headerlink" title="笔记流"></a>笔记流<a href="#bi-ji-liu" class="header-anchor">#</a></h4><h5 id="bi-ji-liu-ding-yi"><a href="#笔记流定义" class="headerlink" title="笔记流定义"></a><strong>笔记流定义</strong><a href="#bi-ji-liu-ding-yi" class="header-anchor">#</a></h5><p>提供一个画面、绘图文件，用来联系学到的东西。通常未划线、画圈。</p>
<h5 id="bi-ji-liu-de-yuan-ze"><a href="#笔记流的原则" class="headerlink" title="笔记流的原则"></a><strong>笔记流的原则</strong><a href="#bi-ji-liu-de-yuan-ze" class="header-anchor">#</a></h5><p>通过重复训练，达到一次学会,在听课时不关注笔记是否漂亮，只关注笔记效果和笔记的目的。</p>
<p>禁止写冗长段落，用短语替代完整句子，降低可读性。减少时间、细节、过程等用词。</p>
<p>画出主题、主题之间间联系箭头、关系用短语描述，最终整理出一张网状图。</p>
<h5 id="bi-ji-liu-de-nan-dian"><a href="#笔记流的难点" class="headerlink" title="笔记流的难点"></a><strong>笔记流的难点</strong><a href="#bi-ji-liu-de-nan-dian" class="header-anchor">#</a></h5><p>记录技术的扩展：融合联想、对比、比喻法</p>
<p>记录信息的选择：什么是重点，什么是核心，什么是难点，什么是考点</p>
<p>记录信息的删减：删除哪些信息，重新建立联系</p>
<p>以下方法练习频率：2周内，每天练习1次，课堂听课使用混合型笔记流，建立课堂上的知识点联系；下课后写一份课下笔记流，重新梳理知识点联系。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>定义</th>
<th>步骤</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>混合型笔记流</td>
<td>课堂听课时记录的笔记</td>
<td>1.画出主题短语<br>2.减少段落内容、减少长句<br>3..使用箭头、箭头描述在主体间建立联系<br>4.多使用配图和图标、符号</td>
<td>保持思路紧跟课堂节奏</td>
<td>损失少量笔记精度</td>
</tr>
<tr>
<td>课下笔记流</td>
<td>下课后根据课堂内容、参考资料整理出的笔记</td>
<td>1.传统的线性式笔记，兼顾可读性和礼节性</td>
<td>1.最完整，最详细的笔记<br>2.学习初期强烈推进使用课下笔记流+混合笔记流两份笔记的形式</td>
<td>耗时</td>
</tr>
<tr>
<td>评注流</td>
<td>课题听课时候信息量大，导致跟不上的采用的笔记方式</td>
<td>1.只写老师评语、个人评语、主题<br>2.只写评语之间的联系</td>
<td>比混合型笔记写的内容少，速度更快，更容易跟上信息量大的课堂场景</td>
<td>损失笔记的精度</td>
</tr>
</tbody></table>
<h5 id="bi-ji-liu-de-li-zi"><a href="#笔记流的例子" class="headerlink" title="笔记流的例子"></a>笔记流的例子<a href="#bi-ji-liu-de-li-zi" class="header-anchor">#</a></h5><table>
<thead>
<tr>
<th>名称</th>
<th>例子</th>
<th>总结</th>
</tr>
</thead>
<tbody><tr>
<td><strong>综合笔笔记流的例子</strong></td>
<td><img src="http://cdn.yangchaofan.cn/zonghebijiliu.png" width="50%" height="50%"></td>
<td></td>
</tr>
<tr>
<td>内在化的笔记流</td>
<td><img src="http://cdn.yangchaofan.cn/%E8%AE%A9%E7%AC%A6%E5%8F%B7%E5%8A%A8%E8%B5%B7%E6%9D%A5%20%E7%9A%84%E7%AC%94%E8%AE%B0%E6%B5%81.png"></td>
<td></td>
</tr>
<tr>
<td>压缩笔记流的例子</td>
<td><img src="http://cdn.yangchaofan.cn/%E7%AC%94%E8%AE%B0%E5%8E%8B%E7%BC%A9%E7%A4%BA%E4%BE%8B.png" width="50%"></td>
<td></td>
</tr>
<tr>
<td>流程图笔记流的例子</td>
<td><img src="http://cdn.yangchaofan.cn/%E6%B5%81%E7%A8%8B%E5%9B%BE%2B%E6%AF%94%E5%96%BB%E6%B3%95%E7%9A%84%E7%BB%BC%E5%90%88%E7%AC%94%E8%AE%B0%E6%B5%81.png"></td>
<td></td>
</tr>
</tbody></table>
<h2 id="lian-xi-guan-dian"><a href="#联系观点" class="headerlink" title="联系观点"></a>联系观点<a href="#lian-xi-guan-dian" class="header-anchor">#</a></h2><h3 id="ding-yi"><a href="#定义-2" class="headerlink" title="定义"></a>定义<a href="#ding-yi" class="header-anchor">#</a></h3><p>联系观点是一组步骤的统称，包括<font color="red">理解</font>和<font color="red">拓展</font>两个步骤。<strong>主要用途</strong>是<font color="red">将信息转化为知识模型的过程</font></p>
<h3 id="fang-fa"><a href="#方法-1" class="headerlink" title="方法"></a>方法<a href="#fang-fa" class="header-anchor">#</a></h3><table>
<thead>
<tr>
<th>名称</th>
<th>定义</th>
<th>步骤</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>比喻</td>
<td>将物体与其他物体联系在一起，将不熟悉的知识和熟悉的知识建立桥梁</td>
<td>1.确定要理解的信息，a<br>2.在个人经验、知识库中找与信息相似的东西，直到找十几个相似的知识，Q<br>3.重复上述过程，修改集合Q中的知识，并描述a和Q中元素的联系</td>
<td>1.在两个物体身上找到一点相似的地方<br>2.视觉、听觉、感觉、过程、原理、情感、声音</td>
<td>容易忘记使用比喻</td>
</tr>
<tr>
<td>视觉</td>
<td>适合抽象信息</td>
<td></td>
<td>能将抽象信息变得具体</td>
<td></td>
</tr>
<tr>
<td>内在化</td>
<td>适合具体信息</td>
<td></td>
<td>赋予知识情感、五官的感觉，如变重变轻、变快、气味、音调、光亮强度</td>
<td></td>
</tr>
<tr>
<td>比喻内在化</td>
<td>将比喻、内在化、视觉方法融为一体</td>
<td>综上3个步骤</td>
<td></td>
<td></td>
</tr>
<tr>
<td>图表法</td>
<td>组合图表展现内容<br>常见类型有3种：流程图、概念图、图像</td>
<td>学习对应的图表绘制方式</td>
<td>重复训练可以达到1分钟画一幅粗略图表</td>
<td>非常耗时</td>
</tr>
<tr>
<td>图表内在化</td>
<td>将图表法+比喻内在化融为一体</td>
<td>综上全部步骤</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="bi-yu"><a href="#比喻" class="headerlink" title="比喻"></a>比喻<a href="#bi-yu" class="header-anchor">#</a></h4><h5 id="ding-yi"><a href="#定义-3" class="headerlink" title="定义"></a>定义<a href="#ding-yi" class="header-anchor">#</a></h5><p>将一个物体与另外一个物体联系起来的工具。如女性身材和沙漏比喻，形容女性身材曼妙，沙子不停向下流淌；肌肉壮的像头牛。</p>
<h5 id="bi-yu-de-ji-qiao"><a href="#比喻的技巧" class="headerlink" title="比喻的技巧"></a><strong>比喻的技巧</strong><a href="#bi-yu-de-ji-qiao" class="header-anchor">#</a></h5><p>有<font color="red"><strong>找寻比喻的意识</strong></font>，在整体学习每一步都使用比喻，在阅读信息的时候比喻</p>
<p>有<font color="red"><strong>找到更好比喻的意识</strong></font>，每次比喻都列举10-20个比喻，直到找个最好的哪个</p>
<p>有<font color="red"><strong>修改比喻的意识</strong></font>，没有合适的比喻，就在列举出的比喻中修改，改成合适的</p>
<p>有<font color="red"><strong>测试比喻的意识</strong></font>，每次使用比喻，都要检查是否理解错误，改善理解错误的比喻</p>
<h5 id="bi-yu-de-li-zi"><a href="#比喻的例子" class="headerlink" title="比喻的例子"></a><strong>比喻的例子</strong><a href="#bi-yu-de-li-zi" class="header-anchor">#</a></h5><p>女性身体-沙漏</p>
<p>男性肌肉-公牛</p>
<p>女性皮肤-牛奶</p>
<p>条件反射-狗吐舌头</p>
<p>条件反射-雪地里找脚印的路</p>
<p>导数-汽车仪表盘里程表和速度表</p>
<h5 id="bi-yu-de-lian-xi"><a href="#比喻的练习" class="headerlink" title="比喻的练习"></a>比喻的练习<a href="#bi-yu-de-lian-xi" class="header-anchor">#</a></h5><p>每个主题写20个比喻。</p>
<p>每个主题写20个比喻后修改5个比喻</p>
<p>将比喻讲给其他人听，别人是否能理解。</p>
<h4 id="nei-zai-hua"><a href="#内在化" class="headerlink" title="内在化"></a>内在化<a href="#nei-zai-hua" class="header-anchor">#</a></h4><h5 id="ding-yi"><a href="#定义-4" class="headerlink" title="定义"></a>定义<a href="#ding-yi" class="header-anchor">#</a></h5><p>将知识转化未视觉、听觉、动觉的信息。</p>
<h5 id="nei-zai-hua-ji-qiao"><a href="#内在化技巧" class="headerlink" title="内在化技巧"></a>内在化技巧<a href="#nei-zai-hua-ji-qiao" class="header-anchor">#</a></h5><table>
<thead>
<tr>
<th>步骤</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>清楚的描述概念</td>
<td>生物学过程还是面向对象的代码</td>
</tr>
<tr>
<td>在脑海中建立图像</td>
<td>手写图案，脑海中画出图案</td>
</tr>
<tr>
<td>脑海中让图案动起来</td>
<td>行列式想象成左右手搬东西，搬东西需要左手先，右手后</td>
</tr>
<tr>
<td>调动身体其他器官与图像建立联系</td>
<td>脚步、身体躯干弯腰、挺直身体等，张开嘴咬，伸出鼻子闻</td>
</tr>
<tr>
<td>加入情感</td>
<td>悲伤、恐惧、兴趣盎然、害怕，如砸到脚、高兴的跳起来</td>
</tr>
<tr>
<td>调整图案的运动模式、调整身体的动作、调整情感</td>
<td>优化上述步骤</td>
</tr>
</tbody></table>
<h5 id="nei-zai-hua-de-li-zi"><a href="#内在化的例子" class="headerlink" title="内在化的例子"></a><strong>内在化的例子</strong><a href="#nei-zai-hua-de-li-zi" class="header-anchor">#</a></h5><p>行列式计算-使用右手、左手搬物体，感觉变轻了</p>
<p>比喻法-光线摄入眼球，眼球对光的感觉，视网膜的感觉，大脑对光的感觉，大脑中的声音</p>
<img src="http://cdn.yangchaofan.cn/biyufa.png" width="20%">



<h2 id="sui-yi-xin-xi-de-chu-li"><a href="#随意信息的处理" class="headerlink" title="随意信息的处理"></a>随意信息的处理<a href="#sui-yi-xin-xi-de-chu-li" class="header-anchor">#</a></h2><h3 id="ding-yi"><a href="#定义-5" class="headerlink" title="定义"></a>定义<a href="#ding-yi" class="header-anchor">#</a></h3><p>作者将学习类信息分为5种，随意信息作为其中之一。具体表现未抽象的信息：</p>
<ul>
<li>日期</li>
<li>解剖学术语</li>
<li>编程术语</li>
<li>数学符号</li>
<li>公司规章制度</li>
<li>科学公式</li>
</ul>
<h3 id="fang-fa"><a href="#方法-2" class="headerlink" title="方法"></a>方法<a href="#fang-fa" class="header-anchor">#</a></h3><p>推荐联想法和笔记流法(上文提到)。</p>
<h4 id="lian-xiang-fa"><a href="#联想法" class="headerlink" title="联想法"></a>联想法<a href="#lian-xiang-fa" class="header-anchor">#</a></h4><p>联想法有以下三步，每一步都需要重复找到最佳实践。</p>
<table>
<thead>
<tr>
<th>步骤</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>将信息写成一个线性的清单，罗列成一组最小化信息</td>
<td>$V=1+X/b$写成如下清单:<br>V=1；<br>加上；<br>X；<br>除以；<br>b</td>
</tr>
<tr>
<td>给清单中的每一项设定有实际意义的物体图像</td>
<td>V=1，一只手胜利姿势;<br>x，X战警<br>b,气泡枪；<br></td>
</tr>
<tr>
<td>创建每个物体的联系</td>
<td>胜利姿势与X战警的联系是，X战警战胜了坏蛋，举着胜利手势；<br>X战警与气泡枪的联系是，X战警另外一只手扛着气泡枪<br></td>
</tr>
</tbody></table>
<p><strong>联想步骤示例</strong></p>
<img src="http://cdn.yangchaofan.cn/liantiao-联想法示例.png" width="50%">

<p><strong>注意事项</strong></p>
<table>
<thead>
<tr>
<th>难点</th>
<th>解决办法</th>
</tr>
</thead>
<tbody><tr>
<td>符号重复</td>
<td>改进符号，给符号加上不同颜色，如红色a、蓝色a</td>
</tr>
<tr>
<td>联系断裂</td>
<td>重复练习<br>联系链长度适中5-15个最佳</td>
</tr>
<tr>
<td>符号难以辨认回忆</td>
<td>改进符号，使用一般受欢迎的的常识，减少特殊场景的物体</td>
</tr>
<tr>
<td>触发点丢失</td>
<td>重复练习<br>将知识标题加入联系链中<br></td>
</tr>
</tbody></table>
<h3 id="lian-xi"><a href="#练习" class="headerlink" title="练习"></a>练习<a href="#lian-xi" class="header-anchor">#</a></h3><p>每天设定时间按照步骤练习3-5个公式、3-5个定理、3-5个长句子等。</p>
<h2 id="zhi-shi-de-yan-shen"><a href="#知识的延伸" class="headerlink" title="知识的延伸"></a>知识的延伸<a href="#zhi-shi-de-yan-shen" class="header-anchor">#</a></h2><h3 id="ding-yi"><a href="#定义-6" class="headerlink" title="定义"></a>定义<a href="#ding-yi" class="header-anchor">#</a></h3><p>延伸是整体性学习的最后一步。用于将知识应用到实际生活。延伸是一种创造性过程，这个过程没有固定步骤。你需要结合你的生活经验、已经习得知识进行联想、比喻、内在化，直至动手实践它。</p>
<h3 id="fang-fa"><a href="#方法-3" class="headerlink" title="方法"></a>方法<a href="#fang-fa" class="header-anchor">#</a></h3><h4 id="sheng-huo-ying-yong"><a href="#生活应用" class="headerlink" title="生活应用"></a>生活应用<a href="#sheng-huo-ying-yong" class="header-anchor">#</a></h4><p>以下是作者经常用来延伸的方法，即将新习得的内容，延伸至以下几个领域；也可以通过模仿表格提供的例子，将习得的知识延伸到具体生活中去。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>例子</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>统计学</td>
<td>利用统计学知识，通过搜索引擎，统计竞品书记字数、价格、书名，给我即将出版的付费文字制定价格。</td>
<td>跟生活结合</td>
</tr>
<tr>
<td>会计学</td>
<td>利用会计知识，理清个人资产、负债情况，预测未来收益、负债，以及自己可承担的负债上限等</td>
<td>跟生活结合</td>
</tr>
<tr>
<td>计算机</td>
<td>计算机科学编写、调试、运行、纠错都是可以借鉴的学习思想；编写程序可以锻炼理性思维；算法可以用来提高生活效率</td>
<td>跟工作结合</td>
</tr>
</tbody></table>
<h5 id="lian-xi"><a href="#练习-1" class="headerlink" title="练习"></a>练习<a href="#lian-xi" class="header-anchor">#</a></h5><p>将习得的新知识，花5-10分钟罗列生活中20个用处。写有创意的思路，尽可能实践这些想法。</p>
<h4 id="jiu-cuo"><a href="#纠错" class="headerlink" title="纠错"></a>纠错<a href="#jiu-cuo" class="header-anchor">#</a></h4><h5 id="ding-yi"><a href="#定义-7" class="headerlink" title="定义"></a>定义<a href="#ding-yi" class="header-anchor">#</a></h5><p>纠错是发现问题，让事情回到正规，让自己对知识的理解回到正规上的唯一办法。</p>
<h5 id="fang-fa"><a href="#方法-4" class="headerlink" title="方法"></a>方法<a href="#fang-fa" class="header-anchor">#</a></h5><table>
<thead>
<tr>
<th>名称</th>
<th>定义</th>
<th>例子</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>分类法</td>
<td>分清楚是书写错误还是概念理解错误<br></td>
<td>1.模型建立不当<br>2.比喻不当<br>3.模型之间的联系描述错误<br>4.粗心写错了内容<br></td>
<td>简单的错误用简单的方法重复大量练习；复杂的概念理解错误，需要仔细查看整体学习步骤，查看每一个环节模型定义、比喻法、内在化过程是否有理解或使用错误</td>
</tr>
<tr>
<td>散弹枪法</td>
<td>单位时间内，每一个知识的测试都做一做<br></td>
<td>1.主题下有3个知识，3分钟把3个知识的测试都做一做；10分钟把3个知识实践以下，最后发现3个知识的问题<br>2.广泛测试主题下的每个知识，重复实践每个知识</td>
<td>发现每个知识的不同问题；多发现不同知识的不同问题</td>
</tr>
<tr>
<td>日历法</td>
<td>每一天都做练习，禁止考前集中做</td>
<td>1.每天、每周做一遍练习题，类似天考、周考、月考、</td>
<td>每天花3分钟练习所学知识，比考前一礼拜练习全部知识有效果</td>
</tr>
</tbody></table>
<blockquote>
<p>比喻法记住上面三个方法：分类法-在红豆和绿豆中分类出红豆；散弹枪法-把红豆装进散弹枪；日历法-将装满红豆的散弹枪对着日历射击，射中的天数可以出去游玩。</p>
</blockquote>
<h4 id="zuo-shi-ji-xiang-mu"><a href="#做实际项目" class="headerlink" title="做实际项目"></a>做实际项目<a href="#zuo-shi-ji-xiang-mu" class="header-anchor">#</a></h4><p>做实际项目是学会知识最佳途径，理解 、做题什么的都不如它有效果。如果有足够多的时间，可以规划做一些真实项目检验你所学的知识。</p>
<table>
<thead>
<tr>
<th>知识名称</th>
<th>实际项目</th>
<th>目标</th>
</tr>
</thead>
<tbody><tr>
<td>编程</td>
<td>设计1个需要1个月完成的项目，比如一个日历APP、美颜APP等</td>
<td>发布上架<br>推广宣传获得100个用户<br></td>
</tr>
<tr>
<td>历史</td>
<td>设计需要1个月完成的具体历史问题的论文</td>
<td>5000字<br>100赞<br>阅读量50000<br></td>
</tr>
<tr>
<td>财务会计</td>
<td>设计需要1个月完成的优化某个公司财务的方案</td>
<td></td>
</tr>
<tr>
<td>学习方法</td>
<td>设计需要7天完成的学习数学的方法合集</td>
<td>数学知识描述<br>学数学的步骤<br>思想<br>故事联想<br>数学实际知识应用<br></td>
</tr>
</tbody></table>
<h1 id="fei-man-ji-qiao"><a href="#费曼技巧" class="headerlink" title="费曼技巧"></a>费曼技巧<a href="#fei-man-ji-qiao" class="header-anchor">#</a></h1><h2 id="yong-tu"><a href="#用途" class="headerlink" title="用途"></a>用途<a href="#yong-tu" class="header-anchor">#</a></h2><p><strong>理解那些你没有真正掌握的知识点</strong></p>
<p><strong>记住你能理解，却在考试忘掉的知识点</strong></p>
<h2 id="fang-fa"><a href="#方法-5" class="headerlink" title="方法"></a>方法<a href="#fang-fa" class="header-anchor">#</a></h2><table>
<thead>
<tr>
<th>名称</th>
<th>实践</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>选择要学习的概念</td>
<td>对于该概念，要有深入理解的动机<br>拿白纸，在中间写下概念名称<br></td>
<td></td>
</tr>
<tr>
<td>设想你是老师，正在试图教会一个新生知识点</td>
<td>对于该新生，你要当作纯小白、小学生<br><font color="red">把你的解释过程录音、写文字记录下来。记住这一步至关重要</font><br>因为在自我解释那些你认为已经理解或不理解的知识的过程中，你会理解的更好，原先混淆的地方也得以理清 <br></td>
<td></td>
</tr>
<tr>
<td>询问自己是否有疑惑</td>
<td>如果有请停止向下学习，返回至学习步骤，重新阅读参考材料，听讲座，找老师解答。直到搞懂位置</td>
<td></td>
</tr>
<tr>
<td>整体化学习技巧</td>
<td>比喻、内在化、联想法、笔记流，重新理解它。</td>
<td></td>
</tr>
</tbody></table>
<h1 id="gao-xiao-lu-xue-sheng"><a href="#高效率学生" class="headerlink" title="高效率学生"></a>高效率学生<a href="#gao-xiao-lu-xue-sheng" class="header-anchor">#</a></h1><p>斯科特杨认为高效率的学生应该有以下特点：</p>
<table>
<thead>
<tr>
<th>特点</th>
<th>特点解释</th>
</tr>
</thead>
<tbody><tr>
<td>能量管理</td>
<td>1.增加日常能量储备：<br>每周3-5次运动，每次40分钟；<br>每天7-8小时睡眠<br>禁止高糖、高脂肪、高蛋白质食物<br>建议粗纤维、粗加工食物<br>一天7杯水<br>多餐、少吃、每餐7分饱<br>2.2/8原则<br>20%的时间处理不重要的事情，80%的时间处理重要的事情<br>重要的事情只做1-2件<br>精力充沛的时间点做重要的事情<br>3.番茄闹钟，25+5原则<br></td>
</tr>
<tr>
<td>不要“学习”</td>
<td>1.不要表演“学习”,即不要嘴里没有东西，还要假装在吃个不停。<br>2.要买菜、摘菜、洗菜、炒菜、夹菜、咀嚼、消化、吸收，去做学习（吃饭）应该做的事情<br>3.学习的最高原则：定义出学习的活动，并做到它们：<br>整体学习法规定的每个活动</td>
</tr>
<tr>
<td>绝不拖延</td>
<td>周日目标体系法<br>甘特图法<br>2/8法<br></td>
</tr>
<tr>
<td>批处理</td>
<td>20%的时间处理以下事情：不重要的、单个时间小于1小时<br>不重要的任务：一次性完成，不要拆分到多个时间段<br></td>
</tr>
<tr>
<td>有组织</td>
<td>关键事件组织规划一些：<br>随身笔记本，随时记、日积月累<br>任务日历、甘特图、思维导图工具的便捷打开方式<br></td>
</tr>
</tbody></table>
<h1 id="zong-jie"><a href="#总结" class="headerlink" title="总结"></a>总结<a href="#zong-jie" class="header-anchor">#</a></h1><p>学习理论和学习技术是整体性学习策略的重要组成部分，它俩同等重要，没有先后。</p>
<p>我喜欢在这两个技术中融入自己的学习方法，如《学习革命的解读》、《超效学方法解码》、《高效学习方法全集》中的一些方法。</p>
<p>将“学习理论”和“学习技术”应用实践到生活中去是非常必要的步骤，我喜欢做一些智力挑战、智力思维训练巩固我的整体性学习策略。</p>
<p>当我的思维库里有如此多的思维技术，我该如何运用呢？</p>
<p>我需要选择，选择将哪些技术当作我习惯技术——好比趁手的兵器。</p>
<p>我需要问为什么，当前场景下为什么需要使用这种技术，而不用其他技术；</p>
<p>我需要练习薄弱的思维，我思维弱项是处理抽象数据、数学公式等，那我就要着重训练内在化、随意信息的处理。</p>
]]></content>
      <categories>
        <category>家庭教育</category>
        <category>学习方法</category>
      </categories>
      <tags>
        <tag>学习方法</tag>
      </tags>
  </entry>
  <entry>
    <title>《超效学习方法解码》心得</title>
    <url>/ye-jincheng-website/blog/2021/02/chao-xiao-xue-xi-fang-fa-jie-ma/</url>
    <content><![CDATA[<h1 id="chao-xiao-xue-xi-fang-fa-jie-ma"><a href="#《超效学习方法解码》" class="headerlink" title="《超效学习方法解码》"></a>《超效学习方法解码》<a href="#chao-xiao-xue-xi-fang-fa-jie-ma" class="header-anchor">#</a></h1><table>
<thead>
<tr>
<th>名称</th>
<th>详情</th>
</tr>
</thead>
<tbody><tr>
<td><strong>封面</strong></td>
<td><img src="http://cdn.yangchaofan.cn/gaoxiao%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95.jpg" width="50%" height="50%"></td>
</tr>
<tr>
<td><strong>作者</strong></td>
<td>曹婷</td>
</tr>
<tr>
<td><strong>出版社</strong></td>
<td>星火教育研究院</td>
</tr>
<tr>
<td><strong>介绍</strong></td>
<td>分为学习基础篇、学习修炼篇、学习问题对症篇；学习对症篇主要解决语文、数学、英文、历史、政治的疑难杂症；学习修炼篇提供了预习、听课、复习、做题的基本思路，克服困难的方法；学习基础篇主要讲了时间管理、注意力管理、记忆力的小技巧。</td>
</tr>
</tbody></table>
<a id="more"></a>

<h1 id="ru-he-yu-xi"><a href="#如何预习" class="headerlink" title="如何预习"></a>如何预习<a href="#ru-he-yu-xi" class="header-anchor">#</a></h1><h2 id="ding-yi"><a href="#定义" class="headerlink" title="定义"></a>定义<a href="#ding-yi" class="header-anchor">#</a></h2><p>预习是学习行为的第一步，在预习之后才能展开听课行为。</p>
<h2 id="fang-fa"><a href="#方法" class="headerlink" title="方法"></a>方法<a href="#fang-fa" class="header-anchor">#</a></h2><p>阅读主题知识结构，理解知识结构</p>
<p>基本概念定理，理解内容</p>
<p>复述记忆，一页一记法复述知识</p>
<p>课后练习，理解困难，做题困难，看不懂</p>
<p>整理问题列表，用于听课过程中解答</p>
<h1 id="ru-he-ting-ke"><a href="#如何听课" class="headerlink" title="如何听课"></a>如何听课<a href="#ru-he-ting-ke" class="header-anchor">#</a></h1><h2 id="ding-yi"><a href="#定义-1" class="headerlink" title="定义"></a>定义<a href="#ding-yi" class="header-anchor">#</a></h2><p>听课行为发生于预习行为之后，听课是一种吸收知识的行为，具体行为表现为听音频、看视频、阅读教材讲义等文字内容、动手实践等</p>
<p>听课的动机目的是</p>
<ul>
<li>解决预习过程中遇到的问题，</li>
<li>完善预习后建立的知识体系，</li>
<li>利用听课时间背诵重点知识，</li>
<li>有选择的跳过非核心知识背诵。</li>
</ul>
<h2 id="fang-fa"><a href="#方法-1" class="headerlink" title="方法"></a>方法<a href="#fang-fa" class="header-anchor">#</a></h2><p><strong>解答问题列表：</strong>使用预习后准备的提问列表，在听课中解决提问</p>
<p><strong>背诵时机选择：</strong>已经听懂的知识，但没记住；此时在讲不重要的知识，则可以背诵前面重要的知识</p>
<p>预习过后已经看懂的主题，听课中可以集中精力背诵该主题，减少听的时间</p>
<p>听课中，抽出精力背诵重点精华内容，老师重复讲的，章节段落核心，讲解思路，老师对知识点联系的描述，重点，难点，画外音，<strong>以及课本上没有的内容</strong></p>
<p><strong>符号笔记：</strong>听课中，老师提到的内容，<strong>如果在课本已有</strong>，用符号标记如波浪线、三角号、着重号标记；<strong>如果课本没有</strong>，则记住关键字，课后提问、搜索引擎。</p>
<h1 id="ru-he-xue-shu-xue"><a href="#如何学数学" class="headerlink" title="如何学数学"></a>如何学数学<a href="#ru-he-xue-shu-xue" class="header-anchor">#</a></h1><h2 id="ding-yi"><a href="#定义-2" class="headerlink" title="定义"></a>定义<a href="#ding-yi" class="header-anchor">#</a></h2><p>数学是一门抽象思维学科，有着独特的描述语言和符号</p>
<h2 id="fang-fa"><a href="#方法-2" class="headerlink" title="方法"></a>方法<a href="#fang-fa" class="header-anchor">#</a></h2><h2 id="ru-he-zuo-li-ti"><a href="#如何做例题" class="headerlink" title="如何做例题"></a>如何做例题<a href="#ru-he-zuo-li-ti" class="header-anchor">#</a></h2><h3 id="ding-yi"><a href="#定义-3" class="headerlink" title="定义"></a>定义<a href="#ding-yi" class="header-anchor">#</a></h3><p>例题是基础题，一般为简单题，主要用于表现定理、公式的基本特征，可用于训练解题步骤</p>
<h3 id="fang-fa"><a href="#方法-3" class="headerlink" title="方法"></a>方法<a href="#fang-fa" class="header-anchor">#</a></h3><p>将例题当做训练解题步骤的母题</p>
<h3 id="jie-ti-bu-zou"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤<a href="#jie-ti-bu-zou" class="header-anchor">#</a></h3><h4 id="shen-ti"><a href="#审题" class="headerlink" title="审题"></a>审题<a href="#shen-ti" class="header-anchor">#</a></h4><p>了解题意</p>
<p>获取题目直接条件：概念常用的性质、特定条件、函数的定义域、值域、方程变量的取值范围、图形的取值范围</p>
<p>分析题目隐含条件</p>
<p>明确题目考察要求</p>
<p>找寻数学基本工具，概念、公式、定理</p>
<h4 id="qiu-jie"><a href="#求解" class="headerlink" title="求解"></a>求解<a href="#qiu-jie" class="header-anchor">#</a></h4><p><strong>联想条件的直接结论</strong>，可根据直接条件联想条件可得出的结论；根据结论再联想它对应的结论；可重复联系对应结论；</p>
<p><strong>溯源结论推导过程</strong>，条件-推导过程-结论-结论推出的结论-结论的结论推导出的结论，有时考察的并非条件、结论，考察的是推导过程，所以要溯源推导过程，过程中的变量、不变量是解题的关键</p>
<h4 id="zong-jie"><a href="#总结" class="headerlink" title="总结"></a>总结<a href="#zong-jie" class="header-anchor">#</a></h4><p>题目条件的总结：直接条件的获取方式、间接条件的推导过程，思考去掉条件，会引起什么变化；思考逆向推导的能力，即由结论找寻条件的过程；总结题目的描述规律、考察规律、解题步骤、题型划分等</p>
<h2 id="ru-he-jian-yan-da-an"><a href="#如何检验答案" class="headerlink" title="如何检验答案"></a>如何检验答案<a href="#ru-he-jian-yan-da-an" class="header-anchor">#</a></h2><h3 id="ding-yi"><a href="#定义-4" class="headerlink" title="定义"></a>定义<a href="#ding-yi" class="header-anchor">#</a></h3><p>检验答案正确性，是做题的关键步骤，必要时会导致答案的修改</p>
<h3 id="fang-fa"><a href="#方法-4" class="headerlink" title="方法"></a>方法<a href="#fang-fa" class="header-anchor">#</a></h3><h4 id="fang-fa-1-ji-ben-gai-nian-jian-yan-fa"><a href="#方法1基本概念检验法" class="headerlink" title="方法1基本概念检验法"></a>方法1基本概念检验法<a href="#fang-fa-1-ji-ben-gai-nian-jian-yan-fa" class="header-anchor">#</a></h4><p>概念性错误是最容易忽视的，基本概念、法则、公式的适用条件是否满足，是否位于边界情况，都是要严格检查的。</p>
<h4 id="fang-fa-2-dui-cheng-yuan-li-jian-yan-fa"><a href="#方法2对称原理检验法" class="headerlink" title="方法2对称原理检验法"></a>方法2对称原理检验法<a href="#fang-fa-2-dui-cheng-yuan-li-jian-yan-fa" class="header-anchor">#</a></h4><p>对称的公式、定理，势必导致结论的对称，利用对称原理可以快速检验反比例函数和二次函数的答案</p>
<h4 id="fang-fa-3-te-shu-qing-xing-jian-yan-fa"><a href="#方法3特殊情形检验法" class="headerlink" title="方法3特殊情形检验法"></a>方法3特殊情形检验法<a href="#fang-fa-3-te-shu-qing-xing-jian-yan-fa" class="header-anchor">#</a></h4><p>特殊值、特例、极端情况是检验答案的快捷方法</p>
<h4 id="fang-fa-4-bu-bian-liang-jian-yan-fa"><a href="#方法4不变量检验法" class="headerlink" title="方法4不变量检验法"></a>方法4不变量检验法<a href="#fang-fa-4-bu-bian-liang-jian-yan-fa" class="header-anchor">#</a></h4><p>某一类数学问题在变化、变形过程中，有的量保持不变，不变的量可以验证答案的正确性。</p>
<p>如图形旋转、平移、翻转时，图形面积、体积不变。</p>
<h4 id="fang-fa-5-deng-jie-guan-xi-jian-yan-fa"><a href="#方法5等价关系检验法" class="headerlink" title="方法5等价关系检验法"></a>方法5等价关系检验法<a href="#fang-fa-5-deng-jie-guan-xi-jian-yan-fa" class="header-anchor">#</a></h4><p>等价替换答案，检验正确性</p>
<h4 id="fang-fa-6-luo-ji-tui-li-jian-yan-fa"><a href="#方法6逻辑推理检验法" class="headerlink" title="方法6逻辑推理检验法"></a>方法6逻辑推理检验法<a href="#fang-fa-6-luo-ji-tui-li-jian-yan-fa" class="header-anchor">#</a></h4><h4 id="fang-fa-7-zheng-ti-jian-yan-fa"><a href="#方法7整体检验法" class="headerlink" title="方法7整体检验法"></a>方法7整体检验法<a href="#fang-fa-7-zheng-ti-jian-yan-fa" class="header-anchor">#</a></h4><h4 id="fang-fa-8-shu-xue-jie-he-jian-yan-fa"><a href="#方法8数学结合检验法" class="headerlink" title="方法8数学结合检验法"></a>方法8数学结合检验法<a href="#fang-fa-8-shu-xue-jie-he-jian-yan-fa" class="header-anchor">#</a></h4><h4 id="fang-fa-9-yi-ti-duo-jie-jian-yan-fa"><a href="#方法9一题多解检验法" class="headerlink" title="方法9一题多解检验法"></a>方法9一题多解检验法<a href="#fang-fa-9-yi-ti-duo-jie-jian-yan-fa" class="header-anchor">#</a></h4><h4 id="fan-fu-10-cao-gao-yun-suan-bu-zou-he-cha-fa"><a href="#反复10草稿运算步骤核查法" class="headerlink" title="反复10草稿运算步骤核查法"></a>反复10草稿运算步骤核查法<a href="#fan-fu-10-cao-gao-yun-suan-bu-zou-he-cha-fa" class="header-anchor">#</a></h4><h2 id="xie-shu-xue-ri-ji"><a href="#写数学日记" class="headerlink" title="写数学日记"></a>写数学日记<a href="#xie-shu-xue-ri-ji" class="header-anchor">#</a></h2><h3 id="ri-ji-nei-rong"><a href="#日记内容" class="headerlink" title="日记内容"></a>日记内容<a href="#ri-ji-nei-rong" class="header-anchor">#</a></h3><p>事件日记：学习中自己感兴趣的活动、故事、事件、主题知识，受到了什么启发，得到了哪些锻炼，自己有什么感受</p>
<p>引导日记：课堂中老师的引导过程、例题推导过程，自己内心有什么感受</p>
<p>练习日记：习题、考试后的心得，哪些做得好，哪些做得不好，改正的步骤，自己五官有什么感受</p>
<h3 id="ri-ji-yao-qiu"><a href="#日记要求" class="headerlink" title="日记要求"></a>日记要求<a href="#ri-ji-yao-qiu" class="header-anchor">#</a></h3><p>简练的描述自己的感受</p>
<p>简练的描述主题知识和内容，详细的部分放在笔记里</p>
<p>将感受和主题知识联系起来</p>
<h1 id="ru-he-xue-zheng-zhi"><a href="#如何学政治" class="headerlink" title="如何学政治"></a>如何学政治<a href="#ru-he-xue-zheng-zhi" class="header-anchor">#</a></h1><p>##定义</p>
<p>描述了学习政治学科的方法</p>
<h2 id="fang-fa"><a href="#方法-5" class="headerlink" title="方法"></a>方法<a href="#fang-fa" class="header-anchor">#</a></h2><p><strong>画知识体系图：</strong>以单元标题-章节标题-框标题-小标题-自然段为<strong>主</strong>题，画思维导图，建立每个知识点的联系。</p>
<p>谁是知识体系的基础：自然段是知识体系的基础，只有理解自然段才能建立<strong>主题知识体系</strong>。</p>
<p><strong>能够提问，层层发问：</strong>政治内容，每句话都有前因后果。每个自然段，不断问“是什么”，“为什么”，“怎么办”。</p>
<p>层层发文的目的：让一个段落诞生几句话，一个段落扩展成几个段落，最终建立主题之间的联系，形成知识体系。</p>
<p><strong>无法发问，使用推理：</strong>无法通过提问找寻主题关系的，只能通过归纳、演绎，抽象得推导出主题之间的关系。</p>
<p><strong>带着提问，问题列表</strong>：手写提问列表，加深阅读的印象，减少阅读的思考负担。</p>
<p>##知识体系</p>
<p>主题-提问-推理-主题建立联系-根据联系绘制思维导图</p>
<p>##配图</p>
<p>暂无：流程图、概念图、思维导图、学科专业配图等</p>
<h1 id="ru-he-zuo-ti"><a href="#如何做题" class="headerlink" title="如何做题"></a>如何做题<a href="#ru-he-zuo-ti" class="header-anchor">#</a></h1><h2 id="ding-yi"><a href="#定义-5" class="headerlink" title="定义"></a>定义<a href="#ding-yi" class="header-anchor">#</a></h2><p>描述了做题的基本流程，前后步骤。</p>
<h2 id="fang-fa"><a href="#方法-6" class="headerlink" title="方法"></a>方法<a href="#fang-fa" class="header-anchor">#</a></h2><p><strong>范围选择：</strong>课后题、例题、错题、考试真题</p>
<p><strong>先后顺序：</strong>书中主题内容看懂，再做题。</p>
<p><strong>时间原则：</strong>做题时要限时，题目时间分配合理，阻塞的题目立刻跳过</p>
<p>**开始原则:**做题任务计时开始，就立刻做，不拖延</p>
<p><strong>收尾原则：</strong>题目做完后，只有反思总结，才能得到收益</p>
<ul>
<li>反思错误：错误原因、没有思路原因、做不出来原因</li>
<li>反思题意：条件、问题、结论，三者联系</li>
<li>反思方法：将题目解题思路融入解题的积累中</li>
<li>反思变化：条件、问题、结论，三者变化后练习</li>
</ul>
<h1 id="ru-he-ti-gao-jie-ti-su-du"><a href="#如何提高解题速度？" class="headerlink" title="如何提高解题速度？"></a>如何提高解题速度？<a href="#ru-he-ti-gao-jie-ti-su-du" class="header-anchor">#</a></h1><p>只有<strong>熟悉主题</strong>（概念、定义、公式、定力），才能做好简单的题目。</p>
<p>只有<strong>做好基本题</strong>，才能做好复杂题。</p>
<p>只有<strong>熟悉主题之间的联系</strong>，才能做好综合题。</p>
<p>只有<strong>掌握基本的解题步骤、解题方法</strong>，才能做好对应的题型。</p>
<p>只有<strong>事后做好归纳总结</strong>（题型归类、基本步骤、解题方法、隐含条件、隐含结论），才能积累考题题型，做到不重不漏。</p>
<p>只有<strong>学会数学工具（画图等10几个数学工具）</strong>，才能翻译出题目的考点。</p>
<p>只有<strong>记住上述内容</strong>，才能提高解题速度。</p>
<h1 id="zong-jie"><a href="#总结-1" class="headerlink" title="总结"></a>总结<a href="#zong-jie" class="header-anchor">#</a></h1><p>本书读完，最大的收获是预习、听课、学政治、学数学、如何做题五个方面。</p>
<p>听课给我的启发是：在预习的基础上，对课堂所讲知识结构心中有数，能轻易的跟上、超过老师的讲课节奏，在充分预习的基础上，可以利用课堂时间背诵重点、难点、核心点，利用听课时间、老师的思路引导知识记忆，可以充分提高学习效率。</p>
<p>尤其是学数学，提倡的<label style="color:green"><strong>数学日记</strong></label>让我很意外，也很开心，事事都可以写日记，日记不同于笔记，更加自由，口语化，能更融入个人的情感，激发具象思维，提升学习兴趣。利于孩童学习，也利于成人读书。</p>
<p>学习数学一节，如何做题的思路也启发了我，提醒我做题应当分为审题、解题、总结三步骤。审题和总结是大多数容易忽视的，不可轻敌，解题中的两个方法联想隐藏条件法和溯源推导过程找间接条件法对我也启发很大，提示我们做题要正向条件-结论思考，也要反向结论-推导过程-条件思考，有时隐藏条件就在推导过程中，而非题目本身给出的直接条件。</p>
]]></content>
      <categories>
        <category>家庭教育</category>
        <category>学习方法</category>
      </categories>
      <tags>
        <tag>学习方法</tag>
      </tags>
  </entry>
  <entry>
    <title>程序员吃的是青春饭吗？</title>
    <url>/ye-jincheng-website/blog/2021/02/Is%20coder%20need%20more%20younger%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="cheng-xu-yuan-chi-de-shi-qing-chun-fan-ma"><a href="#程序员吃的是青春饭吗？" class="headerlink" title="程序员吃的是青春饭吗？"></a>程序员吃的是青春饭吗？<a href="#cheng-xu-yuan-chi-de-shi-qing-chun-fan-ma" class="header-anchor">#</a></h1><p>昨天在知乎上看到一个提问<a href="https://www.zhihu.com/question/444102247">“程序员为什么是吃青春饭，而不是像医生律师一样越老越值钱？”</a></p>
<p>翻了一百多个回答，大多答主都是顺着题主的逻辑假定答的</p>
<p>即许多人都是心中假设此前提成立：“程序员是吃青春饭”、“律师医生越老越值钱”</p>
<p>基于“程序员确实吃青春饭”很容易可以得到以下这些“由果倒因”“贩卖焦虑”的观点：</p>
<ol>
<li>医生可以独立出售个人价值，程序员不行</li>
<li>医生知识更新慢，程序员知识更新快</li>
<li>医生是非劳动密集，程序员是劳动密集</li>
<li>医生卖的是个人服务，程序员卖的是coding能力</li>
<li>医生服务的是人，程序员服务的是计算机</li>
</ol>
<p>可如果题主或答主们的前提假定是错的呢？</p>
<p>如果存在“程序员越老越值钱”的事实呢？<a id="more"></a></p>
<h1 id="yi-sheng-ke-yi-du-li-chu-shou-ge-ren-jie-zhi-cheng-xu-yuan-bu-xing"><a href="#医生可以独立出售个人价值，程序员不行" class="headerlink" title="医生可以独立出售个人价值，程序员不行"></a>医生可以独立出售个人价值，程序员不行<a href="#yi-sheng-ke-yi-du-li-chu-shou-ge-ren-jie-zhi-cheng-xu-yuan-bu-xing" class="header-anchor">#</a></h1><p>全科医生可以开个人门诊，君只见全科医生一个人坐诊门诊人流大，票子多，不见即使是最牛的全科大夫，也得让病人老老实实去医院拍CT、做血检做常规的检验流程，末了拿着化验报告再来他这看；这一流程下来，全科医生卖的是个人服务吗？难道不是基于医院各科室流程体系下工作的“工人”罢了。</p>
<p>程序员无法独立出售个人价值？君不见诸如猪八戒、程序员客栈此类外包网站是如何兴起的？个人综合能力强的，此类人有承担软件开发全流程的能力，一个人挑大梁完成”立项-项需-设计-开发-测试-交付”；能力有偏科较弱的，提供“项需-设计-开发-测试-交付”的能力也足以；能力再弱点提供“设计-开发-测试”总可以吧；再不济“开发xx模块”对大多数程序员来说也是很容易达到的。</p>
<p>能否独立出售个人价值，取决于个人提供的价值有多全面，与行业、年龄无关。</p>
<p>医生再强，也无法做到治病救人的全流程：</p>
<ol>
<li>初诊：问诊病史-专科体格检查-辅助检查（化验、B超、电子镜）-初步诊断-治疗方案-处方和治疗单</li>
<li>复诊：基于检查调整判断，修正治疗方案</li>
</ol>
<p>程序员中综合能力强者，是可以做到一个人全挑系统开发生命周期的：</p>
<p>立项-项需-设计-开发-测试-交付</p>
<h1 id="yi-sheng-geng-xin-zhi-shi-man-cheng-xu-yuan-zhi-shi-geng-xin-kuai"><a href="#医生更新知识慢，程序员知识更新快" class="headerlink" title="医生更新知识慢，程序员知识更新快"></a>医生更新知识慢，程序员知识更新快<a href="#yi-sheng-geng-xin-zhi-shi-man-cheng-xu-yuan-zhi-shi-geng-xin-kuai" class="header-anchor">#</a></h1><p>这里有一层潜台词是：年龄越大，越接受不了知识的频繁更新，越适应不了新知识新技术的摄取</p>
<p>社会确实存在“上了一定年纪，学不动了，自然被行业抛弃淘汰”的事实。</p>
<p>网上诸多社区也能看到很多40+找工作力不从心的程序员同行。</p>
<p>细心观察这一类人的特点：40+年龄，喜欢谈管理，不喜谈coding和架构顶层设计，接受不了技术换代，不愿意投入时间补充新技术，没有精力和心劲追赶新知识新潮流，换言之，这一类人身体老（out）了，思想也老（out）了，身心皆老自然被行业淘汰了。</p>
<p>如果观察公司身边其他人呢，积极一些现象是：有这么一类年长者，40+年龄，能熟练编写项需，搭建顶层设计，各种新技术选型信手拈来，最潮流的coding技巧耍的有模又有样，末了交付验收bug少，还能跟产品谈需求变更，教导年轻测试人员编写安全测试用例和系统测试用例。这种人身上散发着朝气，充满了光芒，推动着团队前进，身体元气满满，心灵积极向上，所带团队凝聚力强，扔在就业市场上，这一类人行业竞争力自然强。</p>
<p>是因为年长导致就业困难吗？不是。</p>
<p>究其本质，是思想衰老不愿意投入精力学习，编码能力已经退化至菜鸟新手级别，此时这类人已经算不上程序员了，无法适应行业要求，就业自然困难；这是诸位选择的结果，温水煮青蛙式的慢性淘汰，消极应对行业需求变更，求仁得仁罢了。</p>
<p>以上是我对这个问题的一点看法。希望能鼓励到犹豫不决的人，坚定一个行业走下去的心。</p>
]]></content>
      <categories>
        <category>标签</category>
        <category>杂谈</category>
        <category>日记</category>
      </categories>
      <tags>
        <tag>程序人生，杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>AndroidHandler百问百答</title>
    <url>/ye-jincheng-website/blog/2020/08/handler%20TOP%20100%20Questions/</url>
    <content><![CDATA[<h1 id="android-bai-wen-bai-da-na-xie-nian-bei-wen-guo-de-handler-yuan-li"><a href="#Android百问百答-《那些年被问过的Handler原理》" class="headerlink" title="Android百问百答-《那些年被问过的Handler原理》"></a>Android百问百答-《那些年被问过的Handler原理》<a href="#android-bai-wen-bai-da-na-xie-nian-bei-wen-guo-de-handler-yuan-li" class="header-anchor">#</a></h1><p>文章迁移自<a href="https://blog.csdn.net/chivalrousman/article/details/108014580">我的csdn博客</a></p>
<p>关于Handler，安卓面试最热门的知识点之一。本篇文章将围绕3点展开：</p>
<p>可以提问哪些Questions？</p>
<p>面试官会怎样follow up？</p>
<p>以及怎样寻找答案。</p>
<h2 id="handler-chang-jian-ti-wen"><a href="#Handler常见提问" class="headerlink" title="Handler常见提问"></a>Handler常见提问<a href="#handler-chang-jian-ti-wen" class="header-anchor">#</a></h2><ol>
<li>哪些场景使用到了Handler？用Handler做什么业务？</li>
<li>用Handler遇到什么问题？怎么解决这些问题的？</li>
<li>说一说Handler原理？</li>
<li>能自己实现一个Handler吗？</li>
<li>说一说Handler延时原理？</li>
<li>Handler延时有哪些缺陷？造成这些缺陷的原因？</li>
<li>你知道Handler#handleMessage原理吗？</li>
<li>Handler的post与sendMessage有哪些区别？</li>
<li>子线程能使用Handler吗？</li>
<li>子线程能创建Handler吗？</li>
<li>了解过HandlerThread吗？</li>
<li>了解过IdleHandler吗？</li>
</ol>
<h2 id="handler-chang-jian-follow-up"><a href="#Handler常见Follow-Up" class="headerlink" title="Handler常见Follow Up"></a>Handler常见Follow Up<a href="#handler-chang-jian-follow-up" class="header-anchor">#</a></h2><ol>
<li>你刚才提到了Message，消息屏障听过吗？有几种Message？</li>
<li>Message有什么用？存储了哪些信息？以什么数据结构存储？</li>
<li>APP内最多能有几个Handler？</li>
<li>App内最多能有多少Message？</li>
<li>App内最多能有几个Looper？</li>
<li>App内最多能有几个MessageQueue？</li>
<li>Message如何知道发给哪一个MessageQueue？发给哪个Handler？</li>
<li>MessageQueue如何存储消息，以什么结构存储？</li>
<li>你提到了Looper，请问子线程如何获取Looper？</li>
<li>你提到了Looper，说一说Looper的消息队列模型？</li>
<li>主线程Looper为什么不会阻塞？为什么不会ANR？</li>
<li>子线程跟主线程如何通过Handler通信？</li>
<li>子线程创建Handler这么麻烦，有什么替代方法吗？</li>
<li>主线程Looper什么时候启动的？</li>
<li>对Handler做过哪些优化？</li>
</ol>
<h2 id="handler-yuan-ma-fen-xi"><a href="#Handler源码分析" class="headerlink" title="Handler源码分析"></a>Handler源码分析<a href="#handler-yuan-ma-fen-xi" class="header-anchor">#</a></h2><h3 id="handler-gou-zao-han-shu-yuan-li"><a href="#Handler-构造函数原理" class="headerlink" title="Handler#构造函数原理"></a>Handler#构造函数原理<a href="#handler-gou-zao-han-shu-yuan-li" class="header-anchor">#</a></h3><p>Handler有7个构造函数</p>
<pre><code>Handler()
Handler(Handler.Callback callback)
Handler(Looper looper)
Handler(Looper looper, Handler.Callback callback)
Handler(boolean async)
Handler(Callback callback, boolean async)
Handler(Looper looper, Callback callback, boolean async)
</code></pre>
<p>先从其中一个构造函数看起：<br><img src="https://img-blog.csdnimg.cn/20200814220917812.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoaXZhbHJvdXNtYW4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>提到了MessageQueue、Looper，Message,CallBack暂且记下。</p>
<p>我们根据经验及面试题，关注Handler几个关键API</p>
<ul>
<li>obtainMessage</li>
<li>post</li>
<li>sendMessage</li>
<li>postDelayed</li>
<li>sendMessageDelayed</li>
</ul>
<p>接着我们关注这些API的底层实现，一个一个分析吧！</p>
<h3 id="handler-obtainmessage-yuan-li"><a href="#Handler-obtainMessage-原理" class="headerlink" title="Handler#obtainMessage 原理"></a>Handler#obtainMessage 原理<a href="#handler-obtainmessage-yuan-li" class="header-anchor">#</a></h3><p>Handler#obtainMessage 调用了Message#obtain()</p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-T7alw6p4-1597413794308)(C:\Users\lenovo\AppData\Local\Temp\1597329263919.png)]</p>
<p>可以看到obtain函数从Message链表中获取message，这是一种内存复用，节省了频繁创建内存，如果Message链表为空，则创建一个Message。如果你对Message是个链表有疑问，那么请继续看下面的内容吧！</p>
<h3 id="message-yuan-ma-fen-xi"><a href="#Message源码分析" class="headerlink" title="Message源码分析"></a>Message源码分析<a href="#message-yuan-ma-fen-xi" class="header-anchor">#</a></h3><p>Message有如下公有属性，供程序员调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> what;<span class="comment">//消息标示，</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> arg1; <span class="comment">//简单int类型数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> arg2;<span class="comment">//简单int类型数据</span></span><br><span class="line"><span class="keyword">public</span> Object obj;<span class="comment">//简单Object类型数据</span></span><br><span class="line"><span class="keyword">public</span> Messenger replyTo;<span class="comment">//跨进程信使</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> sendingUid = -<span class="number">1</span>;<span class="comment">//Messenger消息标示</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>Message有如下私有属性,用途如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*package*/</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLAG_IN_USE = <span class="number">1</span> &lt;&lt; <span class="number">0</span>;<span class="comment">//正在使用中</span></span><br><span class="line"><span class="comment">/*package*/</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLAG_ASYNCHRONOUS = <span class="number">1</span> &lt;&lt; <span class="number">1</span>;<span class="comment">//消息同步标识</span></span><br><span class="line"><span class="comment">/*package*/</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLAGS_TO_CLEAR_ON_COPY_FROM = FLAG_IN_USE;<span class="comment">//</span></span><br><span class="line"><span class="comment">/*package*/</span> <span class="keyword">int</span> flags;<span class="comment">//消息执行标识</span></span><br><span class="line"><span class="comment">/*package*/</span> <span class="keyword">long</span> when;<span class="comment">//执行时间</span></span><br><span class="line"><span class="comment">/*package*/</span> Bundle data;<span class="comment">//装载的数据</span></span><br><span class="line"><span class="comment">/*package*/</span> Handler target;<span class="comment">//目标载体</span></span><br><span class="line"><span class="comment">/*package*/</span> Runnable callback;<span class="comment">//任务线程</span></span><br><span class="line"><span class="comment">/*package*/</span> Message next;<span class="comment">//消息链表，下一个消息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object sPoolSync = <span class="keyword">new</span> Object();<span class="comment">//锁对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Message sPool;<span class="comment">//消息池</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> sPoolSize = <span class="number">0</span>;<span class="comment">//消息池大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_POOL_SIZE = <span class="number">50</span>;<span class="comment">//消息池最大消息数常量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> gCheckRecycle = <span class="keyword">true</span>;<span class="comment">//循环检查</span></span><br></pre></td></tr></table></figure>
<p>Message的源码，我们可以得出如下结论，Message是一种链表结构，每个Message持有以下信息：</p>
<ol>
<li>用于传递的数据，如what、arg1、arg2、obj</li>
<li>用于执行当前Message的Handler</li>
<li>用于执行当前Message的回调接口CallBack、子线程Runnable</li>
<li>当前Message的属性，如延时时间、执行标识、Bundle数据，下一个Message引用。这种结构构成了链表。</li>
</ol>
<h3 id="handler-post-de-yuan-li"><a href="#Handler-post的原理" class="headerlink" title="Handler#post的原理"></a>Handler#post的原理<a href="#handler-post-de-yuan-li" class="header-anchor">#</a></h3><p>post函数入口接收一个子线程Runnable对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span>  sendMessageDelayed(getPostMessage(r), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getPostMessage()做了如下工作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Message <span class="title">getPostMessage</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">    Message m = Message.obtain();</span><br><span class="line">    m.callback = r;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sendMessageDelayed做了如下工作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageDelayed</span><span class="params">(Message msg, <span class="keyword">long</span> delayMillis)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        delayMillis = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sendMessageAtTime做了如下工作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">    MessageQueue queue = mQueue;</span><br><span class="line">    <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        RuntimeException e = <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="keyword">this</span> + <span class="string">&quot; sendMessageAtTime() called with no mQueue&quot;</span>);</span><br><span class="line">        Log.w(<span class="string">&quot;Looper&quot;</span>, e.getMessage(), e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终走下了MessageQueue#enqueueMessage</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">    msg.target = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">        msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一步总结如下</p>
<ol>
<li>getPostMessage将Message与Handler绑定</li>
<li>通过SystemClock.uptimeMillis() + delayMillis计算延时时间，delayMillis默认为0</li>
<li>将Message与计算得出的时间值，传递给MessageQueue#enqueueMessage，交由MessageQueue处理Message。</li>
</ol>
<h3 id="handler-sendmessage-yuan-li"><a href="#Handler-sendMessage原理" class="headerlink" title="Handler#sendMessage原理"></a>Handler#sendMessage原理<a href="#handler-sendmessage-yuan-li" class="header-anchor">#</a></h3><p>入口接收Message对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessage</span><span class="params">(Message msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sendMessageDelayed(msg, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后续执行过程与post相同，最终都将Message交由MessageQueue#enqueueMessage处理。</p>
<h3 id="handler-postdelayed-yuan-li"><a href="#Handler-postDelayed原理" class="headerlink" title="Handler#postDelayed原理"></a>Handler#postDelayed原理<a href="#handler-postdelayed-yuan-li" class="header-anchor">#</a></h3><p>与post相比，postDelayed函数入口除了接收Runnable子线程对象，还接收一个时间戳，用于延时时间的计算。其他过程与post相同。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">postDelayed</span><span class="params">(Runnable r, <span class="keyword">long</span> delayMillis)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sendMessageDelayed(getPostMessage(r), delayMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="handler-sendmessagedelayed-yuan-li"><a href="#Handler-sendMessageDelayed原理" class="headerlink" title="Handler#sendMessageDelayed原理"></a>Handler#sendMessageDelayed原理<a href="#handler-sendmessagedelayed-yuan-li" class="header-anchor">#</a></h3><p>与sendMessage类似，多了一个时间戳，用于计算延时时间。其他过程与sendMessage、相同。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageDelayed</span><span class="params">(Message msg, <span class="keyword">long</span> delayMillis)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        delayMillis = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看完源码，我们得出几个结论：</p>
<ol>
<li>无论是Handler#post或者是Handler#sendMessage，Messag都会交由MessageQueue#enqueueMessage执行</li>
<li>MessageQueue#enqueueMessage接收两个参数Message和long型的时间戳</li>
<li>时间戳计算方式是SystemClock.uptimeMillis() + delayMillis</li>
<li>post与sendMessage的区别是入参参数不一样，post接收Runnable子线程，将子线程绑定到Message上；sendMessage持有的是主线程</li>
</ol>
<p>那么我们心中很自然会产生疑问，MessageQueue#enqueueMessage是如何执行的？</p>
<h2 id="messagequeue-yuan-ma-fen-xi"><a href="#MessageQueue源码分析" class="headerlink" title="MessageQueue源码分析"></a>MessageQueue源码分析<a href="#messagequeue-yuan-ma-fen-xi" class="header-anchor">#</a></h2><p>源码分析的思路是构造函数和enqueueMessage</p>
<h3 id="messagequeue-gou-zao-han-shu-yuan-li"><a href="#MessageQueue-构造函数原理" class="headerlink" title="MessageQueue#构造函数原理"></a>MessageQueue#构造函数原理<a href="#messagequeue-gou-zao-han-shu-yuan-li" class="header-anchor">#</a></h3><p>首先来看看构造函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MessageQueue(<span class="keyword">boolean</span> quitAllowed) &#123;</span><br><span class="line">    mQuitAllowed = quitAllowed;</span><br><span class="line">    mPtr = nativeInit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造函数之上定义了很多native方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">nativeInit</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeDestroy</span><span class="params">(<span class="keyword">long</span> ptr)</span></span>;<span class="comment">// 阻塞</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeWake</span><span class="params">(<span class="keyword">long</span> ptr)</span></span>; <span class="comment">// 唤醒</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">nativeIsPolling</span><span class="params">(<span class="keyword">long</span> ptr)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeSetFileDescriptorEvents</span><span class="params">(<span class="keyword">long</span> ptr, <span class="keyword">int</span> fd, <span class="keyword">int</span> events)</span></span>;</span><br></pre></td></tr></table></figure>
<p>native之上定义了几类数据结构，Message、ArrayList、SparseArray、数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Message mMessages; <span class="comment">// 头结点</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;IdleHandler&gt; mIdleHandlers = <span class="keyword">new</span> ArrayList&lt;IdleHandler&gt;();</span><br><span class="line">   <span class="keyword">private</span> SparseArray&lt;FileDescriptorRecord&gt; mFileDescriptorRecords;</span><br><span class="line">   <span class="keyword">private</span> IdleHandler[] mPendingIdleHandlers;</span><br></pre></td></tr></table></figure>
<p>接着我们来看看enqueueMessage是如何处理Message的吧</p>
<h3 id="messagequeue-enqueuemessage-yuan-li"><a href="#MessageQueue-enqueueMessage原理" class="headerlink" title="MessageQueue#enqueueMessage原理"></a>MessageQueue#enqueueMessage原理<a href="#messagequeue-enqueuemessage-yuan-li" class="header-anchor">#</a></h3><p><img src="https://img-blog.csdnimg.cn/20200814221037199.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoaXZhbHJvdXNtYW4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li>图中 1处会判断如果 Message 中的 target 没有被设置，则直接抛出异常；</li>
<li>图中2和 3 处会按照 Message 的时间 when 来有序得插入 MessageQueue 中，可以看出 MessageQueue 实际上是一个链表维护的有序队列，只不过是按照 Message 的执行时间来排序。</li>
</ul>
<p>看到这里，思路似乎终止了，我们跟随Handler、MessQueue的脚步，只看到了Message被插入到MessageQueue的私有队列中。那我们产生的Message什么时候会背消费呢？</p>
<p>视角再次回到一开始的地方——Handler的构造函数原理，在那一节我们提到了Handler构造函数初始化Looper.myLooper()，mLooper.mQueue，接下来我们看看Looper吧！</p>
<h2 id="looper-yuan-ma-fen-xi"><a href="#Looper源码分析" class="headerlink" title="Looper源码分析"></a>Looper源码分析<a href="#looper-yuan-ma-fen-xi" class="header-anchor">#</a></h2><p>查看源码可知，Looper是final类型的，禁止被外部继承修改。</p>
<h3 id="looper-zi-xian-cheng-yong-li"><a href="#Looper-子线程用例" class="headerlink" title="Looper#子线程用例"></a>Looper#子线程用例<a href="#looper-zi-xian-cheng-yong-li" class="header-anchor">#</a></h3><p>首先在Looper类的注释上，我们看到了如下信息，提示我们在子线程中用个Looper.prepare()+Looper.looper()的方式使用Handler<br><img src="https://img-blog.csdnimg.cn/2020081422110294.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoaXZhbHJvdXNtYW4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>为什么需要用这种方式开启Looper呢？</p>
<p>答案是在任何线程要开启Loop，都要用Looper.prepare()+Looper.looper()的方式。以APP主进程为例，APP进程启动入口的main方法，也是通过这种方式开启loop的。与子线程细微不同的是，主线程开启looper用的是prepareMainLooper。</p>
<p><strong>ActivityThread #main方法</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200814221126574.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoaXZhbHJvdXNtYW4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>带着以下疑问，我们去追看源码：Looper构造函数做了什么？prepare做了什么？loop做了什么？</p>
<h3 id="looper-gou-zao-han-shu-yuan-li"><a href="#Looper-构造函数原理" class="headerlink" title="Looper#构造函数原理"></a>Looper#构造函数原理<a href="#looper-gou-zao-han-shu-yuan-li" class="header-anchor">#</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);</span><br><span class="line">    mThread = Thread.currentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Looper构造函数做了两件事情，初始化消息队列MessageQueue对象，记录当前线程信息。</p>
<h3 id="looper-mylooper-yuan-li"><a href="#Looper-myLooper-原理" class="headerlink" title="Looper#myLooper()原理"></a>Looper#myLooper()原理<a href="#looper-mylooper-yuan-li" class="header-anchor">#</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the Looper object associated with the current thread.  Returns</span></span><br><span class="line"><span class="comment"> * null if the calling thread is not associated with a Looper.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> <span class="function">Looper <span class="title">myLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sThreadLocal.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到myLooper是从threadLocal中取出Looper对象。在Looper类中定义了如下变量sThreadLocal、mQueue、sMainLooper、mThread</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sThreadLocal.get() will return null unless you&#x27;ve called prepare().</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;Looper&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Looper sMainLooper;  <span class="comment">// guarded by Looper.class</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> MessageQueue mQueue;</span><br><span class="line"><span class="keyword">final</span> Thread mThread;</span><br></pre></td></tr></table></figure>
<h3 id="looper-prepare-yuan-li"><a href="#Looper-prepare原理" class="headerlink" title="Looper#prepare原理"></a>Looper#prepare原理<a href="#looper-prepare-yuan-li" class="header-anchor">#</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Only one Looper may be created per thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>prepare就是 new 出一个 Looper。核心之处在于将 new 出的 Looper 设置到了线程本地变量 sThreadLocal 中。也就是说创建的 Looper 与当前线程发生了绑定。</p>
<p>Looper#prepareMainLooper原理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepareMainLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    prepare(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (Looper.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sMainLooper != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;The main Looper has already been prepared.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sMainLooper = myLooper();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>prepareMainLooper只有在APP进程启动的时候有用，并不推荐开发者调用这个函数。</p>
<h3 id="looper-loop-yuan-li"><a href="#Looper-loop原理" class="headerlink" title="Looper#loop原理"></a>Looper#loop原理<a href="#looper-loop-yuan-li" class="header-anchor">#</a></h3><p><img src="https://img-blog.csdnimg.cn/20200814221152760.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoaXZhbHJvdXNtYW4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>图1 取出Looper对象</p>
<p>图2 校验当前线程是否持有Looper，是否启动而来Looper.prepare</p>
<p>图3 从Looper中取出对应的MessageQueue，主线程Looper就取出主线程的MessageQueue，子线程就取出子线程MessageQueue</p>
<p>图4 从MessageQueue中取出Message</p>
<p>图5 Message#target属性，即handler，调用Message绑定好的handler#dispatchMessage，处理消息。</p>
<p>也就是说，Message最终交由与Message绑定的Handler处理。Looper只是负责无限循环+从MessageQueue中读取。</p>
<h3 id="handler-dispatchmessage"><a href="#Handler-dispatchMessage" class="headerlink" title="Handler#dispatchMessage"></a>Handler#dispatchMessage<a href="#handler-dispatchmessage" class="header-anchor">#</a></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">  * Handle system messages here.</span><br><span class="line">  *&#x2F;</span><br><span class="line"> public void dispatchMessage(Message msg) &#123;</span><br><span class="line">     if (msg.callback !&#x3D; null) &#123;</span><br><span class="line">         handleCallback(msg);&#x2F;&#x2F; 1</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">         if (mCallback !&#x3D; null) &#123;</span><br><span class="line">             if (mCallback.handleMessage(msg)) &#123;&#x2F;&#x2F; 2</span><br><span class="line">                 return;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         handleMessage(msg);&#x2F;&#x2F; 3</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到有3处可以处理Message</p>
<p>图 1触发了Message#Runnable的run方法，要知道callback就是个Runnable子线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleCallback</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">    message.callback.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>图2 触发了 Handler#Callback接口，Callback是Handler构造函数初始化的时候传递进来的。参考Handler#构造函数原理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callback</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg A &#123;<span class="doctag">@link</span> android.os.Message Message&#125; object</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> True if no further handling is desired</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>图3 触发了Handler的handleMessage方法，这是个空实现，一般由开发者复写实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Subclasses must implement this to receive messages.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Looper这一节，我们暂停脚步总结一下：</p>
<ol>
<li><p>主线程和子线程都可以使用Handler，Handler使用方式都是要Looper.prepare+Lopper.loop,</p>
</li>
<li><p>子线程Handler用法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LooperThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> Handler mHandler;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   Looper.prepare();</span><br><span class="line"></span><br><span class="line">   mHandler = <span class="keyword">new</span> Handler() &#123;</span><br><span class="line">	   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">		   <span class="comment">// process incoming messages here</span></span><br><span class="line">	   &#125;</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   Looper.loop();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">new</span> LooperThread().start();</span><br></pre></td></tr></table></figure>


</li>
</ol>
<p>回答这些面试题吧</p>
<h2 id="mian-shi-ti-jie-xi"><a href="#面试题解析" class="headerlink" title="面试题解析"></a>面试题解析<a href="#mian-shi-ti-jie-xi" class="header-anchor">#</a></h2><h3 id="na-xie-chang-jing-shi-yong-dao-liao-handler-yong-handler-zuo-shi-me-ye-wu"><a href="#哪些场景使用到了Handler？用Handler做什么业务？" class="headerlink" title="哪些场景使用到了Handler？用Handler做什么业务？"></a>哪些场景使用到了Handler？用Handler做什么业务？<a href="#na-xie-chang-jing-shi-yong-dao-liao-handler-yong-handler-zuo-shi-me-ye-wu" class="header-anchor">#</a></h3><h4 id="zui-jian-dan-de-xiao-xi-fa-song"><a href="#最简单的消息发送" class="headerlink" title="最简单的消息发送"></a>最简单的消息发送<a href="#zui-jian-dan-de-xiao-xi-fa-song" class="header-anchor">#</a></h4><p>主线程使用Handler， 主线程里或子线程里发送消息，或延迟发送消息的方式更新UI如，启动应用时Splash页面的延迟2，3秒后，跳转到主页面</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WHAT_UPDATE_ICON = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Handler handler = <span class="keyword">new</span> Handler() &#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">               <span class="keyword">case</span> WHAT_UPDATE_ICON:</span><br><span class="line">                   Log.e(Tag, <span class="string">&quot;receive message:&quot;</span> + msg.obj);</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"> &#125;;</span><br><span class="line">   </span><br><span class="line">   Message msg = handler.obtainMessage(WHAT_UPDATE_ICON);</span><br><span class="line">   msg.obj = <span class="string">&quot;update the imageview&quot;</span>;</span><br><span class="line">   handler.sendMessage(msg);</span><br></pre></td></tr></table></figure>
<p>使用消息的时候，尽量使用 obtainMessage 的方式来获取Message，避免多次创建Message对象，消耗内存，效率低下。</p>
<p>记住：消息不一定是更新UI的消息，可以再handlerMessage中做很多事情！</p>
<h4 id="jie-he-handlerthread-chu-li-hao-shi-ren-wu"><a href="#结合HandlerThread处理耗时任务" class="headerlink" title="结合HandlerThread处理耗时任务"></a>结合HandlerThread处理耗时任务<a href="#jie-he-handlerthread-chu-li-hao-shi-ren-wu" class="header-anchor">#</a></h4><p>结合HandlerThread，串行的处理单个耗时任务，如单任务下载</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DownloadOneByOne</span> <span class="keyword">extends</span> <span class="title">HandlerThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DownloadOneByOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(DownloadOneByOne.class.getSimpleName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLooperPrepared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onLooperPrepared();</span><br><span class="line">        <span class="comment">// 初始化下载组件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> HandlerThread mHandlerThread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Handler downloadHandler = <span class="keyword">new</span> Handler()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">        String url = (String) msg.obj;</span><br><span class="line">        <span class="comment">// 使用下载组件开始下载</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化Handler</span></span><br><span class="line">    mHandlerThread = <span class="keyword">new</span> DownloadOneByOne();</span><br><span class="line">    mHandlerThread.start();</span><br><span class="line">    </span><br><span class="line">    downloadHandler = <span class="keyword">new</span> Handler(mHandlerThread.getLooper());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendDownloadTask</span><span class="params">(String downloadUrl)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 发送下载任务</span></span><br><span class="line">    Message msg = downloadHandler.obtainMessage(WHAT_DOWNLOAD_TASK);</span><br><span class="line">    msg.obj = downloadUrl;</span><br><span class="line">    downloadHandler.sendMessage(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="dao-ji-shi-view-de-jian-yi-shi-xian"><a href="#倒计时View的简易实现" class="headerlink" title="倒计时View的简易实现"></a>倒计时View的简易实现<a href="#dao-ji-shi-view-de-jian-yi-shi-xian" class="header-anchor">#</a></h4><p>通过Handler我们还可以快速简易，并且不占用太多性能的实现一个简易的倒计时View。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownView</span> <span class="keyword">extends</span> <span class="title">AppCompatTextView</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 总时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> seconds;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前分钟</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> minutes;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前秒数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> second = <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SECONDS_PER_MINUTE = <span class="number">60</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MILLS_PER_SECOND = <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MILLS_PER_MINUTE = SECONDS_PER_MINUTE * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WHAT_DONE = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WHAT_TICK = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> marginEnd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringBuilder content = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CountDownView</span><span class="params">(Context context, <span class="meta">@Nullable</span> AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">        DeviceProfile deviceProfile = Launcher.getLauncher(getContext()).getDeviceProfile();</span><br><span class="line">        <span class="keyword">int</span> size = (<span class="keyword">int</span>) (MeasureSpec.getSize(widthMeasureSpec) / deviceProfile.inv.numColumns);</span><br><span class="line">        marginEnd = marginEnd == <span class="number">0</span> ? (size - deviceProfile.iconSizePx) / <span class="number">2</span> : marginEnd;</span><br><span class="line"></span><br><span class="line">        setMarginEnd(marginEnd);</span><br><span class="line">        <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setMarginEnd</span><span class="params">(<span class="keyword">int</span> marginEnd)</span> </span>&#123;</span><br><span class="line">        LinearLayout.LayoutParams layoutParams = (LinearLayout.LayoutParams) getLayoutParams();</span><br><span class="line">        layoutParams.setMarginEnd(marginEnd);</span><br><span class="line">        layoutParams.resolveLayoutDirection(layoutParams.getLayoutDirection());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDetachedFromWindow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDetachedFromWindow();</span><br><span class="line">        <span class="keyword">if</span> (handler.hasMessages(WHAT_TICK)) &#123;</span><br><span class="line">            handler.removeMessages(WHAT_TICK);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Handler handler = <span class="keyword">new</span> Handler() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                <span class="keyword">case</span> WHAT_DONE:</span><br><span class="line">                    setVisibility(View.GONE);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    setText(content.toString());</span><br><span class="line">                    handler.post(runnable);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***</span></span><br><span class="line"><span class="comment">     * 设置倒计时</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> millis</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCountDownMills</span><span class="params">(<span class="keyword">long</span> millis)</span> </span>&#123;</span><br><span class="line">        seconds = (<span class="keyword">long</span>) Math.floor(millis / MILLS_PER_SECOND);</span><br><span class="line">        minutes = (<span class="keyword">long</span>) Math.floor(millis / MILLS_PER_MINUTE) - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// start after one second</span></span><br><span class="line">        handler.postDelayed(runnable, MILLS_PER_SECOND);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (seconds &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                handler.sendEmptyMessage(WHAT_DONE);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            seconds--;</span><br><span class="line">            <span class="keyword">if</span> (second &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                second = SECONDS_PER_MINUTE;</span><br><span class="line">                minutes = (<span class="keyword">long</span>) Math.floor(seconds / SECONDS_PER_MINUTE);</span><br><span class="line">            &#125;</span><br><span class="line">            second--;</span><br><span class="line">            content.delete(<span class="number">0</span>, content.length());</span><br><span class="line"></span><br><span class="line">            appendZeroWhenLower10(minutes);</span><br><span class="line">            content.append(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">            appendZeroWhenLower10(second);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (handler.hasMessages(WHAT_TICK)) &#123;</span><br><span class="line">                handler.removeMessages(WHAT_TICK);</span><br><span class="line">            &#125;</span><br><span class="line">            handler.sendEmptyMessageDelayed(WHAT_TICK, MILLS_PER_SECOND);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> StringBuilder <span class="title">appendZeroWhenLower10</span><span class="params">(<span class="keyword">long</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value &lt; <span class="number">10</span>) &#123;</span><br><span class="line">            content.append(<span class="string">&quot;0&quot;</span>).append(value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            content.append(value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="jie-he-intentservice-de-shi-yong"><a href="#结合IntentService的使用" class="headerlink" title="结合IntentService的使用"></a>结合IntentService的使用<a href="#jie-he-intentservice-de-shi-yong" class="header-anchor">#</a></h4><p>使用IntentService处理耗时的任务相对比较简单，我们来个有难度的，结合AlarmManager的调度，息屏唤醒IntentService定时处理任务的案例来讲</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ACTION_WAKE_UP = <span class="string">&quot;com.doze.cpu.wakeup&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerAlarm</span><span class="params">(Context context, <span class="keyword">int</span> wakeType)</span> </span>&#123;</span><br><span class="line">    type = wakeType;</span><br><span class="line">    <span class="keyword">if</span> (alarmManager == <span class="keyword">null</span>)</span><br><span class="line">        alarmManager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (operation != <span class="keyword">null</span>) alarmManager.cancel(operation);</span><br><span class="line"></span><br><span class="line">    schedule(context);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">schedule</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">    intent.setAction(ACTION_WAKE_UP);</span><br><span class="line">    operation = PendingIntent.getBroadcast(context, <span class="number">0</span>, intent, PendingIntent.FLAG_UPDATE_CURRENT);</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            AlarmUtils.setRTCWakeup(alarmManager, AlarmUtils.DEFAULT_TRIGGER_AT_MILLIS, operation);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            AlarmUtils.setElapsedWakeup(alarmManager, AlarmUtils.DEFAULT_TRIGGER_AT_MILLIS, operation);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定时5分钟发送一个Action为com.doze.cpu.wakeup的广播，我们的广播需要继承 WakefulBroadcastReceiver， 在onReceive里，调用startWakefulService方法，会创建一个1分钟的WakeLock，唤醒cpu处理我们的任务，我们的任务IntentService处理最好不过了，处理完就销毁，不会有多余的占用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WakeCPUReceiver</span> <span class="keyword">extends</span> <span class="title">WakefulBroadcastReceiver</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Intent wakefulIntent = <span class="keyword">new</span> Intent(context, WorkService.class);</span><br><span class="line">        startWakefulService(context, wakefulIntent);</span><br><span class="line">        schedule(context);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>startWakefulService的源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ComponentName <span class="title">startWakefulService</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mActiveWakeLocks) &#123;</span><br><span class="line">            <span class="keyword">int</span> id = mNextId;</span><br><span class="line">            mNextId++;</span><br><span class="line">            <span class="keyword">if</span> (mNextId &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                mNextId = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            intent.putExtra(EXTRA_WAKE_LOCK_ID, id);</span><br><span class="line">            ComponentName comp = context.startService(intent);</span><br><span class="line">            <span class="keyword">if</span> (comp == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            PowerManager pm = (PowerManager)context.getSystemService(Context.POWER_SERVICE);</span><br><span class="line">            PowerManager.WakeLock wl = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,</span><br><span class="line">                    <span class="string">&quot;wake:&quot;</span> + comp.flattenToShortString());</span><br><span class="line">            wl.setReferenceCounted(<span class="keyword">false</span>);</span><br><span class="line">            wl.acquire(<span class="number">60</span>*<span class="number">1000</span>);</span><br><span class="line">            mActiveWakeLocks.put(id, wl);</span><br><span class="line">            <span class="keyword">return</span> comp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在IntentService里，我们在onHandleIntent处理我们的任务后，再调用WakefulBroadcastReceiver的静态方法completeWakefulIntent，释放WakeLock，减少电量的消耗</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkService</span> <span class="keyword">extends</span> <span class="title">IntentService</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onHandleIntent</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        Log.e(WakeCPUReceiver.TAG, <span class="string">&quot;WorkService is working&quot;</span>);</span><br><span class="line">        <span class="comment">// TODO 处理我们的任务</span></span><br><span class="line">        WakeCPUReceiver.completeWakefulIntent(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>completeWakefulIntent源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">completeWakefulIntent</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> id = intent.getIntExtra(EXTRA_WAKE_LOCK_ID, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (id == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (mActiveWakeLocks) &#123;</span><br><span class="line">            PowerManager.WakeLock wl = mActiveWakeLocks.get(id);</span><br><span class="line">            <span class="keyword">if</span> (wl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                wl.release();</span><br><span class="line">                mActiveWakeLocks.remove(id);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// We return true whether or not we actually found the wake lock</span></span><br><span class="line">            <span class="comment">// the return code is defined to indicate whether the Intent contained</span></span><br><span class="line">            <span class="comment">// an identifier for a wake lock that it was supposed to match.</span></span><br><span class="line">            <span class="comment">// We just log a warning here if there is no wake lock found, which could</span></span><br><span class="line">            <span class="comment">// happen for example if this function is called twice on the same</span></span><br><span class="line">            <span class="comment">// intent or the process is killed and restarted before processing the intent.</span></span><br><span class="line">            Log.w(<span class="string">&quot;WakefulBroadcastReceiver&quot;</span>, <span class="string">&quot;No active wake lock id #&quot;</span> + id);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="idlehandler-yong-yu-ui-xing-neng-you-hua"><a href="#IdleHandler-用于UI性能优化" class="headerlink" title="IdleHandler 用于UI性能优化"></a>IdleHandler 用于UI性能优化<a href="#idlehandler-yong-yu-ui-xing-neng-you-hua" class="header-anchor">#</a></h4><p>先计算任务放在Activity绘制结束完成之后，节省了90Ms计算时间。参考面试题你了解过IdleHandler 吗？<br><img src="https://img-blog.csdnimg.cn/20200814221240437.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoaXZhbHJvdXNtYW4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="handlerthread-yong-yu-dan-xian-cheng-xiao-xi-tong-zhi-qi"><a href="#HandlerThread用于单线程消息通知器" class="headerlink" title="HandlerThread用于单线程消息通知器"></a><strong>HandlerThread</strong>用于单线程消息通知器<a href="#handlerthread-yong-yu-dan-xian-cheng-xiao-xi-tong-zhi-qi" class="header-anchor">#</a></h4><p>在用户操作某些界面元素的时候，如收藏、点赞、转发，有一个小的问题，就是如果有一个操作生成10个快速连续的增删改查操作，那么我们的UI就会收到10次回调，而这种场景下我们其实只需要最后一次回调就够了，中间操作其实不用刷新UI的。如何合并这些频繁操作，只在最后一次操作结束时候响应UI更新呢。</p>
<p>答：HandlerThread+反射MessageQueue+idelHandler<br><img src="https://img-blog.csdnimg.cn/20200814221259759.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoaXZhbHJvdXNtYW4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="yong-handler-yu-dao-shi-me-wen-ti-zen-me-jie-jue-zhe-xie-wen-ti-de"><a href="#用Handler遇到什么问题？怎么解决这些问题的？" class="headerlink" title="用Handler遇到什么问题？怎么解决这些问题的？"></a>用Handler遇到什么问题？怎么解决这些问题的？<a href="#yong-handler-yu-dao-shi-me-wen-ti-zen-me-jie-jue-zhe-xie-wen-ti-de" class="header-anchor">#</a></h3><h4 id="wen-ti-handler-yan-shi-bu-zhun-que-jing-chang-dao-liao-shi-jian-bu-xiang-ying-ye-wu"><a href="#问题：Handler延时不准确，经常到了时间不响应业务" class="headerlink" title="问题：Handler延时不准确，经常到了时间不响应业务"></a>问题：Handler延时不准确，经常到了时间不响应业务<a href="#wen-ti-handler-yan-shi-bu-zhun-que-jing-chang-dao-liao-shi-jian-bu-xiang-ying-ye-wu" class="header-anchor">#</a></h4><p>解决：<strong>SystemClock.uptimeMillis()**表示系统</strong>开机到当前的时间总数**，单位是毫秒，但是，当系统进入深度睡眠（CPU休眠、屏幕休眠、设备等待外部输入）时间就会停止，但是不会受到时钟缩放、空闲或者其他节能机制的影响。</p>
<p>使用其他延时方式</p>
<ol>
<li>用concurrent包的TimeUnit类延时sleep()方法延时</li>
<li>Timer+TimeTask</li>
<li>AlarmManager  </li>
<li>ScheduledExecutorService</li>
</ol>
<h4 id="wen-ti-zi-xian-cheng-chuang-jian-handler-shi-bai"><a href="#问题：子线程创建Handler失败" class="headerlink" title="问题：子线程创建Handler失败"></a>问题：子线程创建Handler失败<a href="#wen-ti-zi-xian-cheng-chuang-jian-handler-shi-bai" class="header-anchor">#</a></h4><p>解决：参考Looper#子线程用例部分</p>
<h4 id="wen-ti-fei-jing-tai-lei-dao-zhi-de-nei-cun-xie-lou"><a href="#问题：非静态类导致的内存泄漏" class="headerlink" title="问题：非静态类导致的内存泄漏"></a>问题：非静态类导致的内存泄漏<a href="#wen-ti-fei-jing-tai-lei-dao-zhi-de-nei-cun-xie-lou" class="header-anchor">#</a></h4><p>解决：static+WeakReference</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span></span>&#123;</span><br><span class="line">     WeakReference&lt;MainActivity&gt; mActivity;</span><br><span class="line">     MyHandler(MainActivity activity)&#123;</span><br><span class="line">         mActivity = <span class="keyword">new</span> WeakReference&lt;MainActivity&gt;(activity);</span><br><span class="line">     &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> cuttent = msg.what;</span><br><span class="line"></span><br><span class="line">        MainActivity activity = mActivity.get();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(activity.currentlayout!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            Animation set2 = <span class="keyword">new</span> TranslateAnimation(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,-<span class="number">100</span>);</span><br><span class="line">            set2.setDuration(<span class="number">500</span>);</span><br><span class="line">            activity.currentlayout.setAnimation(set2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        activity.linearLayout.removeAllViews();</span><br><span class="line"></span><br><span class="line">        activity.currentlayout = activity.initView(cuttent);</span><br><span class="line"></span><br><span class="line">        Animation set1 = <span class="keyword">new</span> TranslateAnimation(<span class="number">0</span>,<span class="number">0</span>,<span class="number">100</span>,<span class="number">0</span>);</span><br><span class="line">        set1.setDuration(<span class="number">500</span>);</span><br><span class="line">        activity.currentlayout.setAnimation(set1);</span><br><span class="line"></span><br><span class="line">        activity.linearLayout.addView(activity.currentlayout);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="shuo-yi-shuo-handler-yuan-li"><a href="#说一说Handler原理？" class="headerlink" title="说一说Handler原理？"></a>说一说Handler原理？<a href="#shuo-yi-shuo-handler-yuan-li" class="header-anchor">#</a></h3><p>原理的定义是：某个类的提供哪些功能，这些功能是如何实现的？</p>
<p>我认为回答这个问题包含三步：Handler是什么，关键API是什么，关键对象是什么？</p>
<h4 id="di-yi-bu-hui-da-handler-shi-shi-me-you-na-xie-chang-jing"><a href="#第一步：回答Handler是什么，有哪些场景。" class="headerlink" title="第一步：回答Handler是什么，有哪些场景。"></a>第一步：回答Handler是什么，有哪些场景。<a href="#di-yi-bu-hui-da-handler-shi-shi-me-you-na-xie-chang-jing" class="header-anchor">#</a></h4><p>答：Handler是Android消息通信组件，用于线程间通信，收发消息，更新UI等参考面试题目1。</p>
<h4 id="di-er-bu-handler-de-guan-jian-api-shi-shi-me-yong-tu-shi-shi-me-ru-he-shi-xian-de"><a href="#第二步：Handler的关键API是什么，用途是什么，如何实现的。" class="headerlink" title="第二步：Handler的关键API是什么，用途是什么，如何实现的。"></a>第二步：Handler的关键API是什么，用途是什么，如何实现的。<a href="#di-er-bu-handler-de-guan-jian-api-shi-shi-me-yong-tu-shi-shi-me-ru-he-shi-xian-de" class="header-anchor">#</a></h4><p>答：关键API有：</p>
<p>构造函数：用于绑定MessageQueue、Looper、Message、Runnable、CallBack等</p>
<p>obtainMessage：用于复用Message</p>
<p>post、sendMessage：不同的执行Message方式，前者是接收Runnable参数，后者是当前线程</p>
<p>sendMessageAtTime：消息延时的实现入口，调用MessageQueue#enqueueMessage</p>
<h4 id="di-san-bu-handler-de-guan-jian-dui-xiang-shi-shi-me-ti-gong-na-xie-gong-neng-zhe-xie-gong-neng-ru-he-shi-xian-de"><a href="#第三步：Handler的关键对象是什么，提供哪些功能，这些功能如何实现的。" class="headerlink" title="第三步：Handler的关键对象是什么，提供哪些功能，这些功能如何实现的。"></a>第三步：Handler的关键对象是什么，提供哪些功能，这些功能如何实现的。<a href="#di-san-bu-handler-de-guan-jian-dui-xiang-shi-shi-me-ti-gong-na-xie-gong-neng-zhe-xie-gong-neng-ru-he-shi-xian-de" class="header-anchor">#</a></h4><p>答：关键对象有：</p>
<p>Message</p>
<p>Message是一种链表结构的子节点，作为载体可以存储的信息有：公开信息arg1、arg2、handler、Message，私有信息when、Runnable。Message有2种Flag，使用中、同步中，三种消息类型，如普通消息、异步消息、消息屏障。</p>
<p>MessageQueue</p>
<p>MessageQueue提供一种链表数据结构，包括头结点信息，插入节点的方式是按照 Message 的时间 when 顺序，时间小的先插入 。</p>
<p>Looper</p>
<p>开启无限循环，不断从 MessageQueue 中取出 Message，然后处理 Message 中指定的任务。典型的Looper是主线程Looper，在 ActivityThread 的 main 方法中，除了调用 Looper.prepareMainLooper 初始化 Looper 对象之外，还调用了 Looper.loop 方法开启无限循环，Looper 的主要功能就是在这个循环中完成的。</p>
<p>Looper提供了一些native方法用于唤醒阻塞状态如nativePollOnce</p>
<p>Looper不断loop的结果，就是调用msg.target.handleMessage,即执行开发者定义好的Handler#handleMessage方法体中的业务。</p>
<h3 id="neng-zi-ji-shi-xian-yi-ge-handler-ma"><a href="#能自己实现一个Handler吗？" class="headerlink" title="能自己实现一个Handler吗？"></a>能自己实现一个Handler吗？<a href="#neng-zi-ji-shi-xian-yi-ge-handler-ma" class="header-anchor">#</a></h3><p>根据Handler的类图，我们可以抽象出Handler消息组件的基本架构。<br><img src="https://img-blog.csdnimg.cn/20200814221418179.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoaXZhbHJvdXNtYW4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="jian-ban-handler"><a href="#简版Handler" class="headerlink" title="简版Handler"></a>简版Handler<a href="#jian-ban-handler" class="header-anchor">#</a></h4><p>概要设计：</p>
<p>首先我们仿照Android的Handler定义了：阻塞队列、处理消息的回调、分发和发送消息的方法<br>其次然后在创建Handler时，我们获取了当前线程的Looper和MessageQueue</p>
<p>最后，当我们发送消息的时候，将消息添加进之前得到的MessageQueue</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MyMessageQueue queue;<span class="comment">// 用于进行线程间通信的阻塞队列</span></span><br><span class="line">    <span class="keyword">private</span> CallBack callBack; <span class="comment">// 处理消息的回调</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyHandler</span><span class="params">(CallBack callBack)</span> </span>&#123;</span><br><span class="line">        MyLooper looper = MyLooper.myLooper();</span><br><span class="line">        <span class="keyword">if</span> (looper == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;在新开的线程中。创建MyHandler对象需要先调用MyLooper.prepare()方法。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        queue = looper.queue;</span><br><span class="line">        <span class="keyword">this</span>.callBack = callBack;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消息接收的回调</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CallBack</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(MyMessage msg)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(MyMessage msg)</span> </span>&#123;</span><br><span class="line">        msg.target = <span class="keyword">this</span>;</span><br><span class="line">        queue.enqueueMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//派发消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(MyMessage msg)</span> </span>&#123;</span><br><span class="line">        callBack.handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="jian-ban-looper"><a href="#简版Looper" class="headerlink" title="简版Looper"></a>简版Looper<a href="#jian-ban-looper" class="header-anchor">#</a></h4><ol>
<li>在Looper中，我们用一个ThreadLocal存储当前Looper的相关数据</li>
<li>定义了一个消息队列，用来管理消息</li>
<li>在prepare()时，用ThreadLocal存储Looper的数据；在myLooper时，读取ThreadLocal存储的Looper数据</li>
<li>在loop()时,用一个死循环来不断的接受和分发消息</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLooper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;MyLooper&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> MyLooper myLooper;</span><br><span class="line">    <span class="keyword">public</span> MyMessageQueue queue;<span class="comment">//一个线程对应一个阻塞队列</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MyLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queue = <span class="keyword">new</span> MyMessageQueue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取当前线程相对应的Looper对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MyLooper <span class="title">myLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> threadLocal.get();<span class="comment">//当未调用prepare()方法时。ThreadLocal.get()方法返回的为null;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为本线程准备对应的MyLooper对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (threadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException( <span class="string">&quot;Only one MyLooper may be created per thread&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        threadLocal.set(<span class="keyword">new</span> MyLooper());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里启动消息循环</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            myLooper = myLooper();</span><br><span class="line">            MyMessageQueue mQueue = myLooper.queue;</span><br><span class="line">            senior.thread_concurrent.handler.MyMessage msg = mQueue.next();<span class="comment">// take()方法是个阻塞方法。线程运行到此会阻塞住。以准备接收发过来的消息</span></span><br><span class="line">            msg.target.dispatchMessage(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="jian-ban-messagequeue"><a href="#简版MessageQueue" class="headerlink" title="简版MessageQueue"></a>简版MessageQueue<a href="#jian-ban-messagequeue" class="header-anchor">#</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMessageQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;MyMessage&gt; queue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> quit = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyMessageQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</span><br><span class="line">        queue.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入队</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MyMessage msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;消息必须有一个消息处理者&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            queue.put(msg);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出队</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyMessage <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MyMessage msg = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (quit) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            msg = queue.take();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//销毁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">quit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        quit = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="jian-ban-message"><a href="#简版Message" class="headerlink" title="简版Message"></a>简版Message<a href="#jian-ban-message" class="header-anchor">#</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMessage</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> msg1;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> msg2;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> what;</span><br><span class="line">    <span class="keyword">public</span> Object obj;</span><br><span class="line">    <span class="keyword">public</span> MyHandler target;</span><br><span class="line">    <span class="keyword">public</span> Runnable runnable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="xie-yi-ge-wang-luo-qing-qiu-de-ce-shi-yong-li"><a href="#写一个网络请求的测试用例" class="headerlink" title="写一个网络请求的测试用例"></a>写一个网络请求的测试用例<a href="#xie-yi-ge-wang-luo-qing-qiu-de-ce-shi-yong-li" class="header-anchor">#</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> senior.thread_concurrent.handler.MyHandler mainHandler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> TestClient().test();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化主线程Looper</span></span><br><span class="line">        MyLooper.prepare();</span><br><span class="line">        mainHandler = <span class="keyword">new</span> senior.thread_concurrent.handler.MyHandler(<span class="keyword">new</span> senior.thread_concurrent.handler.MyHandler.CallBack() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(senior.thread_concurrent.handler.MyMessage msg)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 刷新界面</span></span><br><span class="line">                String obj = (String) msg.obj;</span><br><span class="line">                LogUtil.print(<span class="string">&quot;刷新界面:&quot;</span> + obj);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//发起网络请求</span></span><br><span class="line">        LogUtil.print(<span class="string">&quot;在主线程发起一个网络请求&quot;</span>);</span><br><span class="line">        NetThread netThread = <span class="keyword">new</span> NetThread(<span class="string">&quot;http://baidu.com&quot;</span>);</span><br><span class="line">        netThread.start();</span><br><span class="line">        LogUtil.print(<span class="string">&quot;在主线程继续其它操作&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开始消息循环</span></span><br><span class="line">        MyLooper.loop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//网络线程类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">NetThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String url;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">NetThread</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.url = url;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            String body = getWebData(url);</span><br><span class="line">            senior.thread_concurrent.handler.MyMessage msg = <span class="keyword">new</span> senior.thread_concurrent.handler.MyMessage();</span><br><span class="line">            msg.obj = body;</span><br><span class="line">            mainHandler.sendMessage(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行网络请求</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getWebData</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">        LogUtil.print(<span class="string">&quot;执行请求网络:&quot;</span> + url);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        String body = <span class="string">&quot;这是&quot;</span> + url + <span class="string">&quot;的响应值&quot;</span>;</span><br><span class="line">        LogUtil.print(<span class="string">&quot;请求网络成功:&quot;</span> + body);</span><br><span class="line">        <span class="keyword">return</span> body;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="shuo-yi-shuo-handler-yan-shi-yuan-li"><a href="#说一说Handler延时原理？" class="headerlink" title="说一说Handler延时原理？"></a>说一说Handler延时原理？<a href="#shuo-yi-shuo-handler-yan-shi-yuan-li" class="header-anchor">#</a></h3><p>首先Handler无论是post还是sendMessage方式处理Message过程中，都会产生一个时间戳，计算方式是SystemClock.uptimeMillis() + delayMillis，这个时间戳会赋值给Message.when，影响Message在MessageQueue链表中的位置。时间戳值越大，越晚执行。</p>
<p>Handler延时存在时间不准的问题，问题产生原因以及解决办法以及在<u>面试题2问题：Handler延时不准确，经常到了时间不响应业务</u>提到。</p>
<h3 id="handler-yan-shi-you-na-xie-que-xian-zao-cheng-zhe-xie-que-xian-de-yuan-yin"><a href="#Handler延时有哪些缺陷？造成这些缺陷的原因？" class="headerlink" title="Handler延时有哪些缺陷？造成这些缺陷的原因？"></a>Handler延时有哪些缺陷？造成这些缺陷的原因？<a href="#handler-yan-shi-you-na-xie-que-xian-zao-cheng-zhe-xie-que-xian-de-yuan-yin" class="header-anchor">#</a></h3><p>参考<u>面试题2问题：Handler延时不准确，经常到了时间不响应业务</u></p>
<p>Handler的post与sendMessage有哪些区别？</p>
<p>post需要指定Runnable参数，将传入的Runnable绑定至Handler默认的Message，很多值都为默认值，换言之post方法只是为了执行Runnable子线程的任务。</p>
<p>sendMessage需要传入开发者自定义的Message参数，将Message中的信息载体传递下去，sendMessage方法是为了传递消息。</p>
<p>两者最终都会将Message传递下去，区别是Message中的数据信息赋值数量的不同。</p>
<h3 id="zi-xian-cheng-neng-shi-yong-handler-ma"><a href="#子线程能使用Handler吗？" class="headerlink" title="子线程能使用Handler吗？"></a>子线程能使用Handler吗？<a href="#zi-xian-cheng-neng-shi-yong-handler-ma" class="header-anchor">#</a></h3><p>能，可以使用handler对象以及对应的方法。区别是Handler的创建位置，如果Handler在主线程创建，那么只能在主线程中处理消息。如果在子线程创建Handler，那么才能在子线程处理消息。</p>
<h3 id="zi-xian-cheng-neng-chuang-jian-handler-ma"><a href="#子线程能创建Handler吗？" class="headerlink" title="子线程能创建Handler吗？"></a>子线程能创建Handler吗？<a href="#zi-xian-cheng-neng-chuang-jian-handler-ma" class="header-anchor">#</a></h3><p>能，前提是需要Looper.prepare+Looper.loop</p>
<p>Looper.prepare是将当前线程添加到sThreadLocal中，Looper.loop是开启无限循环，不断执行Message</p>
<h3 id="zi-xian-cheng-chuang-jian-handler-zhe-me-ma-fan-you-shi-me-ti-dai-fang-fa-ma-liao-jie-guo-handlerthread-ma"><a href="#子线程创建Handler这么麻烦，有什么替代方法吗？了解过HandlerThread吗？" class="headerlink" title="子线程创建Handler这么麻烦，有什么替代方法吗？了解过HandlerThread吗？"></a>子线程创建Handler这么麻烦，有什么替代方法吗？了解过HandlerThread吗？<a href="#zi-xian-cheng-chuang-jian-handler-zhe-me-ma-fan-you-shi-me-ti-dai-fang-fa-ma-liao-jie-guo-handlerthread-ma" class="header-anchor">#</a></h3><p>HandlerThread的run方法中替我们做了Looper.prepare+Looper.loop</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HandlerThread handlerThread = <span class="keyword">new</span> HandlerThread(<span class="string">&quot;handler-thread&quot;</span>);</span><br><span class="line">handlerThread.start(); <span class="comment">// 必须在Handler创建前调用，因为线程start后才会创建Looper</span></span><br><span class="line"></span><br><span class="line">Handler threadHandler = <span class="keyword">new</span> Handler(handlerThread.getLooper()) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">        <span class="comment">// 处理消息，因为这个方法是在子线程调用，所以可以在这执行耗时任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="liao-jie-guo-idlehandler-ma"><a href="#了解过IdleHandler吗？" class="headerlink" title="了解过IdleHandler吗？"></a>了解过IdleHandler吗？<a href="#liao-jie-guo-idlehandler-ma" class="header-anchor">#</a></h3><p>IdleHandler 用途：</p>
<ol>
<li>IdleHandler 是 Handler 提供的一种在消息队列空闲时，执行任务的时机；</li>
<li>当 MessageQueue 当前没有立即需要处理的消息时，会执行 IdleHandler；</li>
<li>Activity界面绘制结束的回调时机</li>
</ol>
<p>IdleHandler 缺点：</p>
<ol>
<li>但它执行的时机依赖消息队列的情况，那么如果 MessageQueue 一直有待执行的消息时，IdleHandler 就一直得不到执行，也就是它的执行时机是不可控的，不适合执行一些对时机要求比较高的任务。</li>
</ol>
<p>IdleHandler场景</p>
<p>如果我们想在界面绘制出来后做点什么，那么在onResume里面是不合适的，它先于measure等流程了<strong>， **有人可能会说在onResume里面post一个runnable可以吗？还是不行，因为那样就会变成这个样子</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200814221532843.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoaXZhbHJvdXNtYW4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>所以你的行为一样会在绘制之前执行，这个时候我们的主角IdleHandler就发挥作用了，我们前面说了，它是在looper里面message暂时执行完毕了就会回调，顾名思义嘛，Idle就是队列为空的意思，那么我们的onResume和measure, layout, draw都是一个个message的话，这个IdleHandler就提供了一个它们都执行完毕的回调了，大概就是这样<br><img src="https://img-blog.csdnimg.cn/20200814221511481.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoaXZhbHJvdXNtYW4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>也就是说IdleHandler可以再界面绘制的消息回调之后执行。<br><img src="https://img-blog.csdnimg.cn/20200814221456646.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoaXZhbHJvdXNtYW4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>优化前：</p>
<p>这个是我们地图的公交详情页面， 进入之后产品要求左边的页卡需要展示，可以看到左边的页卡是一个非常复杂的布局，那么进入之后的效果可以明显看到头部的展示信息是先显示空白再100毫秒左右之后才展示出来的，原因就是这个页卡的内容比较复杂，用数据向它填充的时候花了较长时间，代码如下：<br><img src="https://img-blog.csdnimg.cn/2020081422161443.png#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9mLndldGVzdC5xcS5jb20vZ3FvcC8xMDAwMC8yMDAwMC9MYWJJbWFnZV8xNjY0ODA1Yjc3YTAxZDE5MGUwY2Y2MGY2YjkxMGI1MS5naWY"></p>
<p>可以看到这个detailView就是这个侧滑的页卡了，填充里面的数据花了90ms，如果这个时间是用在了界面view绘制之前的话，就会出现以上的效果了，view先是白的，再出现，这样就体验不好了。</p>
<p>优化后：如果我们把它放到IdleHandler里面呢？</p>
<p>结果非常明显：顶部的页卡先展示出来了，这样体验是不是会更好一些呢。虽然只有短短90ms，不过我们做app也应该关注这种细节优化的，是吧~ 这个做法也提供了一种思路，android本身提供的activity框架和fragment框架并没有提供绘制完成的回调，如果我们自己实现一个框架，就可以使用这个IdleHandler来实现一个onRenderFinished这种回调了。</p>
<p>代码如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20200814221558397.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoaXZhbHJvdXNtYW4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9mLndldGVzdC5xcS5jb20vZ3FvcC8xMDAwMC8yMDAwMC9MYWJJbWFnZV83MTliYjQ0YjE3NTZkOTE4OGJkOGExMzQyNTE1NWIzYS5naWY"><br>特别参考</p>
<p><a href="https://wetest.qq.com/lab/view/352.html">https://wetest.qq.com/lab/view/352.html</a></p>
<p><a href="https://blog.csdn.net/u013718120/article/details/51945490">https://blog.csdn.net/u013718120/article/details/51945490</a></p>
]]></content>
      <categories>
        <category>Android</category>
        <category>面试</category>
        <category>应用层</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Handler</tag>
      </tags>
  </entry>
</search>
