<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>程序员吃的是青春饭吗？</title>
    <url>/ye-jincheng-website/Is%20coder%20need%20more%20younger%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="cheng-xu-yuan-chi-de-shi-qing-chun-fan-ma"><a href="#程序员吃的是青春饭吗？" class="headerlink" title="程序员吃的是青春饭吗？"></a>程序员吃的是青春饭吗？<a href="#cheng-xu-yuan-chi-de-shi-qing-chun-fan-ma" class="header-anchor">#</a></h1><p>昨天在知乎上看到一个提问<a href="https://www.zhihu.com/question/444102247">“程序员为什么是吃青春饭，而不是像医生律师一样越老越值钱？”</a></p>
<p>翻了一百多个回答，大多答主都是顺着题主的逻辑假定答的</p>
<p>即许多人都是心中假设此前提成立：“程序员是吃青春饭”、“律师医生越老越值钱”</p>
<p>基于“程序员确实吃青春饭”很容易可以得到以下这些“由果倒因”“贩卖焦虑”的观点：</p>
<ol>
<li>医生可以独立出售个人价值，程序员不行</li>
<li>医生知识更新慢，程序员知识更新快</li>
<li>医生是非劳动密集，程序员是劳动密集</li>
<li>医生卖的是个人服务，程序员卖的是coding能力</li>
<li>医生服务的是人，程序员服务的是计算机</li>
</ol>
<p>可如果题主或答主们的前提假定是错的呢？</p>
<p>如果存在“程序员越老越值钱”的事实呢？<a id="more"></a></p>
<h1 id="yi-sheng-ke-yi-du-li-chu-shou-ge-ren-jie-zhi-cheng-xu-yuan-bu-xing"><a href="#医生可以独立出售个人价值，程序员不行" class="headerlink" title="医生可以独立出售个人价值，程序员不行"></a>医生可以独立出售个人价值，程序员不行<a href="#yi-sheng-ke-yi-du-li-chu-shou-ge-ren-jie-zhi-cheng-xu-yuan-bu-xing" class="header-anchor">#</a></h1><p>全科医生可以开个人门诊，君只见全科医生一个人坐诊门诊人流大，票子多，不见即使是最牛的全科大夫，也得让病人老老实实去医院拍CT、做血检做常规的检验流程，末了拿着化验报告再来他这看；这一流程下来，全科医生卖的是个人服务吗？难道不是基于医院各科室流程体系下工作的“工人”罢了。</p>
<p>程序员无法独立出售个人价值？君不见诸如猪八戒、程序员客栈此类外包网站是如何兴起的？个人综合能力强的，此类人有承担软件开发全流程的能力，一个人挑大梁完成”立项-项需-设计-开发-测试-交付”；能力有偏科较弱的，提供“项需-设计-开发-测试-交付”的能力也足以；能力再弱点提供“设计-开发-测试”总可以吧；再不济“开发xx模块”对大多数程序员来说也是很容易达到的。</p>
<p>能否独立出售个人价值，取决于个人提供的价值有多全面，与行业、年龄无关。</p>
<p>医生再强，也无法做到治病救人的全流程：</p>
<ol>
<li>初诊：问诊病史-专科体格检查-辅助检查（化验、B超、电子镜）-初步诊断-治疗方案-处方和治疗单</li>
<li>复诊：基于检查调整判断，修正治疗方案</li>
</ol>
<p>程序员中综合能力强者，是可以做到一个人全挑系统开发生命周期的：</p>
<p>立项-项需-设计-开发-测试-交付</p>
<h1 id="yi-sheng-geng-xin-zhi-shi-man-cheng-xu-yuan-zhi-shi-geng-xin-kuai"><a href="#医生更新知识慢，程序员知识更新快" class="headerlink" title="医生更新知识慢，程序员知识更新快"></a>医生更新知识慢，程序员知识更新快<a href="#yi-sheng-geng-xin-zhi-shi-man-cheng-xu-yuan-zhi-shi-geng-xin-kuai" class="header-anchor">#</a></h1><p>这里有一层潜台词是：年龄越大，越接受不了知识的频繁更新，越适应不了新知识新技术的摄取</p>
<p>社会确实存在“上了一定年纪，学不动了，自然被行业抛弃淘汰”的事实。</p>
<p>网上诸多社区也能看到很多40+找工作力不从心的程序员同行。</p>
<p>细心观察这一类人的特点：40+年龄，喜欢谈管理，不喜谈coding和架构顶层设计，接受不了技术换代，不愿意投入时间补充新技术，没有精力和心劲追赶新知识新潮流，换言之，这一类人身体老（out）了，思想也老（out）了，身心皆老自然被行业淘汰了。</p>
<p>如果观察公司身边其他人呢，积极一些现象是：有这么一类年长者，40+年龄，能熟练编写项需，搭建顶层设计，各种新技术选型信手拈来，最潮流的coding技巧耍的有模又有样，末了交付验收bug少，还能跟产品谈需求变更，教导年轻测试人员编写安全测试用例和系统测试用例。这种人身上散发着朝气，充满了光芒，推动着团队前进，身体元气满满，心灵积极向上，所带团队凝聚力强，扔在就业市场上，这一类人行业竞争力自然强。</p>
<p>是因为年长导致就业困难吗？不是。</p>
<p>究其本质，是思想衰老不愿意投入精力学习，编码能力已经退化至菜鸟新手级别，此时这类人已经算不上程序员了，无法适应行业要求，就业自然困难；这是诸位选择的结果，温水煮青蛙式的慢性淘汰，消极应对行业需求变更，求仁得仁罢了。</p>
<p>以上是我对这个问题的一点看法。希望能鼓励到犹豫不决的人，坚定一个行业走下去的心。</p>
]]></content>
      <categories>
        <category>标签</category>
        <category>杂谈</category>
        <category>日记</category>
      </categories>
      <tags>
        <tag>程序人生，杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>波尔克</title>
    <url>/ye-jincheng-website/website_nickname/</url>
    <content><![CDATA[<h1 id="bo-er-ke"><a href="#波尔克" class="headerlink" title="波尔克"></a>波尔克<a href="#bo-er-ke" class="header-anchor">#</a></h1><h1 id="jie-shao"><a href="#介绍" class="headerlink" title="介绍"></a>介绍<a href="#jie-shao" class="header-anchor">#</a></h1><p>阿里云服务器用了三年了，上个月到期忘了续费。云服务器上的文章资料忘了及时导出，也被阿里清空了，甚是心疼。于是花了一天时间，使用码云仓库搭一个个人网站，免费，简单，便捷，空间够用。这篇文章主要包含了个人网站的技术架构。包括使用的oss管理平台、域名管理、评论管理、文章编辑与发布、网站编辑管理等功能的设计与实现。<a id="more"></a></p>
<h1 id="wang-zhan-jia-gou"><a href="#网站架构" class="headerlink" title="网站架构"></a>网站架构<a href="#wang-zhan-jia-gou" class="header-anchor">#</a></h1><table>
<thead>
<tr>
<th>名称</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>typora</td>
<td>markdown编辑器</td>
</tr>
<tr>
<td>hexo</td>
<td>博客服务</td>
</tr>
<tr>
<td>nodejs</td>
<td>hexo编译环境</td>
</tr>
<tr>
<td>gitee</td>
<td>码云代码仓库</td>
</tr>
<tr>
<td>next</td>
<td>hexo主题</td>
</tr>
<tr>
<td>七牛云</td>
<td>oss图片文件仓库</td>
</tr>
<tr>
<td>阿里云域名</td>
<td>域名转发、cdn转发</td>
</tr>
<tr>
<td>hexo-toc</td>
<td>文档插件显示二级目录，响应点击事件</td>
</tr>
<tr>
<td>hexo-renderer-markdown-it-plus</td>
<td>markdown解析插件</td>
</tr>
<tr>
<td>leanclound</td>
<td>阅读量统计插件，如何配置<a href="https://blog.csdn.net/lijing742180/article/details/87928554">参考文章</a></td>
</tr>
</tbody></table>
<h1 id="mo-ban-jia-gou"><a href="#模板架构" class="headerlink" title="模板架构"></a>模板架构<a href="#mo-ban-jia-gou" class="header-anchor">#</a></h1><table>
<thead>
<tr>
<th>模板名称</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>android-xx-Tips</td>
<td>Android百问百答模板</td>
</tr>
<tr>
<td>book-note-model</td>
<td>读书笔记模板</td>
</tr>
<tr>
<td>draft</td>
<td>草稿模板</td>
</tr>
<tr>
<td>page</td>
<td>页面模板</td>
</tr>
<tr>
<td>post</td>
<td>文章模板</td>
</tr>
</tbody></table>
<h1 id="an-zhuang-jiao-cheng"><a href="#安装教程" class="headerlink" title="安装教程"></a>安装教程<a href="#an-zhuang-jiao-cheng" class="header-anchor">#</a></h1><h2 id="nodejs-an-zhuang-jiao-cheng"><a href="#nodejs安装教程" class="headerlink" title="nodejs安装教程"></a>nodejs安装教程<a href="#nodejs-an-zhuang-jiao-cheng" class="header-anchor">#</a></h2><p>步骤太简单了，难点就是找到合适版本、合适渠道的安装包，推荐国内使用方式2node中文网的方式下载安装</p>
<table>
<thead>
<tr>
<th>方式</th>
<th>缺点</th>
<th>优点</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://nodejs.org/zh-cn/">node官网</a>，点击链接下载，一路next同意协议安装</td>
<td>国外服务器下载慢</td>
<td>最新安装包</td>
</tr>
<tr>
<td><a href="http://nodejs.cn/">node中文网</a>，点击链接下载，一路next同意协议安装</td>
<td>安装包版本落后1-2个版本</td>
<td>国内服务器下载快</td>
</tr>
</tbody></table>
<h2 id="ma-yun-pei-zhi-wang-zhan-jiao-cheng"><a href="#码云配置网站教程" class="headerlink" title="码云配置网站教程"></a>码云配置网站教程<a href="#ma-yun-pei-zhi-wang-zhan-jiao-cheng" class="header-anchor">#</a></h2><h2 id="git-shi-yong-jiao-cheng"><a href="#git使用教程" class="headerlink" title="git使用教程"></a>git使用教程<a href="#git-shi-yong-jiao-cheng" class="header-anchor">#</a></h2><h2 id="hexo-shi-yong-jiao-cheng"><a href="#hexo使用教程" class="headerlink" title="hexo使用教程"></a>hexo使用教程<a href="#hexo-shi-yong-jiao-cheng" class="header-anchor">#</a></h2><p>hexo官网有详细步骤，小白可以参考百度上的安装教程博客</p>
<table>
<thead>
<tr>
<th>方式</th>
<th>步骤</th>
<th>缺点</th>
<th>优点</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://hexo.io/zh-cn/docs/">hexo官网</a>，权威hexo安装步骤</td>
<td>npm install -g hexo-cli；</td>
<td>不适合小白用户，命令行操作居多</td>
<td>简洁，明了，歧义少</td>
</tr>
<tr>
<td>搜索引擎“hexo安装步骤”</td>
<td><a href="https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html">《参考》</a></td>
<td>遇到问题较难解答</td>
<td>傻瓜式，上手快</td>
</tr>
</tbody></table>
<h1 id="hexo-chang-jian-zhi-ling"><a href="#hexo常见指令" class="headerlink" title="hexo常见指令"></a>hexo常见指令<a href="#hexo-chang-jian-zhi-ling" class="header-anchor">#</a></h1><table>
<thead>
<tr>
<th>指令</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>hexo init</td>
<td>在当前目录下创建工程</td>
</tr>
<tr>
<td>_config.yml</td>
<td>deploy:   type: git   repository: <a href="mailto:&#103;&#105;&#116;&#64;&#x67;&#x69;&#116;&#104;&#x75;&#x62;&#x2e;&#x63;&#x6f;&#x6d;">&#103;&#105;&#116;&#64;&#x67;&#x69;&#116;&#104;&#x75;&#x62;&#x2e;&#x63;&#x6f;&#x6d;</a>:liuxianan/liuxianan.github.io.git   branch: master</td>
</tr>
<tr>
<td>hexo clean</td>
<td>清除缓存</td>
</tr>
<tr>
<td>hexo g</td>
<td>生成web</td>
</tr>
<tr>
<td>hexo s</td>
<td>启动web服务并预览，在浏览器输入 <a href="http://localhost:4000/">http://localhost:4000</a></td>
</tr>
<tr>
<td>hexo d</td>
<td>发布pulic 目录下的静态页面至github</td>
</tr>
<tr>
<td>git clone url themes/yilia</td>
<td>下载指定主题到根目录/thems/yilia/ 下</td>
</tr>
<tr>
<td>hexo new “postName”</td>
<td>新建文章，hexo n</td>
</tr>
<tr>
<td>hexo new page “pageName”</td>
<td>#新建页面</td>
</tr>
<tr>
<td>hexo generate</td>
<td>生成静态页面至public目录，hexo g</td>
</tr>
<tr>
<td>hexo server</td>
<td>开启预览访问端口（默认端口4000，’ctrl + c’关闭server）</td>
</tr>
<tr>
<td>hexo deploy</td>
<td>hexo d</td>
</tr>
<tr>
<td>hexo s -g</td>
<td>生成并本地预览</td>
</tr>
</tbody></table>
<h1 id="markdwon-shi-yong-ji-qiao"><a href="#markdwon使用技巧" class="headerlink" title="markdwon使用技巧"></a>markdwon使用技巧<a href="#markdwon-shi-yong-ji-qiao" class="header-anchor">#</a></h1><h2 id="suo-fang-tu-pian-si-chong-chong-ji-qiao"><a href="#缩放图片四种种技巧" class="headerlink" title="缩放图片四种种技巧"></a>缩放图片四种种技巧<a href="#suo-fang-tu-pian-si-chong-chong-ji-qiao" class="header-anchor">#</a></h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;img src=&quot;&quot; width=&quot;50%&quot; height=&quot;50%&quot;&gt;</span><br><span class="line">![test image size](url)&#123;:class=&quot;img-responsive&quot;&#125;</span><br><span class="line">![test image size](url)&#123;:height=&quot;50%&quot; width=&quot;50%&quot;&#125;</span><br><span class="line">![test image size](url)&#123;:height=&quot;100px&quot; width=&quot;400px&quot;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="she-zhi-zi-ti-yan-se"><a href="#设置字体颜色" class="headerlink" title="设置字体颜色"></a>设置字体颜色<a href="#she-zhi-zi-ti-yan-se" class="header-anchor">#</a></h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">style</span>=<span class="string">&quot;color:green&quot;</span>&gt;</span>**数学日记**<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h1 id="chang-jian-wen-ti"><a href="#常见问题" class="headerlink" title="常见问题**"></a>常见问题**<a href="#chang-jian-wen-ti" class="header-anchor">#</a></h1><h2 id="ma-yun-bu-shu-hexo-zhan-dian-css-yang-shi-bu-xian-shi"><a href="#码云部署hexo站点-css样式不显示？" class="headerlink" title="码云部署hexo站点 css样式不显示？"></a><strong>码云部署hexo站点 css样式不显示？</strong><a href="#ma-yun-bu-shu-hexo-zhan-dian-css-yang-shi-bu-xian-shi" class="header-anchor">#</a></h2><p>原因：仓库地址与个性地址url不一致<br>解决：修改_config.yml<br>    ​<code>xml     url: https://ipvb.gitee.io/blog     root: /blog     ​</code></p>
<p>其他码云部署的问题参考<a href="https://gitee.com/help/articles/4136#article-header3">这里</a></p>
<h2 id="hexo-ru-he-suo-fang-tu-pian"><a href="#hexo如何缩放图片" class="headerlink" title="hexo如何缩放图片"></a>hexo如何缩放图片<a href="#hexo-ru-he-suo-fang-tu-pian" class="header-anchor">#</a></h2><p><code>&lt;img src=&quot;&quot; width=&quot;50%&quot; height=&quot;50%&quot;&gt;</code></p>
<h2 id="hexo-ru-he-an-zhuang-zhu-ti"><a href="#hexo如何安装主题" class="headerlink" title="hexo如何安装主题"></a>hexo如何安装主题<a href="#hexo-ru-he-an-zhuang-zhu-ti" class="header-anchor">#</a></h2><ol>
<li><p>找到合适的主题列表，推荐以下2个：</p>
<p><a href="https://www.zhihu.com/question/24422335">有哪些好看的 Hexo 主题？</a></p>
<p><a href="https://hexo.io/themes/">hexo.thems</a></p>
</li>
<li><p>安装主题至根目录，例如找到next主题，将其克隆岛根目录/thesms/next下</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">git clone https:<span class="comment">//github.com/iissnan/hexo-theme-next themes/next</span></span><br></pre></td></tr></table></figure></li>
<li><p>阅读<a href="https://github.com/iissnan/hexo-theme-next">next文档</a></p>
<ol>
<li>引用主题：在config.yml中修改主题名称：<code>theme: next</code></li>
<li>发布时遇到 bug<code>&#123;% extends '_layout.swig' %&#125;</code>；输入指令解决：<code>npm i hexo-renderer-swig</code></li>
</ol>
</li>
</ol>
<h2 id="hexo-bu-xian-shi-er-ji-mu-lu"><a href="#hexo不显示二级目录？" class="headerlink" title="hexo不显示二级目录？"></a>hexo不显示二级目录？<a href="#hexo-bu-xian-shi-er-ji-mu-lu" class="header-anchor">#</a></h2><p>原因：hexo解析目录是按照1级，1级下面找2级，2级下面找3级的顺序查找目录的，如果只有2级，没有1级，是会显示错误的。</p>
<p>解决：先写1级标题，再写2级标题，先写大标题，再写小标题。</p>
<p>原因：markdown解析问题</p>
<p>解决：参考<a href="https://www.cnblogs.com/Createsequence/p/14150758.html">渲染错误解决和超链接乱码解决方案</a>、参考<a href="https://convivae.top/posts/hexo-bo-ke-cai-keng/#%E6%96%B9%E6%B3%95-2">markdown-it的bug</a></p>
<h2 id="hexo-dian-ji-er-ji-mu-lu-bu-tiao-zhuan"><a href="#hexo点击二级目录不跳转" class="headerlink" title="hexo点击二级目录不跳转?"></a>hexo点击二级目录不跳转?<a href="#hexo-dian-ji-er-ji-mu-lu-bu-tiao-zhuan" class="header-anchor">#</a></h2><p>原因：markdown解析问题</p>
<p>解决：参考<a href="https://www.cnblogs.com/Createsequence/p/14150758.html">渲染错误解决和超链接乱码解决方案</a>、参考<a href="https://convivae.top/posts/hexo-bo-ke-cai-keng/#%E6%96%B9%E6%B3%95-2">markdown-it的bug</a></p>
<h2 id="hexo-zi-dong-fa-bu-tu-pian-zhi-qi-niu-yun"><a href="#hexo自动发布图片至七牛云？" class="headerlink" title="hexo自动发布图片至七牛云？"></a>hexo自动发布图片至七牛云？<a href="#hexo-zi-dong-fa-bu-tu-pian-zhi-qi-niu-yun" class="header-anchor">#</a></h2><p>阿里云-域名管理-解析设置-添加记录-设置以下参数</p>
<table>
<thead>
<tr>
<th>键</th>
<th>值</th>
</tr>
</thead>
<tbody><tr>
<td>记录类型</td>
<td>CNAME</td>
</tr>
<tr>
<td>主机记录</td>
<td>如cdn</td>
</tr>
<tr>
<td>记录值</td>
<td>从七牛云后台获取</td>
</tr>
</tbody></table>
<p>七牛云-域名管理-加速域名设置值如cdn.yangchaofan.cn；cdn就是主机记录值；创建完毕后，获得一个CNAME值，记住该值，填写至阿里云域名记录值中。</p>
<p><a href="https://portal.qiniu.com/kodo/overview"></a></p>
<h2 id="next-ru-he-da-kai-bai-du-fen-xiang"><a href="#next如何打开百度分享？" class="headerlink" title="next如何打开百度分享？"></a>next如何打开百度分享？<a href="#next-ru-he-da-kai-bai-du-fen-xiang" class="header-anchor">#</a></h2><p>主题文件中插入以下代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">baidushare:</span><br><span class="line">  type: button</span><br><span class="line">  baidushare: <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h2 id="next-ru-he-tian-jia-sou-suo-gong-neng"><a href="#next如何添加搜索功能？" class="headerlink" title="next如何添加搜索功能？"></a>next如何添加搜索功能？<a href="#next-ru-he-tian-jia-sou-suo-gong-neng" class="header-anchor">#</a></h2><p>安装插件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>
<p>编辑全局配置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: <span class="number">10000</span></span><br></pre></td></tr></table></figure>
<p>编辑主题配置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">local_search:</span><br><span class="line">  enable: <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h2 id="next-ru-he-tian-jia-ping-lun-gong-neng"><a href="#next如何添加评论功能？" class="headerlink" title="next如何添加评论功能？"></a>next如何添加评论功能？<a href="#next-ru-he-tian-jia-ping-lun-gong-neng" class="header-anchor">#</a></h2><p>翻墙打开<a href="https://livere.com/">来比力官网</a>，注册填写域名，copy代码块中的data-uid</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- 来必力City版安装代码 --&gt;</span><br><span class="line">&lt;div id=<span class="string">&quot;lv-container&quot;</span> data-id=<span class="string">&quot;city&quot;</span> data-uid=<span class="string">&quot;这里是id&quot;</span>&gt;</span><br><span class="line">	&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">   (<span class="function"><span class="keyword">function</span>(<span class="params">d, s</span>) </span>&#123;</span><br><span class="line">       <span class="keyword">var</span> j, e = d.getElementsByTagName(s)[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">typeof</span> LivereTower === <span class="string">&#x27;function&#x27;</span>) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line"></span><br><span class="line">       j = d.createElement(s);</span><br><span class="line">       j.src = <span class="string">&#x27;https://cdn-city.livere.com/js/embed.dist.js&#x27;</span>;</span><br><span class="line">       j.async = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">       e.parentNode.insertBefore(j, e);</span><br><span class="line">   &#125;)(<span class="built_in">document</span>, <span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">	&lt;/script&gt;</span><br><span class="line">&lt;noscript&gt; 为正常使用来必力评论功能请激活JavaScript&lt;/noscript&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;!-- City版安装代码已完成 --&gt;</span><br></pre></td></tr></table></figure>
<p>配置完成后可以在评论<a href="https://livere.com/insight/communite">后台</a>管理评论内容。</p>
<h2 id="hexo-ru-he-chuang-jian-mo-ban"><a href="#hexo如何创建模板？" class="headerlink" title="hexo如何创建模板？"></a>hexo如何创建模板？<a href="#hexo-ru-he-chuang-jian-mo-ban" class="header-anchor">#</a></h2><p><strong>模板有什么用？</strong></p>
<p>模板可以当做一类文章的格式，按照指定格式批量创建文章，减少重复内容的编写工作。如创建读书笔记模板、创建一类任务计划模板。</p>
<p><strong>创建模板步骤？</strong></p>
<ul>
<li>新建md文件，文件头插入以下内容，并将文件移动至<code>根目录/scaffolds</code> 下</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">title: 《超效学习方法解码》心得</span><br><span class="line">date: <span class="number">2021</span>-<span class="number">02</span>-<span class="number">17</span> <span class="number">11</span>:<span class="number">37</span>:<span class="number">23</span></span><br><span class="line">entitle:</span><br><span class="line">tags:</span><br><span class="line">categories:</span><br></pre></td></tr></table></figure>
<ul>
<li>使用指令读取模板创建文章</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> hexo new 模板名称 <span class="string">&quot;title&quot;</span></span></span><br><span class="line">hexo new book-note-model &quot;《超效学习方法解码》心得&quot;</span><br></pre></td></tr></table></figure>
<h2 id="hexo-ru-he-chuang-jian-cao-gao"><a href="#hexo如何创建草稿？" class="headerlink" title="hexo如何创建草稿？"></a>hexo如何创建草稿？<a href="#hexo-ru-he-chuang-jian-cao-gao" class="header-anchor">#</a></h2><p><strong>草稿的用途？</strong></p>
<p>文章写到一半，未完成，并不想发布。可以向存到指定位置。hexo提供了_drafts目录存放草稿。</p>
<p><strong>创建草稿的步骤？</strong></p>
<ul>
<li>​创建草稿</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> hexo new draft <span class="string">&quot;title&quot;</span></span></span><br><span class="line">hexo new draft &quot;Android性能优化百问百答&quot;</span><br><span class="line">INFO  Validating config</span><br><span class="line">INFO  Created: </span><br><span class="line">D:\workspace\gitblog\hexoblogcode\source\_drafts\Android性能优化百问百答.md</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>发布草稿</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> hexo publish 布局类型 <span class="string">&quot;title&quot;</span></span></span><br><span class="line">hexo publish draft &quot;Android性能优化百问百答&quot;</span><br><span class="line">INFO  Validating config</span><br><span class="line">INFO  Published: D:\workspace\gitblog\hexoblogcode\source\_posts\Android性能优化百问百答.md</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>  ​</p>
<h1 id="shi-yong-shuo-ming"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明<a href="#shi-yong-shuo-ming" class="header-anchor">#</a></h1><ol>
<li> 定时使用typora编写markdown文章：编写markdown文件</li>
<li> 导出成html，发布在hexo：使用hexo s</li>
<li> hexo推送到码云指定仓库地址：hexo d</li>
<li> 将阿里云的域名解析至码云仓库地址：配置域名解析</li>
<li> 通过公网域名访问我的网站</li>
</ol>
<h1 id="zhi-chi"><a href="#支持" class="headerlink" title="支持"></a>支持<a href="#zhi-chi" class="header-anchor">#</a></h1><ol>
<li> <a href="https://support.typora.io/Resize-Image/">typora使用手册</a></li>
<li> <a href="https://gitee.com/help">Gitee 官方提供的使用手册</a></li>
<li> <a href="https://portal.qiniu.com/kodo/overview">七牛云</a> </li>
<li> <a href="https://homenew.console.aliyun.com/home/dashboard/ProductAndService">阿里云</a> </li>
<li> <a href="https://hexo.io/zh-cn/docs">hexo中文文档</a></li>
<li> <a href="http://theme-next.iissnan.com/third-party-services.html#comment-system">next中文文档</a></li>
<li> <a href="https://console.leancloud.cn/apps">leanclound统计云</a></li>
<li> <a href="https://livere.com/insight/communite">来比力评论云</a></li>
</ol>
]]></content>
      <categories>
        <category>杂谈</category>
        <category>日记</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>《超效学习方法解码》心得</title>
    <url>/ye-jincheng-website/chao-xiao-xue-xi-fang-fa-jie-ma/</url>
    <content><![CDATA[<h1 id="chao-xiao-xue-xi-fang-fa-jie-ma"><a href="#《超效学习方法解码》" class="headerlink" title="《超效学习方法解码》"></a>《超效学习方法解码》<a href="#chao-xiao-xue-xi-fang-fa-jie-ma" class="header-anchor">#</a></h1><table>
<thead>
<tr>
<th>名称</th>
<th>详情</th>
</tr>
</thead>
<tbody><tr>
<td><strong>封面</strong></td>
<td><img src="http://cdn.yangchaofan.cn/gaoxiao%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95.jpg" width="50%" height="50%"></td>
</tr>
<tr>
<td><strong>作者</strong></td>
<td>曹婷</td>
</tr>
<tr>
<td><strong>出版社</strong></td>
<td>星火教育研究院</td>
</tr>
<tr>
<td><strong>介绍</strong></td>
<td>分为学习基础篇、学习修炼篇、学习问题对症篇；学习对症篇主要解决语文、数学、英文、历史、政治的疑难杂症；学习修炼篇提供了预习、听课、复习、做题的基本思路，克服困难的方法；学习基础篇主要讲了时间管理、注意力管理、记忆力的小技巧。</td>
</tr>
</tbody></table>
<a id="more"></a>

<h1 id="ru-he-yu-xi"><a href="#如何预习" class="headerlink" title="如何预习"></a>如何预习<a href="#ru-he-yu-xi" class="header-anchor">#</a></h1><h2 id="ding-yi"><a href="#定义" class="headerlink" title="定义"></a>定义<a href="#ding-yi" class="header-anchor">#</a></h2><p>预习是学习行为的第一步，在预习之后才能展开听课行为。</p>
<h2 id="fang-fa"><a href="#方法" class="headerlink" title="方法"></a>方法<a href="#fang-fa" class="header-anchor">#</a></h2><p>阅读主题知识结构，理解知识结构</p>
<p>基本概念定理，理解内容</p>
<p>复述记忆，一页一记法复述知识</p>
<p>课后练习，理解困难，做题困难，看不懂</p>
<p>整理问题列表，用于听课过程中解答</p>
<h1 id="ru-he-ting-ke"><a href="#如何听课" class="headerlink" title="如何听课"></a>如何听课<a href="#ru-he-ting-ke" class="header-anchor">#</a></h1><h2 id="ding-yi"><a href="#定义-1" class="headerlink" title="定义"></a>定义<a href="#ding-yi" class="header-anchor">#</a></h2><p>听课行为发生于预习行为之后，听课是一种吸收知识的行为，具体行为表现为听音频、看视频、阅读教材讲义等文字内容、动手实践等</p>
<p>听课的动机目的是</p>
<ul>
<li>解决预习过程中遇到的问题，</li>
<li>完善预习后建立的知识体系，</li>
<li>利用听课时间背诵重点知识，</li>
<li>有选择的跳过非核心知识背诵。</li>
</ul>
<h2 id="fang-fa"><a href="#方法-1" class="headerlink" title="方法"></a>方法<a href="#fang-fa" class="header-anchor">#</a></h2><p><strong>解答问题列表：</strong>使用预习后准备的提问列表，在听课中解决提问</p>
<p><strong>背诵时机选择：</strong>已经听懂的知识，但没记住；此时在讲不重要的知识，则可以背诵前面重要的知识</p>
<p>预习过后已经看懂的主题，听课中可以集中精力背诵该主题，减少听的时间</p>
<p>听课中，抽出精力背诵重点精华内容，老师重复讲的，章节段落核心，讲解思路，老师对知识点联系的描述，重点，难点，画外音，<strong>以及课本上没有的内容</strong></p>
<p><strong>符号笔记：</strong>听课中，老师提到的内容，<strong>如果在课本已有</strong>，用符号标记如波浪线、三角号、着重号标记；<strong>如果课本没有</strong>，则记住关键字，课后提问、搜索引擎。</p>
<h1 id="ru-he-xue-shu-xue"><a href="#如何学数学" class="headerlink" title="如何学数学"></a>如何学数学<a href="#ru-he-xue-shu-xue" class="header-anchor">#</a></h1><h2 id="ding-yi"><a href="#定义-2" class="headerlink" title="定义"></a>定义<a href="#ding-yi" class="header-anchor">#</a></h2><p>数学是一门抽象思维学科，有着独特的描述语言和符号</p>
<h2 id="fang-fa"><a href="#方法-2" class="headerlink" title="方法"></a>方法<a href="#fang-fa" class="header-anchor">#</a></h2><h2 id="ru-he-zuo-li-ti"><a href="#如何做例题" class="headerlink" title="如何做例题"></a>如何做例题<a href="#ru-he-zuo-li-ti" class="header-anchor">#</a></h2><h3 id="ding-yi"><a href="#定义-3" class="headerlink" title="定义"></a>定义<a href="#ding-yi" class="header-anchor">#</a></h3><p>例题是基础题，一般为简单题，主要用于表现定理、公式的基本特征，可用于训练解题步骤</p>
<h3 id="fang-fa"><a href="#方法-3" class="headerlink" title="方法"></a>方法<a href="#fang-fa" class="header-anchor">#</a></h3><p>将例题当做训练解题步骤的母题</p>
<h3 id="jie-ti-bu-zou"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤<a href="#jie-ti-bu-zou" class="header-anchor">#</a></h3><h4 id="shen-ti"><a href="#审题" class="headerlink" title="审题"></a>审题<a href="#shen-ti" class="header-anchor">#</a></h4><p>了解题意</p>
<p>获取题目直接条件：概念常用的性质、特定条件、函数的定义域、值域、方程变量的取值范围、图形的取值范围</p>
<p>分析题目隐含条件</p>
<p>明确题目考察要求</p>
<p>找寻数学基本工具，概念、公式、定理</p>
<h4 id="qiu-jie"><a href="#求解" class="headerlink" title="求解"></a>求解<a href="#qiu-jie" class="header-anchor">#</a></h4><p><strong>联想条件的直接结论</strong>，可根据直接条件联想条件可得出的结论；根据结论再联想它对应的结论；可重复联系对应结论；</p>
<p><strong>溯源结论推导过程</strong>，条件-推导过程-结论-结论推出的结论-结论的结论推导出的结论，有时考察的并非条件、结论，考察的是推导过程，所以要溯源推导过程，过程中的变量、不变量是解题的关键</p>
<h4 id="zong-jie"><a href="#总结" class="headerlink" title="总结"></a>总结<a href="#zong-jie" class="header-anchor">#</a></h4><p>题目条件的总结：直接条件的获取方式、间接条件的推导过程，思考去掉条件，会引起什么变化；思考逆向推导的能力，即由结论找寻条件的过程；总结题目的描述规律、考察规律、解题步骤、题型划分等</p>
<h2 id="ru-he-jian-yan-da-an"><a href="#如何检验答案" class="headerlink" title="如何检验答案"></a>如何检验答案<a href="#ru-he-jian-yan-da-an" class="header-anchor">#</a></h2><h3 id="ding-yi"><a href="#定义-4" class="headerlink" title="定义"></a>定义<a href="#ding-yi" class="header-anchor">#</a></h3><p>检验答案正确性，是做题的关键步骤，必要时会导致答案的修改</p>
<h3 id="fang-fa"><a href="#方法-4" class="headerlink" title="方法"></a>方法<a href="#fang-fa" class="header-anchor">#</a></h3><h4 id="fang-fa-1-ji-ben-gai-nian-jian-yan-fa"><a href="#方法1基本概念检验法" class="headerlink" title="方法1基本概念检验法"></a>方法1基本概念检验法<a href="#fang-fa-1-ji-ben-gai-nian-jian-yan-fa" class="header-anchor">#</a></h4><p>概念性错误是最容易忽视的，基本概念、法则、公式的适用条件是否满足，是否位于边界情况，都是要严格检查的。</p>
<h4 id="fang-fa-2-dui-cheng-yuan-li-jian-yan-fa"><a href="#方法2对称原理检验法" class="headerlink" title="方法2对称原理检验法"></a>方法2对称原理检验法<a href="#fang-fa-2-dui-cheng-yuan-li-jian-yan-fa" class="header-anchor">#</a></h4><p>对称的公式、定理，势必导致结论的对称，利用对称原理可以快速检验反比例函数和二次函数的答案</p>
<h4 id="fang-fa-3-te-shu-qing-xing-jian-yan-fa"><a href="#方法3特殊情形检验法" class="headerlink" title="方法3特殊情形检验法"></a>方法3特殊情形检验法<a href="#fang-fa-3-te-shu-qing-xing-jian-yan-fa" class="header-anchor">#</a></h4><p>特殊值、特例、极端情况是检验答案的快捷方法</p>
<h4 id="fang-fa-4-bu-bian-liang-jian-yan-fa"><a href="#方法4不变量检验法" class="headerlink" title="方法4不变量检验法"></a>方法4不变量检验法<a href="#fang-fa-4-bu-bian-liang-jian-yan-fa" class="header-anchor">#</a></h4><p>某一类数学问题在变化、变形过程中，有的量保持不变，不变的量可以验证答案的正确性。</p>
<p>如图形旋转、平移、翻转时，图形面积、体积不变。</p>
<h4 id="fang-fa-5-deng-jie-guan-xi-jian-yan-fa"><a href="#方法5等价关系检验法" class="headerlink" title="方法5等价关系检验法"></a>方法5等价关系检验法<a href="#fang-fa-5-deng-jie-guan-xi-jian-yan-fa" class="header-anchor">#</a></h4><p>等价替换答案，检验正确性</p>
<h4 id="fang-fa-6-luo-ji-tui-li-jian-yan-fa"><a href="#方法6逻辑推理检验法" class="headerlink" title="方法6逻辑推理检验法"></a>方法6逻辑推理检验法<a href="#fang-fa-6-luo-ji-tui-li-jian-yan-fa" class="header-anchor">#</a></h4><h4 id="fang-fa-7-zheng-ti-jian-yan-fa"><a href="#方法7整体检验法" class="headerlink" title="方法7整体检验法"></a>方法7整体检验法<a href="#fang-fa-7-zheng-ti-jian-yan-fa" class="header-anchor">#</a></h4><h4 id="fang-fa-8-shu-xue-jie-he-jian-yan-fa"><a href="#方法8数学结合检验法" class="headerlink" title="方法8数学结合检验法"></a>方法8数学结合检验法<a href="#fang-fa-8-shu-xue-jie-he-jian-yan-fa" class="header-anchor">#</a></h4><h4 id="fang-fa-9-yi-ti-duo-jie-jian-yan-fa"><a href="#方法9一题多解检验法" class="headerlink" title="方法9一题多解检验法"></a>方法9一题多解检验法<a href="#fang-fa-9-yi-ti-duo-jie-jian-yan-fa" class="header-anchor">#</a></h4><h4 id="fan-fu-10-cao-gao-yun-suan-bu-zou-he-cha-fa"><a href="#反复10草稿运算步骤核查法" class="headerlink" title="反复10草稿运算步骤核查法"></a>反复10草稿运算步骤核查法<a href="#fan-fu-10-cao-gao-yun-suan-bu-zou-he-cha-fa" class="header-anchor">#</a></h4><h2 id="xie-shu-xue-ri-ji"><a href="#写数学日记" class="headerlink" title="写数学日记"></a>写数学日记<a href="#xie-shu-xue-ri-ji" class="header-anchor">#</a></h2><h3 id="ri-ji-nei-rong"><a href="#日记内容" class="headerlink" title="日记内容"></a>日记内容<a href="#ri-ji-nei-rong" class="header-anchor">#</a></h3><p>事件日记：学习中自己感兴趣的活动、故事、事件、主题知识，受到了什么启发，得到了哪些锻炼，自己有什么感受</p>
<p>引导日记：课堂中老师的引导过程、例题推导过程，自己内心有什么感受</p>
<p>练习日记：习题、考试后的心得，哪些做得好，哪些做得不好，改正的步骤，自己五官有什么感受</p>
<h3 id="ri-ji-yao-qiu"><a href="#日记要求" class="headerlink" title="日记要求"></a>日记要求<a href="#ri-ji-yao-qiu" class="header-anchor">#</a></h3><p>简练的描述自己的感受</p>
<p>简练的描述主题知识和内容，详细的部分放在笔记里</p>
<p>将感受和主题知识联系起来</p>
<h1 id="ru-he-xue-zheng-zhi"><a href="#如何学政治" class="headerlink" title="如何学政治"></a>如何学政治<a href="#ru-he-xue-zheng-zhi" class="header-anchor">#</a></h1><p>##定义</p>
<p>描述了学习政治学科的方法</p>
<h2 id="fang-fa"><a href="#方法-5" class="headerlink" title="方法"></a>方法<a href="#fang-fa" class="header-anchor">#</a></h2><p><strong>画知识体系图：</strong>以单元标题-章节标题-框标题-小标题-自然段为<strong>主</strong>题，画思维导图，建立每个知识点的联系。</p>
<p>谁是知识体系的基础：自然段是知识体系的基础，只有理解自然段才能建立<strong>主题知识体系</strong>。</p>
<p><strong>能够提问，层层发问：</strong>政治内容，每句话都有前因后果。每个自然段，不断问“是什么”，“为什么”，“怎么办”。</p>
<p>层层发文的目的：让一个段落诞生几句话，一个段落扩展成几个段落，最终建立主题之间的联系，形成知识体系。</p>
<p><strong>无法发问，使用推理：</strong>无法通过提问找寻主题关系的，只能通过归纳、演绎，抽象得推导出主题之间的关系。</p>
<p><strong>带着提问，问题列表</strong>：手写提问列表，加深阅读的印象，减少阅读的思考负担。</p>
<p>##知识体系</p>
<p>主题-提问-推理-主题建立联系-根据联系绘制思维导图</p>
<p>##配图</p>
<p>暂无：流程图、概念图、思维导图、学科专业配图等</p>
<h1 id="ru-he-zuo-ti"><a href="#如何做题" class="headerlink" title="如何做题"></a>如何做题<a href="#ru-he-zuo-ti" class="header-anchor">#</a></h1><h2 id="ding-yi"><a href="#定义-5" class="headerlink" title="定义"></a>定义<a href="#ding-yi" class="header-anchor">#</a></h2><p>描述了做题的基本流程，前后步骤。</p>
<h2 id="fang-fa"><a href="#方法-6" class="headerlink" title="方法"></a>方法<a href="#fang-fa" class="header-anchor">#</a></h2><p><strong>范围选择：</strong>课后题、例题、错题、考试真题</p>
<p><strong>先后顺序：</strong>书中主题内容看懂，再做题。</p>
<p><strong>时间原则：</strong>做题时要限时，题目时间分配合理，阻塞的题目立刻跳过</p>
<p>**开始原则:**做题任务计时开始，就立刻做，不拖延</p>
<p><strong>收尾原则：</strong>题目做完后，只有反思总结，才能得到收益</p>
<ul>
<li>反思错误：错误原因、没有思路原因、做不出来原因</li>
<li>反思题意：条件、问题、结论，三者联系</li>
<li>反思方法：将题目解题思路融入解题的积累中</li>
<li>反思变化：条件、问题、结论，三者变化后练习</li>
</ul>
<h1 id="ru-he-ti-gao-jie-ti-su-du"><a href="#如何提高解题速度？" class="headerlink" title="如何提高解题速度？"></a>如何提高解题速度？<a href="#ru-he-ti-gao-jie-ti-su-du" class="header-anchor">#</a></h1><p>只有<strong>熟悉主题</strong>（概念、定义、公式、定力），才能做好简单的题目。</p>
<p>只有<strong>做好基本题</strong>，才能做好复杂题。</p>
<p>只有<strong>熟悉主题之间的联系</strong>，才能做好综合题。</p>
<p>只有<strong>掌握基本的解题步骤、解题方法</strong>，才能做好对应的题型。</p>
<p>只有<strong>事后做好归纳总结</strong>（题型归类、基本步骤、解题方法、隐含条件、隐含结论），才能积累考题题型，做到不重不漏。</p>
<p>只有<strong>学会数学工具（画图等10几个数学工具）</strong>，才能翻译出题目的考点。</p>
<p>只有<strong>记住上述内容</strong>，才能提高解题速度。</p>
<h1 id="zong-jie"><a href="#总结-1" class="headerlink" title="总结"></a>总结<a href="#zong-jie" class="header-anchor">#</a></h1><p>本书读完，最大的收获是预习、听课、学政治、学数学、如何做题五个方面。</p>
<p>听课给我的启发是：在预习的基础上，对课堂所讲知识结构心中有数，能轻易的跟上、超过老师的讲课节奏，在充分预习的基础上，可以利用课堂时间背诵重点、难点、核心点，利用听课时间、老师的思路引导知识记忆，可以充分提高学习效率。</p>
<p>尤其是学数学，提倡的<label style="color:green"><strong>数学日记</strong></label>让我很意外，也很开心，事事都可以写日记，日记不同于笔记，更加自由，口语化，能更融入个人的情感，激发具象思维，提升学习兴趣。利于孩童学习，也利于成人读书。</p>
<p>学习数学一节，如何做题的思路也启发了我，提醒我做题应当分为审题、解题、总结三步骤。审题和总结是大多数容易忽视的，不可轻敌，解题中的两个方法联想隐藏条件法和溯源推导过程找间接条件法对我也启发很大，提示我们做题要正向条件-结论思考，也要反向结论-推导过程-条件思考，有时隐藏条件就在推导过程中，而非题目本身给出的直接条件。</p>
]]></content>
      <categories>
        <category>-[家庭教育,学习方法]</category>
      </categories>
      <tags>
        <tag>-[学习方法]</tag>
      </tags>
  </entry>
  <entry>
    <title>AndroidHandler百问百答</title>
    <url>/ye-jincheng-website/handler%20TOP%20100%20Questions/</url>
    <content><![CDATA[<h1 id="android-bai-wen-bai-da-na-xie-nian-bei-wen-guo-de-handler-yuan-li"><a href="#Android百问百答-《那些年被问过的Handler原理》" class="headerlink" title="Android百问百答-《那些年被问过的Handler原理》"></a>Android百问百答-《那些年被问过的Handler原理》<a href="#android-bai-wen-bai-da-na-xie-nian-bei-wen-guo-de-handler-yuan-li" class="header-anchor">#</a></h1><p>文章迁移自<a href="https://blog.csdn.net/chivalrousman/article/details/108014580">我的csdn博客</a></p>
<p>关于Handler，安卓面试最热门的知识点之一。本篇文章将围绕3点展开：</p>
<p>可以提问哪些Questions？</p>
<p>面试官会怎样follow up？</p>
<p>以及怎样寻找答案。</p>
<h2 id="handler-chang-jian-ti-wen"><a href="#Handler常见提问" class="headerlink" title="Handler常见提问"></a>Handler常见提问<a href="#handler-chang-jian-ti-wen" class="header-anchor">#</a></h2><ol>
<li>哪些场景使用到了Handler？用Handler做什么业务？</li>
<li>用Handler遇到什么问题？怎么解决这些问题的？</li>
<li>说一说Handler原理？</li>
<li>能自己实现一个Handler吗？</li>
<li>说一说Handler延时原理？</li>
<li>Handler延时有哪些缺陷？造成这些缺陷的原因？</li>
<li>你知道Handler#handleMessage原理吗？</li>
<li>Handler的post与sendMessage有哪些区别？</li>
<li>子线程能使用Handler吗？</li>
<li>子线程能创建Handler吗？</li>
<li>了解过HandlerThread吗？</li>
<li>了解过IdleHandler吗？</li>
</ol>
<h2 id="handler-chang-jian-follow-up"><a href="#Handler常见Follow-Up" class="headerlink" title="Handler常见Follow Up"></a>Handler常见Follow Up<a href="#handler-chang-jian-follow-up" class="header-anchor">#</a></h2><ol>
<li>你刚才提到了Message，消息屏障听过吗？有几种Message？</li>
<li>Message有什么用？存储了哪些信息？以什么数据结构存储？</li>
<li>APP内最多能有几个Handler？</li>
<li>App内最多能有多少Message？</li>
<li>App内最多能有几个Looper？</li>
<li>App内最多能有几个MessageQueue？</li>
<li>Message如何知道发给哪一个MessageQueue？发给哪个Handler？</li>
<li>MessageQueue如何存储消息，以什么结构存储？</li>
<li>你提到了Looper，请问子线程如何获取Looper？</li>
<li>你提到了Looper，说一说Looper的消息队列模型？</li>
<li>主线程Looper为什么不会阻塞？为什么不会ANR？</li>
<li>子线程跟主线程如何通过Handler通信？</li>
<li>子线程创建Handler这么麻烦，有什么替代方法吗？</li>
<li>主线程Looper什么时候启动的？</li>
<li>对Handler做过哪些优化？</li>
</ol>
<h2 id="handler-yuan-ma-fen-xi"><a href="#Handler源码分析" class="headerlink" title="Handler源码分析"></a>Handler源码分析<a href="#handler-yuan-ma-fen-xi" class="header-anchor">#</a></h2><h3 id="handler-gou-zao-han-shu-yuan-li"><a href="#Handler-构造函数原理" class="headerlink" title="Handler#构造函数原理"></a>Handler#构造函数原理<a href="#handler-gou-zao-han-shu-yuan-li" class="header-anchor">#</a></h3><p>Handler有7个构造函数</p>
<pre><code>Handler()
Handler(Handler.Callback callback)
Handler(Looper looper)
Handler(Looper looper, Handler.Callback callback)
Handler(boolean async)
Handler(Callback callback, boolean async)
Handler(Looper looper, Callback callback, boolean async)
</code></pre>
<p>先从其中一个构造函数看起：<br><img src="https://img-blog.csdnimg.cn/20200814220917812.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoaXZhbHJvdXNtYW4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>提到了MessageQueue、Looper，Message,CallBack暂且记下。</p>
<p>我们根据经验及面试题，关注Handler几个关键API</p>
<ul>
<li>obtainMessage</li>
<li>post</li>
<li>sendMessage</li>
<li>postDelayed</li>
<li>sendMessageDelayed</li>
</ul>
<p>接着我们关注这些API的底层实现，一个一个分析吧！</p>
<h3 id="handler-obtainmessage-yuan-li"><a href="#Handler-obtainMessage-原理" class="headerlink" title="Handler#obtainMessage 原理"></a>Handler#obtainMessage 原理<a href="#handler-obtainmessage-yuan-li" class="header-anchor">#</a></h3><p>Handler#obtainMessage 调用了Message#obtain()</p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-T7alw6p4-1597413794308)(C:\Users\lenovo\AppData\Local\Temp\1597329263919.png)]</p>
<p>可以看到obtain函数从Message链表中获取message，这是一种内存复用，节省了频繁创建内存，如果Message链表为空，则创建一个Message。如果你对Message是个链表有疑问，那么请继续看下面的内容吧！</p>
<h3 id="message-yuan-ma-fen-xi"><a href="#Message源码分析" class="headerlink" title="Message源码分析"></a>Message源码分析<a href="#message-yuan-ma-fen-xi" class="header-anchor">#</a></h3><p>Message有如下公有属性，供程序员调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> what;<span class="comment">//消息标示，</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> arg1; <span class="comment">//简单int类型数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> arg2;<span class="comment">//简单int类型数据</span></span><br><span class="line"><span class="keyword">public</span> Object obj;<span class="comment">//简单Object类型数据</span></span><br><span class="line"><span class="keyword">public</span> Messenger replyTo;<span class="comment">//跨进程信使</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> sendingUid = -<span class="number">1</span>;<span class="comment">//Messenger消息标示</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>Message有如下私有属性,用途如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*package*/</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLAG_IN_USE = <span class="number">1</span> &lt;&lt; <span class="number">0</span>;<span class="comment">//正在使用中</span></span><br><span class="line"><span class="comment">/*package*/</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLAG_ASYNCHRONOUS = <span class="number">1</span> &lt;&lt; <span class="number">1</span>;<span class="comment">//消息同步标识</span></span><br><span class="line"><span class="comment">/*package*/</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLAGS_TO_CLEAR_ON_COPY_FROM = FLAG_IN_USE;<span class="comment">//</span></span><br><span class="line"><span class="comment">/*package*/</span> <span class="keyword">int</span> flags;<span class="comment">//消息执行标识</span></span><br><span class="line"><span class="comment">/*package*/</span> <span class="keyword">long</span> when;<span class="comment">//执行时间</span></span><br><span class="line"><span class="comment">/*package*/</span> Bundle data;<span class="comment">//装载的数据</span></span><br><span class="line"><span class="comment">/*package*/</span> Handler target;<span class="comment">//目标载体</span></span><br><span class="line"><span class="comment">/*package*/</span> Runnable callback;<span class="comment">//任务线程</span></span><br><span class="line"><span class="comment">/*package*/</span> Message next;<span class="comment">//消息链表，下一个消息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object sPoolSync = <span class="keyword">new</span> Object();<span class="comment">//锁对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Message sPool;<span class="comment">//消息池</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> sPoolSize = <span class="number">0</span>;<span class="comment">//消息池大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_POOL_SIZE = <span class="number">50</span>;<span class="comment">//消息池最大消息数常量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> gCheckRecycle = <span class="keyword">true</span>;<span class="comment">//循环检查</span></span><br></pre></td></tr></table></figure>
<p>Message的源码，我们可以得出如下结论，Message是一种链表结构，每个Message持有以下信息：</p>
<ol>
<li>用于传递的数据，如what、arg1、arg2、obj</li>
<li>用于执行当前Message的Handler</li>
<li>用于执行当前Message的回调接口CallBack、子线程Runnable</li>
<li>当前Message的属性，如延时时间、执行标识、Bundle数据，下一个Message引用。这种结构构成了链表。</li>
</ol>
<h3 id="handler-post-de-yuan-li"><a href="#Handler-post的原理" class="headerlink" title="Handler#post的原理"></a>Handler#post的原理<a href="#handler-post-de-yuan-li" class="header-anchor">#</a></h3><p>post函数入口接收一个子线程Runnable对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span>  sendMessageDelayed(getPostMessage(r), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getPostMessage()做了如下工作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Message <span class="title">getPostMessage</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">    Message m = Message.obtain();</span><br><span class="line">    m.callback = r;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sendMessageDelayed做了如下工作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageDelayed</span><span class="params">(Message msg, <span class="keyword">long</span> delayMillis)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        delayMillis = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sendMessageAtTime做了如下工作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">    MessageQueue queue = mQueue;</span><br><span class="line">    <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        RuntimeException e = <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="keyword">this</span> + <span class="string">&quot; sendMessageAtTime() called with no mQueue&quot;</span>);</span><br><span class="line">        Log.w(<span class="string">&quot;Looper&quot;</span>, e.getMessage(), e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终走下了MessageQueue#enqueueMessage</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">    msg.target = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">        msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一步总结如下</p>
<ol>
<li>getPostMessage将Message与Handler绑定</li>
<li>通过SystemClock.uptimeMillis() + delayMillis计算延时时间，delayMillis默认为0</li>
<li>将Message与计算得出的时间值，传递给MessageQueue#enqueueMessage，交由MessageQueue处理Message。</li>
</ol>
<h3 id="handler-sendmessage-yuan-li"><a href="#Handler-sendMessage原理" class="headerlink" title="Handler#sendMessage原理"></a>Handler#sendMessage原理<a href="#handler-sendmessage-yuan-li" class="header-anchor">#</a></h3><p>入口接收Message对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessage</span><span class="params">(Message msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sendMessageDelayed(msg, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后续执行过程与post相同，最终都将Message交由MessageQueue#enqueueMessage处理。</p>
<h3 id="handler-postdelayed-yuan-li"><a href="#Handler-postDelayed原理" class="headerlink" title="Handler#postDelayed原理"></a>Handler#postDelayed原理<a href="#handler-postdelayed-yuan-li" class="header-anchor">#</a></h3><p>与post相比，postDelayed函数入口除了接收Runnable子线程对象，还接收一个时间戳，用于延时时间的计算。其他过程与post相同。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">postDelayed</span><span class="params">(Runnable r, <span class="keyword">long</span> delayMillis)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sendMessageDelayed(getPostMessage(r), delayMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="handler-sendmessagedelayed-yuan-li"><a href="#Handler-sendMessageDelayed原理" class="headerlink" title="Handler#sendMessageDelayed原理"></a>Handler#sendMessageDelayed原理<a href="#handler-sendmessagedelayed-yuan-li" class="header-anchor">#</a></h3><p>与sendMessage类似，多了一个时间戳，用于计算延时时间。其他过程与sendMessage、相同。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageDelayed</span><span class="params">(Message msg, <span class="keyword">long</span> delayMillis)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        delayMillis = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看完源码，我们得出几个结论：</p>
<ol>
<li>无论是Handler#post或者是Handler#sendMessage，Messag都会交由MessageQueue#enqueueMessage执行</li>
<li>MessageQueue#enqueueMessage接收两个参数Message和long型的时间戳</li>
<li>时间戳计算方式是SystemClock.uptimeMillis() + delayMillis</li>
<li>post与sendMessage的区别是入参参数不一样，post接收Runnable子线程，将子线程绑定到Message上；sendMessage持有的是主线程</li>
</ol>
<p>那么我们心中很自然会产生疑问，MessageQueue#enqueueMessage是如何执行的？</p>
<h2 id="messagequeue-yuan-ma-fen-xi"><a href="#MessageQueue源码分析" class="headerlink" title="MessageQueue源码分析"></a>MessageQueue源码分析<a href="#messagequeue-yuan-ma-fen-xi" class="header-anchor">#</a></h2><p>源码分析的思路是构造函数和enqueueMessage</p>
<h3 id="messagequeue-gou-zao-han-shu-yuan-li"><a href="#MessageQueue-构造函数原理" class="headerlink" title="MessageQueue#构造函数原理"></a>MessageQueue#构造函数原理<a href="#messagequeue-gou-zao-han-shu-yuan-li" class="header-anchor">#</a></h3><p>首先来看看构造函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MessageQueue(<span class="keyword">boolean</span> quitAllowed) &#123;</span><br><span class="line">    mQuitAllowed = quitAllowed;</span><br><span class="line">    mPtr = nativeInit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造函数之上定义了很多native方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">nativeInit</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeDestroy</span><span class="params">(<span class="keyword">long</span> ptr)</span></span>;<span class="comment">// 阻塞</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeWake</span><span class="params">(<span class="keyword">long</span> ptr)</span></span>; <span class="comment">// 唤醒</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">nativeIsPolling</span><span class="params">(<span class="keyword">long</span> ptr)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeSetFileDescriptorEvents</span><span class="params">(<span class="keyword">long</span> ptr, <span class="keyword">int</span> fd, <span class="keyword">int</span> events)</span></span>;</span><br></pre></td></tr></table></figure>
<p>native之上定义了几类数据结构，Message、ArrayList、SparseArray、数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Message mMessages; <span class="comment">// 头结点</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;IdleHandler&gt; mIdleHandlers = <span class="keyword">new</span> ArrayList&lt;IdleHandler&gt;();</span><br><span class="line">   <span class="keyword">private</span> SparseArray&lt;FileDescriptorRecord&gt; mFileDescriptorRecords;</span><br><span class="line">   <span class="keyword">private</span> IdleHandler[] mPendingIdleHandlers;</span><br></pre></td></tr></table></figure>
<p>接着我们来看看enqueueMessage是如何处理Message的吧</p>
<h3 id="messagequeue-enqueuemessage-yuan-li"><a href="#MessageQueue-enqueueMessage原理" class="headerlink" title="MessageQueue#enqueueMessage原理"></a>MessageQueue#enqueueMessage原理<a href="#messagequeue-enqueuemessage-yuan-li" class="header-anchor">#</a></h3><p><img src="https://img-blog.csdnimg.cn/20200814221037199.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoaXZhbHJvdXNtYW4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li>图中 1处会判断如果 Message 中的 target 没有被设置，则直接抛出异常；</li>
<li>图中2和 3 处会按照 Message 的时间 when 来有序得插入 MessageQueue 中，可以看出 MessageQueue 实际上是一个链表维护的有序队列，只不过是按照 Message 的执行时间来排序。</li>
</ul>
<p>看到这里，思路似乎终止了，我们跟随Handler、MessQueue的脚步，只看到了Message被插入到MessageQueue的私有队列中。那我们产生的Message什么时候会背消费呢？</p>
<p>视角再次回到一开始的地方——Handler的构造函数原理，在那一节我们提到了Handler构造函数初始化Looper.myLooper()，mLooper.mQueue，接下来我们看看Looper吧！</p>
<h2 id="looper-yuan-ma-fen-xi"><a href="#Looper源码分析" class="headerlink" title="Looper源码分析"></a>Looper源码分析<a href="#looper-yuan-ma-fen-xi" class="header-anchor">#</a></h2><p>查看源码可知，Looper是final类型的，禁止被外部继承修改。</p>
<h3 id="looper-zi-xian-cheng-yong-li"><a href="#Looper-子线程用例" class="headerlink" title="Looper#子线程用例"></a>Looper#子线程用例<a href="#looper-zi-xian-cheng-yong-li" class="header-anchor">#</a></h3><p>首先在Looper类的注释上，我们看到了如下信息，提示我们在子线程中用个Looper.prepare()+Looper.looper()的方式使用Handler<br><img src="https://img-blog.csdnimg.cn/2020081422110294.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoaXZhbHJvdXNtYW4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>为什么需要用这种方式开启Looper呢？</p>
<p>答案是在任何线程要开启Loop，都要用Looper.prepare()+Looper.looper()的方式。以APP主进程为例，APP进程启动入口的main方法，也是通过这种方式开启loop的。与子线程细微不同的是，主线程开启looper用的是prepareMainLooper。</p>
<p><strong>ActivityThread #main方法</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200814221126574.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoaXZhbHJvdXNtYW4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>带着以下疑问，我们去追看源码：Looper构造函数做了什么？prepare做了什么？loop做了什么？</p>
<h3 id="looper-gou-zao-han-shu-yuan-li"><a href="#Looper-构造函数原理" class="headerlink" title="Looper#构造函数原理"></a>Looper#构造函数原理<a href="#looper-gou-zao-han-shu-yuan-li" class="header-anchor">#</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);</span><br><span class="line">    mThread = Thread.currentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Looper构造函数做了两件事情，初始化消息队列MessageQueue对象，记录当前线程信息。</p>
<h3 id="looper-mylooper-yuan-li"><a href="#Looper-myLooper-原理" class="headerlink" title="Looper#myLooper()原理"></a>Looper#myLooper()原理<a href="#looper-mylooper-yuan-li" class="header-anchor">#</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the Looper object associated with the current thread.  Returns</span></span><br><span class="line"><span class="comment"> * null if the calling thread is not associated with a Looper.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> <span class="function">Looper <span class="title">myLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sThreadLocal.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到myLooper是从threadLocal中取出Looper对象。在Looper类中定义了如下变量sThreadLocal、mQueue、sMainLooper、mThread</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sThreadLocal.get() will return null unless you&#x27;ve called prepare().</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;Looper&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Looper sMainLooper;  <span class="comment">// guarded by Looper.class</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> MessageQueue mQueue;</span><br><span class="line"><span class="keyword">final</span> Thread mThread;</span><br></pre></td></tr></table></figure>
<h3 id="looper-prepare-yuan-li"><a href="#Looper-prepare原理" class="headerlink" title="Looper#prepare原理"></a>Looper#prepare原理<a href="#looper-prepare-yuan-li" class="header-anchor">#</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Only one Looper may be created per thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>prepare就是 new 出一个 Looper。核心之处在于将 new 出的 Looper 设置到了线程本地变量 sThreadLocal 中。也就是说创建的 Looper 与当前线程发生了绑定。</p>
<p>Looper#prepareMainLooper原理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepareMainLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    prepare(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (Looper.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sMainLooper != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;The main Looper has already been prepared.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sMainLooper = myLooper();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>prepareMainLooper只有在APP进程启动的时候有用，并不推荐开发者调用这个函数。</p>
<h3 id="looper-loop-yuan-li"><a href="#Looper-loop原理" class="headerlink" title="Looper#loop原理"></a>Looper#loop原理<a href="#looper-loop-yuan-li" class="header-anchor">#</a></h3><p><img src="https://img-blog.csdnimg.cn/20200814221152760.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoaXZhbHJvdXNtYW4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>图1 取出Looper对象</p>
<p>图2 校验当前线程是否持有Looper，是否启动而来Looper.prepare</p>
<p>图3 从Looper中取出对应的MessageQueue，主线程Looper就取出主线程的MessageQueue，子线程就取出子线程MessageQueue</p>
<p>图4 从MessageQueue中取出Message</p>
<p>图5 Message#target属性，即handler，调用Message绑定好的handler#dispatchMessage，处理消息。</p>
<p>也就是说，Message最终交由与Message绑定的Handler处理。Looper只是负责无限循环+从MessageQueue中读取。</p>
<h3 id="handler-dispatchmessage"><a href="#Handler-dispatchMessage" class="headerlink" title="Handler#dispatchMessage"></a>Handler#dispatchMessage<a href="#handler-dispatchmessage" class="header-anchor">#</a></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">  * Handle system messages here.</span><br><span class="line">  *&#x2F;</span><br><span class="line"> public void dispatchMessage(Message msg) &#123;</span><br><span class="line">     if (msg.callback !&#x3D; null) &#123;</span><br><span class="line">         handleCallback(msg);&#x2F;&#x2F; 1</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">         if (mCallback !&#x3D; null) &#123;</span><br><span class="line">             if (mCallback.handleMessage(msg)) &#123;&#x2F;&#x2F; 2</span><br><span class="line">                 return;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         handleMessage(msg);&#x2F;&#x2F; 3</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到有3处可以处理Message</p>
<p>图 1触发了Message#Runnable的run方法，要知道callback就是个Runnable子线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleCallback</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">    message.callback.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>图2 触发了 Handler#Callback接口，Callback是Handler构造函数初始化的时候传递进来的。参考Handler#构造函数原理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callback</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg A &#123;<span class="doctag">@link</span> android.os.Message Message&#125; object</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> True if no further handling is desired</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>图3 触发了Handler的handleMessage方法，这是个空实现，一般由开发者复写实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Subclasses must implement this to receive messages.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Looper这一节，我们暂停脚步总结一下：</p>
<ol>
<li><p>主线程和子线程都可以使用Handler，Handler使用方式都是要Looper.prepare+Lopper.loop,</p>
</li>
<li><p>子线程Handler用法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LooperThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> Handler mHandler;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   Looper.prepare();</span><br><span class="line"></span><br><span class="line">   mHandler = <span class="keyword">new</span> Handler() &#123;</span><br><span class="line">	   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">		   <span class="comment">// process incoming messages here</span></span><br><span class="line">	   &#125;</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   Looper.loop();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">new</span> LooperThread().start();</span><br></pre></td></tr></table></figure>


</li>
</ol>
<p>回答这些面试题吧</p>
<h2 id="mian-shi-ti-jie-xi"><a href="#面试题解析" class="headerlink" title="面试题解析"></a>面试题解析<a href="#mian-shi-ti-jie-xi" class="header-anchor">#</a></h2><h3 id="na-xie-chang-jing-shi-yong-dao-liao-handler-yong-handler-zuo-shi-me-ye-wu"><a href="#哪些场景使用到了Handler？用Handler做什么业务？" class="headerlink" title="哪些场景使用到了Handler？用Handler做什么业务？"></a>哪些场景使用到了Handler？用Handler做什么业务？<a href="#na-xie-chang-jing-shi-yong-dao-liao-handler-yong-handler-zuo-shi-me-ye-wu" class="header-anchor">#</a></h3><h4 id="zui-jian-dan-de-xiao-xi-fa-song"><a href="#最简单的消息发送" class="headerlink" title="最简单的消息发送"></a>最简单的消息发送<a href="#zui-jian-dan-de-xiao-xi-fa-song" class="header-anchor">#</a></h4><p>主线程使用Handler， 主线程里或子线程里发送消息，或延迟发送消息的方式更新UI如，启动应用时Splash页面的延迟2，3秒后，跳转到主页面</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WHAT_UPDATE_ICON = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Handler handler = <span class="keyword">new</span> Handler() &#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">               <span class="keyword">case</span> WHAT_UPDATE_ICON:</span><br><span class="line">                   Log.e(Tag, <span class="string">&quot;receive message:&quot;</span> + msg.obj);</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"> &#125;;</span><br><span class="line">   </span><br><span class="line">   Message msg = handler.obtainMessage(WHAT_UPDATE_ICON);</span><br><span class="line">   msg.obj = <span class="string">&quot;update the imageview&quot;</span>;</span><br><span class="line">   handler.sendMessage(msg);</span><br></pre></td></tr></table></figure>
<p>使用消息的时候，尽量使用 obtainMessage 的方式来获取Message，避免多次创建Message对象，消耗内存，效率低下。</p>
<p>记住：消息不一定是更新UI的消息，可以再handlerMessage中做很多事情！</p>
<h4 id="jie-he-handlerthread-chu-li-hao-shi-ren-wu"><a href="#结合HandlerThread处理耗时任务" class="headerlink" title="结合HandlerThread处理耗时任务"></a>结合HandlerThread处理耗时任务<a href="#jie-he-handlerthread-chu-li-hao-shi-ren-wu" class="header-anchor">#</a></h4><p>结合HandlerThread，串行的处理单个耗时任务，如单任务下载</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DownloadOneByOne</span> <span class="keyword">extends</span> <span class="title">HandlerThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DownloadOneByOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(DownloadOneByOne.class.getSimpleName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLooperPrepared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onLooperPrepared();</span><br><span class="line">        <span class="comment">// 初始化下载组件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> HandlerThread mHandlerThread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Handler downloadHandler = <span class="keyword">new</span> Handler()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">        String url = (String) msg.obj;</span><br><span class="line">        <span class="comment">// 使用下载组件开始下载</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化Handler</span></span><br><span class="line">    mHandlerThread = <span class="keyword">new</span> DownloadOneByOne();</span><br><span class="line">    mHandlerThread.start();</span><br><span class="line">    </span><br><span class="line">    downloadHandler = <span class="keyword">new</span> Handler(mHandlerThread.getLooper());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendDownloadTask</span><span class="params">(String downloadUrl)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 发送下载任务</span></span><br><span class="line">    Message msg = downloadHandler.obtainMessage(WHAT_DOWNLOAD_TASK);</span><br><span class="line">    msg.obj = downloadUrl;</span><br><span class="line">    downloadHandler.sendMessage(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="dao-ji-shi-view-de-jian-yi-shi-xian"><a href="#倒计时View的简易实现" class="headerlink" title="倒计时View的简易实现"></a>倒计时View的简易实现<a href="#dao-ji-shi-view-de-jian-yi-shi-xian" class="header-anchor">#</a></h4><p>通过Handler我们还可以快速简易，并且不占用太多性能的实现一个简易的倒计时View。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownView</span> <span class="keyword">extends</span> <span class="title">AppCompatTextView</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 总时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> seconds;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前分钟</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> minutes;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前秒数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> second = <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SECONDS_PER_MINUTE = <span class="number">60</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MILLS_PER_SECOND = <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MILLS_PER_MINUTE = SECONDS_PER_MINUTE * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WHAT_DONE = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WHAT_TICK = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> marginEnd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringBuilder content = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CountDownView</span><span class="params">(Context context, <span class="meta">@Nullable</span> AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">        DeviceProfile deviceProfile = Launcher.getLauncher(getContext()).getDeviceProfile();</span><br><span class="line">        <span class="keyword">int</span> size = (<span class="keyword">int</span>) (MeasureSpec.getSize(widthMeasureSpec) / deviceProfile.inv.numColumns);</span><br><span class="line">        marginEnd = marginEnd == <span class="number">0</span> ? (size - deviceProfile.iconSizePx) / <span class="number">2</span> : marginEnd;</span><br><span class="line"></span><br><span class="line">        setMarginEnd(marginEnd);</span><br><span class="line">        <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setMarginEnd</span><span class="params">(<span class="keyword">int</span> marginEnd)</span> </span>&#123;</span><br><span class="line">        LinearLayout.LayoutParams layoutParams = (LinearLayout.LayoutParams) getLayoutParams();</span><br><span class="line">        layoutParams.setMarginEnd(marginEnd);</span><br><span class="line">        layoutParams.resolveLayoutDirection(layoutParams.getLayoutDirection());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDetachedFromWindow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDetachedFromWindow();</span><br><span class="line">        <span class="keyword">if</span> (handler.hasMessages(WHAT_TICK)) &#123;</span><br><span class="line">            handler.removeMessages(WHAT_TICK);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Handler handler = <span class="keyword">new</span> Handler() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                <span class="keyword">case</span> WHAT_DONE:</span><br><span class="line">                    setVisibility(View.GONE);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    setText(content.toString());</span><br><span class="line">                    handler.post(runnable);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***</span></span><br><span class="line"><span class="comment">     * 设置倒计时</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> millis</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCountDownMills</span><span class="params">(<span class="keyword">long</span> millis)</span> </span>&#123;</span><br><span class="line">        seconds = (<span class="keyword">long</span>) Math.floor(millis / MILLS_PER_SECOND);</span><br><span class="line">        minutes = (<span class="keyword">long</span>) Math.floor(millis / MILLS_PER_MINUTE) - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// start after one second</span></span><br><span class="line">        handler.postDelayed(runnable, MILLS_PER_SECOND);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (seconds &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                handler.sendEmptyMessage(WHAT_DONE);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            seconds--;</span><br><span class="line">            <span class="keyword">if</span> (second &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                second = SECONDS_PER_MINUTE;</span><br><span class="line">                minutes = (<span class="keyword">long</span>) Math.floor(seconds / SECONDS_PER_MINUTE);</span><br><span class="line">            &#125;</span><br><span class="line">            second--;</span><br><span class="line">            content.delete(<span class="number">0</span>, content.length());</span><br><span class="line"></span><br><span class="line">            appendZeroWhenLower10(minutes);</span><br><span class="line">            content.append(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">            appendZeroWhenLower10(second);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (handler.hasMessages(WHAT_TICK)) &#123;</span><br><span class="line">                handler.removeMessages(WHAT_TICK);</span><br><span class="line">            &#125;</span><br><span class="line">            handler.sendEmptyMessageDelayed(WHAT_TICK, MILLS_PER_SECOND);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> StringBuilder <span class="title">appendZeroWhenLower10</span><span class="params">(<span class="keyword">long</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value &lt; <span class="number">10</span>) &#123;</span><br><span class="line">            content.append(<span class="string">&quot;0&quot;</span>).append(value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            content.append(value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="jie-he-intentservice-de-shi-yong"><a href="#结合IntentService的使用" class="headerlink" title="结合IntentService的使用"></a>结合IntentService的使用<a href="#jie-he-intentservice-de-shi-yong" class="header-anchor">#</a></h4><p>使用IntentService处理耗时的任务相对比较简单，我们来个有难度的，结合AlarmManager的调度，息屏唤醒IntentService定时处理任务的案例来讲</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ACTION_WAKE_UP = <span class="string">&quot;com.doze.cpu.wakeup&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerAlarm</span><span class="params">(Context context, <span class="keyword">int</span> wakeType)</span> </span>&#123;</span><br><span class="line">    type = wakeType;</span><br><span class="line">    <span class="keyword">if</span> (alarmManager == <span class="keyword">null</span>)</span><br><span class="line">        alarmManager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (operation != <span class="keyword">null</span>) alarmManager.cancel(operation);</span><br><span class="line"></span><br><span class="line">    schedule(context);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">schedule</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">    intent.setAction(ACTION_WAKE_UP);</span><br><span class="line">    operation = PendingIntent.getBroadcast(context, <span class="number">0</span>, intent, PendingIntent.FLAG_UPDATE_CURRENT);</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            AlarmUtils.setRTCWakeup(alarmManager, AlarmUtils.DEFAULT_TRIGGER_AT_MILLIS, operation);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            AlarmUtils.setElapsedWakeup(alarmManager, AlarmUtils.DEFAULT_TRIGGER_AT_MILLIS, operation);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定时5分钟发送一个Action为com.doze.cpu.wakeup的广播，我们的广播需要继承 WakefulBroadcastReceiver， 在onReceive里，调用startWakefulService方法，会创建一个1分钟的WakeLock，唤醒cpu处理我们的任务，我们的任务IntentService处理最好不过了，处理完就销毁，不会有多余的占用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WakeCPUReceiver</span> <span class="keyword">extends</span> <span class="title">WakefulBroadcastReceiver</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Intent wakefulIntent = <span class="keyword">new</span> Intent(context, WorkService.class);</span><br><span class="line">        startWakefulService(context, wakefulIntent);</span><br><span class="line">        schedule(context);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>startWakefulService的源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ComponentName <span class="title">startWakefulService</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mActiveWakeLocks) &#123;</span><br><span class="line">            <span class="keyword">int</span> id = mNextId;</span><br><span class="line">            mNextId++;</span><br><span class="line">            <span class="keyword">if</span> (mNextId &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                mNextId = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            intent.putExtra(EXTRA_WAKE_LOCK_ID, id);</span><br><span class="line">            ComponentName comp = context.startService(intent);</span><br><span class="line">            <span class="keyword">if</span> (comp == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            PowerManager pm = (PowerManager)context.getSystemService(Context.POWER_SERVICE);</span><br><span class="line">            PowerManager.WakeLock wl = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,</span><br><span class="line">                    <span class="string">&quot;wake:&quot;</span> + comp.flattenToShortString());</span><br><span class="line">            wl.setReferenceCounted(<span class="keyword">false</span>);</span><br><span class="line">            wl.acquire(<span class="number">60</span>*<span class="number">1000</span>);</span><br><span class="line">            mActiveWakeLocks.put(id, wl);</span><br><span class="line">            <span class="keyword">return</span> comp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在IntentService里，我们在onHandleIntent处理我们的任务后，再调用WakefulBroadcastReceiver的静态方法completeWakefulIntent，释放WakeLock，减少电量的消耗</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkService</span> <span class="keyword">extends</span> <span class="title">IntentService</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onHandleIntent</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        Log.e(WakeCPUReceiver.TAG, <span class="string">&quot;WorkService is working&quot;</span>);</span><br><span class="line">        <span class="comment">// TODO 处理我们的任务</span></span><br><span class="line">        WakeCPUReceiver.completeWakefulIntent(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>completeWakefulIntent源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">completeWakefulIntent</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> id = intent.getIntExtra(EXTRA_WAKE_LOCK_ID, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (id == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (mActiveWakeLocks) &#123;</span><br><span class="line">            PowerManager.WakeLock wl = mActiveWakeLocks.get(id);</span><br><span class="line">            <span class="keyword">if</span> (wl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                wl.release();</span><br><span class="line">                mActiveWakeLocks.remove(id);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// We return true whether or not we actually found the wake lock</span></span><br><span class="line">            <span class="comment">// the return code is defined to indicate whether the Intent contained</span></span><br><span class="line">            <span class="comment">// an identifier for a wake lock that it was supposed to match.</span></span><br><span class="line">            <span class="comment">// We just log a warning here if there is no wake lock found, which could</span></span><br><span class="line">            <span class="comment">// happen for example if this function is called twice on the same</span></span><br><span class="line">            <span class="comment">// intent or the process is killed and restarted before processing the intent.</span></span><br><span class="line">            Log.w(<span class="string">&quot;WakefulBroadcastReceiver&quot;</span>, <span class="string">&quot;No active wake lock id #&quot;</span> + id);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="idlehandler-yong-yu-ui-xing-neng-you-hua"><a href="#IdleHandler-用于UI性能优化" class="headerlink" title="IdleHandler 用于UI性能优化"></a>IdleHandler 用于UI性能优化<a href="#idlehandler-yong-yu-ui-xing-neng-you-hua" class="header-anchor">#</a></h4><p>先计算任务放在Activity绘制结束完成之后，节省了90Ms计算时间。参考面试题你了解过IdleHandler 吗？<br><img src="https://img-blog.csdnimg.cn/20200814221240437.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoaXZhbHJvdXNtYW4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="handlerthread-yong-yu-dan-xian-cheng-xiao-xi-tong-zhi-qi"><a href="#HandlerThread用于单线程消息通知器" class="headerlink" title="HandlerThread用于单线程消息通知器"></a><strong>HandlerThread</strong>用于单线程消息通知器<a href="#handlerthread-yong-yu-dan-xian-cheng-xiao-xi-tong-zhi-qi" class="header-anchor">#</a></h4><p>在用户操作某些界面元素的时候，如收藏、点赞、转发，有一个小的问题，就是如果有一个操作生成10个快速连续的增删改查操作，那么我们的UI就会收到10次回调，而这种场景下我们其实只需要最后一次回调就够了，中间操作其实不用刷新UI的。如何合并这些频繁操作，只在最后一次操作结束时候响应UI更新呢。</p>
<p>答：HandlerThread+反射MessageQueue+idelHandler<br><img src="https://img-blog.csdnimg.cn/20200814221259759.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoaXZhbHJvdXNtYW4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="yong-handler-yu-dao-shi-me-wen-ti-zen-me-jie-jue-zhe-xie-wen-ti-de"><a href="#用Handler遇到什么问题？怎么解决这些问题的？" class="headerlink" title="用Handler遇到什么问题？怎么解决这些问题的？"></a>用Handler遇到什么问题？怎么解决这些问题的？<a href="#yong-handler-yu-dao-shi-me-wen-ti-zen-me-jie-jue-zhe-xie-wen-ti-de" class="header-anchor">#</a></h3><h4 id="wen-ti-handler-yan-shi-bu-zhun-que-jing-chang-dao-liao-shi-jian-bu-xiang-ying-ye-wu"><a href="#问题：Handler延时不准确，经常到了时间不响应业务" class="headerlink" title="问题：Handler延时不准确，经常到了时间不响应业务"></a>问题：Handler延时不准确，经常到了时间不响应业务<a href="#wen-ti-handler-yan-shi-bu-zhun-que-jing-chang-dao-liao-shi-jian-bu-xiang-ying-ye-wu" class="header-anchor">#</a></h4><p>解决：<strong>SystemClock.uptimeMillis()**表示系统</strong>开机到当前的时间总数**，单位是毫秒，但是，当系统进入深度睡眠（CPU休眠、屏幕休眠、设备等待外部输入）时间就会停止，但是不会受到时钟缩放、空闲或者其他节能机制的影响。</p>
<p>使用其他延时方式</p>
<ol>
<li>用concurrent包的TimeUnit类延时sleep()方法延时</li>
<li>Timer+TimeTask</li>
<li>AlarmManager  </li>
<li>ScheduledExecutorService</li>
</ol>
<h4 id="wen-ti-zi-xian-cheng-chuang-jian-handler-shi-bai"><a href="#问题：子线程创建Handler失败" class="headerlink" title="问题：子线程创建Handler失败"></a>问题：子线程创建Handler失败<a href="#wen-ti-zi-xian-cheng-chuang-jian-handler-shi-bai" class="header-anchor">#</a></h4><p>解决：参考Looper#子线程用例部分</p>
<h4 id="wen-ti-fei-jing-tai-lei-dao-zhi-de-nei-cun-xie-lou"><a href="#问题：非静态类导致的内存泄漏" class="headerlink" title="问题：非静态类导致的内存泄漏"></a>问题：非静态类导致的内存泄漏<a href="#wen-ti-fei-jing-tai-lei-dao-zhi-de-nei-cun-xie-lou" class="header-anchor">#</a></h4><p>解决：static+WeakReference</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span></span>&#123;</span><br><span class="line">     WeakReference&lt;MainActivity&gt; mActivity;</span><br><span class="line">     MyHandler(MainActivity activity)&#123;</span><br><span class="line">         mActivity = <span class="keyword">new</span> WeakReference&lt;MainActivity&gt;(activity);</span><br><span class="line">     &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> cuttent = msg.what;</span><br><span class="line"></span><br><span class="line">        MainActivity activity = mActivity.get();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(activity.currentlayout!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            Animation set2 = <span class="keyword">new</span> TranslateAnimation(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,-<span class="number">100</span>);</span><br><span class="line">            set2.setDuration(<span class="number">500</span>);</span><br><span class="line">            activity.currentlayout.setAnimation(set2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        activity.linearLayout.removeAllViews();</span><br><span class="line"></span><br><span class="line">        activity.currentlayout = activity.initView(cuttent);</span><br><span class="line"></span><br><span class="line">        Animation set1 = <span class="keyword">new</span> TranslateAnimation(<span class="number">0</span>,<span class="number">0</span>,<span class="number">100</span>,<span class="number">0</span>);</span><br><span class="line">        set1.setDuration(<span class="number">500</span>);</span><br><span class="line">        activity.currentlayout.setAnimation(set1);</span><br><span class="line"></span><br><span class="line">        activity.linearLayout.addView(activity.currentlayout);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="shuo-yi-shuo-handler-yuan-li"><a href="#说一说Handler原理？" class="headerlink" title="说一说Handler原理？"></a>说一说Handler原理？<a href="#shuo-yi-shuo-handler-yuan-li" class="header-anchor">#</a></h3><p>原理的定义是：某个类的提供哪些功能，这些功能是如何实现的？</p>
<p>我认为回答这个问题包含三步：Handler是什么，关键API是什么，关键对象是什么？</p>
<h4 id="di-yi-bu-hui-da-handler-shi-shi-me-you-na-xie-chang-jing"><a href="#第一步：回答Handler是什么，有哪些场景。" class="headerlink" title="第一步：回答Handler是什么，有哪些场景。"></a>第一步：回答Handler是什么，有哪些场景。<a href="#di-yi-bu-hui-da-handler-shi-shi-me-you-na-xie-chang-jing" class="header-anchor">#</a></h4><p>答：Handler是Android消息通信组件，用于线程间通信，收发消息，更新UI等参考面试题目1。</p>
<h4 id="di-er-bu-handler-de-guan-jian-api-shi-shi-me-yong-tu-shi-shi-me-ru-he-shi-xian-de"><a href="#第二步：Handler的关键API是什么，用途是什么，如何实现的。" class="headerlink" title="第二步：Handler的关键API是什么，用途是什么，如何实现的。"></a>第二步：Handler的关键API是什么，用途是什么，如何实现的。<a href="#di-er-bu-handler-de-guan-jian-api-shi-shi-me-yong-tu-shi-shi-me-ru-he-shi-xian-de" class="header-anchor">#</a></h4><p>答：关键API有：</p>
<p>构造函数：用于绑定MessageQueue、Looper、Message、Runnable、CallBack等</p>
<p>obtainMessage：用于复用Message</p>
<p>post、sendMessage：不同的执行Message方式，前者是接收Runnable参数，后者是当前线程</p>
<p>sendMessageAtTime：消息延时的实现入口，调用MessageQueue#enqueueMessage</p>
<h4 id="di-san-bu-handler-de-guan-jian-dui-xiang-shi-shi-me-ti-gong-na-xie-gong-neng-zhe-xie-gong-neng-ru-he-shi-xian-de"><a href="#第三步：Handler的关键对象是什么，提供哪些功能，这些功能如何实现的。" class="headerlink" title="第三步：Handler的关键对象是什么，提供哪些功能，这些功能如何实现的。"></a>第三步：Handler的关键对象是什么，提供哪些功能，这些功能如何实现的。<a href="#di-san-bu-handler-de-guan-jian-dui-xiang-shi-shi-me-ti-gong-na-xie-gong-neng-zhe-xie-gong-neng-ru-he-shi-xian-de" class="header-anchor">#</a></h4><p>答：关键对象有：</p>
<p>Message</p>
<p>Message是一种链表结构的子节点，作为载体可以存储的信息有：公开信息arg1、arg2、handler、Message，私有信息when、Runnable。Message有2种Flag，使用中、同步中，三种消息类型，如普通消息、异步消息、消息屏障。</p>
<p>MessageQueue</p>
<p>MessageQueue提供一种链表数据结构，包括头结点信息，插入节点的方式是按照 Message 的时间 when 顺序，时间小的先插入 。</p>
<p>Looper</p>
<p>开启无限循环，不断从 MessageQueue 中取出 Message，然后处理 Message 中指定的任务。典型的Looper是主线程Looper，在 ActivityThread 的 main 方法中，除了调用 Looper.prepareMainLooper 初始化 Looper 对象之外，还调用了 Looper.loop 方法开启无限循环，Looper 的主要功能就是在这个循环中完成的。</p>
<p>Looper提供了一些native方法用于唤醒阻塞状态如nativePollOnce</p>
<p>Looper不断loop的结果，就是调用msg.target.handleMessage,即执行开发者定义好的Handler#handleMessage方法体中的业务。</p>
<h3 id="neng-zi-ji-shi-xian-yi-ge-handler-ma"><a href="#能自己实现一个Handler吗？" class="headerlink" title="能自己实现一个Handler吗？"></a>能自己实现一个Handler吗？<a href="#neng-zi-ji-shi-xian-yi-ge-handler-ma" class="header-anchor">#</a></h3><p>根据Handler的类图，我们可以抽象出Handler消息组件的基本架构。<br><img src="https://img-blog.csdnimg.cn/20200814221418179.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoaXZhbHJvdXNtYW4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="jian-ban-handler"><a href="#简版Handler" class="headerlink" title="简版Handler"></a>简版Handler<a href="#jian-ban-handler" class="header-anchor">#</a></h4><p>概要设计：</p>
<p>首先我们仿照Android的Handler定义了：阻塞队列、处理消息的回调、分发和发送消息的方法<br>其次然后在创建Handler时，我们获取了当前线程的Looper和MessageQueue</p>
<p>最后，当我们发送消息的时候，将消息添加进之前得到的MessageQueue</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MyMessageQueue queue;<span class="comment">// 用于进行线程间通信的阻塞队列</span></span><br><span class="line">    <span class="keyword">private</span> CallBack callBack; <span class="comment">// 处理消息的回调</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyHandler</span><span class="params">(CallBack callBack)</span> </span>&#123;</span><br><span class="line">        MyLooper looper = MyLooper.myLooper();</span><br><span class="line">        <span class="keyword">if</span> (looper == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;在新开的线程中。创建MyHandler对象需要先调用MyLooper.prepare()方法。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        queue = looper.queue;</span><br><span class="line">        <span class="keyword">this</span>.callBack = callBack;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消息接收的回调</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CallBack</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(MyMessage msg)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(MyMessage msg)</span> </span>&#123;</span><br><span class="line">        msg.target = <span class="keyword">this</span>;</span><br><span class="line">        queue.enqueueMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//派发消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(MyMessage msg)</span> </span>&#123;</span><br><span class="line">        callBack.handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="jian-ban-looper"><a href="#简版Looper" class="headerlink" title="简版Looper"></a>简版Looper<a href="#jian-ban-looper" class="header-anchor">#</a></h4><ol>
<li>在Looper中，我们用一个ThreadLocal存储当前Looper的相关数据</li>
<li>定义了一个消息队列，用来管理消息</li>
<li>在prepare()时，用ThreadLocal存储Looper的数据；在myLooper时，读取ThreadLocal存储的Looper数据</li>
<li>在loop()时,用一个死循环来不断的接受和分发消息</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLooper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;MyLooper&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> MyLooper myLooper;</span><br><span class="line">    <span class="keyword">public</span> MyMessageQueue queue;<span class="comment">//一个线程对应一个阻塞队列</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MyLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queue = <span class="keyword">new</span> MyMessageQueue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取当前线程相对应的Looper对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MyLooper <span class="title">myLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> threadLocal.get();<span class="comment">//当未调用prepare()方法时。ThreadLocal.get()方法返回的为null;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为本线程准备对应的MyLooper对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (threadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException( <span class="string">&quot;Only one MyLooper may be created per thread&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        threadLocal.set(<span class="keyword">new</span> MyLooper());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里启动消息循环</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            myLooper = myLooper();</span><br><span class="line">            MyMessageQueue mQueue = myLooper.queue;</span><br><span class="line">            senior.thread_concurrent.handler.MyMessage msg = mQueue.next();<span class="comment">// take()方法是个阻塞方法。线程运行到此会阻塞住。以准备接收发过来的消息</span></span><br><span class="line">            msg.target.dispatchMessage(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="jian-ban-messagequeue"><a href="#简版MessageQueue" class="headerlink" title="简版MessageQueue"></a>简版MessageQueue<a href="#jian-ban-messagequeue" class="header-anchor">#</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMessageQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;MyMessage&gt; queue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> quit = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyMessageQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</span><br><span class="line">        queue.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入队</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MyMessage msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;消息必须有一个消息处理者&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            queue.put(msg);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出队</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyMessage <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MyMessage msg = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (quit) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            msg = queue.take();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//销毁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">quit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        quit = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="jian-ban-message"><a href="#简版Message" class="headerlink" title="简版Message"></a>简版Message<a href="#jian-ban-message" class="header-anchor">#</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMessage</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> msg1;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> msg2;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> what;</span><br><span class="line">    <span class="keyword">public</span> Object obj;</span><br><span class="line">    <span class="keyword">public</span> MyHandler target;</span><br><span class="line">    <span class="keyword">public</span> Runnable runnable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="xie-yi-ge-wang-luo-qing-qiu-de-ce-shi-yong-li"><a href="#写一个网络请求的测试用例" class="headerlink" title="写一个网络请求的测试用例"></a>写一个网络请求的测试用例<a href="#xie-yi-ge-wang-luo-qing-qiu-de-ce-shi-yong-li" class="header-anchor">#</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> senior.thread_concurrent.handler.MyHandler mainHandler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> TestClient().test();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化主线程Looper</span></span><br><span class="line">        MyLooper.prepare();</span><br><span class="line">        mainHandler = <span class="keyword">new</span> senior.thread_concurrent.handler.MyHandler(<span class="keyword">new</span> senior.thread_concurrent.handler.MyHandler.CallBack() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(senior.thread_concurrent.handler.MyMessage msg)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 刷新界面</span></span><br><span class="line">                String obj = (String) msg.obj;</span><br><span class="line">                LogUtil.print(<span class="string">&quot;刷新界面:&quot;</span> + obj);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//发起网络请求</span></span><br><span class="line">        LogUtil.print(<span class="string">&quot;在主线程发起一个网络请求&quot;</span>);</span><br><span class="line">        NetThread netThread = <span class="keyword">new</span> NetThread(<span class="string">&quot;http://baidu.com&quot;</span>);</span><br><span class="line">        netThread.start();</span><br><span class="line">        LogUtil.print(<span class="string">&quot;在主线程继续其它操作&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开始消息循环</span></span><br><span class="line">        MyLooper.loop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//网络线程类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">NetThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String url;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">NetThread</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.url = url;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            String body = getWebData(url);</span><br><span class="line">            senior.thread_concurrent.handler.MyMessage msg = <span class="keyword">new</span> senior.thread_concurrent.handler.MyMessage();</span><br><span class="line">            msg.obj = body;</span><br><span class="line">            mainHandler.sendMessage(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行网络请求</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getWebData</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">        LogUtil.print(<span class="string">&quot;执行请求网络:&quot;</span> + url);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        String body = <span class="string">&quot;这是&quot;</span> + url + <span class="string">&quot;的响应值&quot;</span>;</span><br><span class="line">        LogUtil.print(<span class="string">&quot;请求网络成功:&quot;</span> + body);</span><br><span class="line">        <span class="keyword">return</span> body;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="shuo-yi-shuo-handler-yan-shi-yuan-li"><a href="#说一说Handler延时原理？" class="headerlink" title="说一说Handler延时原理？"></a>说一说Handler延时原理？<a href="#shuo-yi-shuo-handler-yan-shi-yuan-li" class="header-anchor">#</a></h3><p>首先Handler无论是post还是sendMessage方式处理Message过程中，都会产生一个时间戳，计算方式是SystemClock.uptimeMillis() + delayMillis，这个时间戳会赋值给Message.when，影响Message在MessageQueue链表中的位置。时间戳值越大，越晚执行。</p>
<p>Handler延时存在时间不准的问题，问题产生原因以及解决办法以及在<u>面试题2问题：Handler延时不准确，经常到了时间不响应业务</u>提到。</p>
<h3 id="handler-yan-shi-you-na-xie-que-xian-zao-cheng-zhe-xie-que-xian-de-yuan-yin"><a href="#Handler延时有哪些缺陷？造成这些缺陷的原因？" class="headerlink" title="Handler延时有哪些缺陷？造成这些缺陷的原因？"></a>Handler延时有哪些缺陷？造成这些缺陷的原因？<a href="#handler-yan-shi-you-na-xie-que-xian-zao-cheng-zhe-xie-que-xian-de-yuan-yin" class="header-anchor">#</a></h3><p>参考<u>面试题2问题：Handler延时不准确，经常到了时间不响应业务</u></p>
<p>Handler的post与sendMessage有哪些区别？</p>
<p>post需要指定Runnable参数，将传入的Runnable绑定至Handler默认的Message，很多值都为默认值，换言之post方法只是为了执行Runnable子线程的任务。</p>
<p>sendMessage需要传入开发者自定义的Message参数，将Message中的信息载体传递下去，sendMessage方法是为了传递消息。</p>
<p>两者最终都会将Message传递下去，区别是Message中的数据信息赋值数量的不同。</p>
<h3 id="zi-xian-cheng-neng-shi-yong-handler-ma"><a href="#子线程能使用Handler吗？" class="headerlink" title="子线程能使用Handler吗？"></a>子线程能使用Handler吗？<a href="#zi-xian-cheng-neng-shi-yong-handler-ma" class="header-anchor">#</a></h3><p>能，可以使用handler对象以及对应的方法。区别是Handler的创建位置，如果Handler在主线程创建，那么只能在主线程中处理消息。如果在子线程创建Handler，那么才能在子线程处理消息。</p>
<h3 id="zi-xian-cheng-neng-chuang-jian-handler-ma"><a href="#子线程能创建Handler吗？" class="headerlink" title="子线程能创建Handler吗？"></a>子线程能创建Handler吗？<a href="#zi-xian-cheng-neng-chuang-jian-handler-ma" class="header-anchor">#</a></h3><p>能，前提是需要Looper.prepare+Looper.loop</p>
<p>Looper.prepare是将当前线程添加到sThreadLocal中，Looper.loop是开启无限循环，不断执行Message</p>
<h3 id="zi-xian-cheng-chuang-jian-handler-zhe-me-ma-fan-you-shi-me-ti-dai-fang-fa-ma-liao-jie-guo-handlerthread-ma"><a href="#子线程创建Handler这么麻烦，有什么替代方法吗？了解过HandlerThread吗？" class="headerlink" title="子线程创建Handler这么麻烦，有什么替代方法吗？了解过HandlerThread吗？"></a>子线程创建Handler这么麻烦，有什么替代方法吗？了解过HandlerThread吗？<a href="#zi-xian-cheng-chuang-jian-handler-zhe-me-ma-fan-you-shi-me-ti-dai-fang-fa-ma-liao-jie-guo-handlerthread-ma" class="header-anchor">#</a></h3><p>HandlerThread的run方法中替我们做了Looper.prepare+Looper.loop</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HandlerThread handlerThread = <span class="keyword">new</span> HandlerThread(<span class="string">&quot;handler-thread&quot;</span>);</span><br><span class="line">handlerThread.start(); <span class="comment">// 必须在Handler创建前调用，因为线程start后才会创建Looper</span></span><br><span class="line"></span><br><span class="line">Handler threadHandler = <span class="keyword">new</span> Handler(handlerThread.getLooper()) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">        <span class="comment">// 处理消息，因为这个方法是在子线程调用，所以可以在这执行耗时任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="liao-jie-guo-idlehandler-ma"><a href="#了解过IdleHandler吗？" class="headerlink" title="了解过IdleHandler吗？"></a>了解过IdleHandler吗？<a href="#liao-jie-guo-idlehandler-ma" class="header-anchor">#</a></h3><p>IdleHandler 用途：</p>
<ol>
<li>IdleHandler 是 Handler 提供的一种在消息队列空闲时，执行任务的时机；</li>
<li>当 MessageQueue 当前没有立即需要处理的消息时，会执行 IdleHandler；</li>
<li>Activity界面绘制结束的回调时机</li>
</ol>
<p>IdleHandler 缺点：</p>
<ol>
<li>但它执行的时机依赖消息队列的情况，那么如果 MessageQueue 一直有待执行的消息时，IdleHandler 就一直得不到执行，也就是它的执行时机是不可控的，不适合执行一些对时机要求比较高的任务。</li>
</ol>
<p>IdleHandler场景</p>
<p>如果我们想在界面绘制出来后做点什么，那么在onResume里面是不合适的，它先于measure等流程了<strong>， **有人可能会说在onResume里面post一个runnable可以吗？还是不行，因为那样就会变成这个样子</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200814221532843.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoaXZhbHJvdXNtYW4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>所以你的行为一样会在绘制之前执行，这个时候我们的主角IdleHandler就发挥作用了，我们前面说了，它是在looper里面message暂时执行完毕了就会回调，顾名思义嘛，Idle就是队列为空的意思，那么我们的onResume和measure, layout, draw都是一个个message的话，这个IdleHandler就提供了一个它们都执行完毕的回调了，大概就是这样<br><img src="https://img-blog.csdnimg.cn/20200814221511481.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoaXZhbHJvdXNtYW4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>也就是说IdleHandler可以再界面绘制的消息回调之后执行。<br><img src="https://img-blog.csdnimg.cn/20200814221456646.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoaXZhbHJvdXNtYW4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>优化前：</p>
<p>这个是我们地图的公交详情页面， 进入之后产品要求左边的页卡需要展示，可以看到左边的页卡是一个非常复杂的布局，那么进入之后的效果可以明显看到头部的展示信息是先显示空白再100毫秒左右之后才展示出来的，原因就是这个页卡的内容比较复杂，用数据向它填充的时候花了较长时间，代码如下：<br><img src="https://img-blog.csdnimg.cn/2020081422161443.png#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9mLndldGVzdC5xcS5jb20vZ3FvcC8xMDAwMC8yMDAwMC9MYWJJbWFnZV8xNjY0ODA1Yjc3YTAxZDE5MGUwY2Y2MGY2YjkxMGI1MS5naWY"></p>
<p>可以看到这个detailView就是这个侧滑的页卡了，填充里面的数据花了90ms，如果这个时间是用在了界面view绘制之前的话，就会出现以上的效果了，view先是白的，再出现，这样就体验不好了。</p>
<p>优化后：如果我们把它放到IdleHandler里面呢？</p>
<p>结果非常明显：顶部的页卡先展示出来了，这样体验是不是会更好一些呢。虽然只有短短90ms，不过我们做app也应该关注这种细节优化的，是吧~ 这个做法也提供了一种思路，android本身提供的activity框架和fragment框架并没有提供绘制完成的回调，如果我们自己实现一个框架，就可以使用这个IdleHandler来实现一个onRenderFinished这种回调了。</p>
<p>代码如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20200814221558397.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoaXZhbHJvdXNtYW4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9mLndldGVzdC5xcS5jb20vZ3FvcC8xMDAwMC8yMDAwMC9MYWJJbWFnZV83MTliYjQ0YjE3NTZkOTE4OGJkOGExMzQyNTE1NWIzYS5naWY"><br>特别参考</p>
<p><a href="https://wetest.qq.com/lab/view/352.html">https://wetest.qq.com/lab/view/352.html</a></p>
<p><a href="https://blog.csdn.net/u013718120/article/details/51945490">https://blog.csdn.net/u013718120/article/details/51945490</a></p>
]]></content>
      <categories>
        <category>Android</category>
        <category>应用层</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Handler</tag>
      </tags>
  </entry>
  <entry>
    <title>《高效学习方法全集》日记</title>
    <url>/ye-jincheng-website/super-learn-skills/</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="shu-ji"><a href="#书籍" class="headerlink" title="书籍"></a>书籍<a href="#shu-ji" class="header-anchor">#</a></h1><h1 id="shu-ji"><a href="#书籍-1" class="headerlink" title="书籍"></a>书籍<a href="#shu-ji" class="header-anchor">#</a></h1><table>
<thead>
<tr>
<th>名称</th>
<th>详情</th>
</tr>
</thead>
<tbody><tr>
<td><strong>封面</strong></td>
<td><img src="http://cdn.yangchaofan.cn/gaoxiao%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95.jpg" width="50%" height="50%"></td>
</tr>
<tr>
<td><strong>作者</strong></td>
<td>曹婷</td>
</tr>
<tr>
<td><strong>出版社</strong></td>
<td>星火教育研究院</td>
</tr>
<tr>
<td><strong>介绍</strong></td>
<td>分为学习基础篇、学习修炼篇、学习问题对症篇；学习对症篇主要解决语文、数学、英文、历史、政治的疑难杂症；学习修炼篇提供了预习、听课、复习、做题的基本思路，克服困难的方法；学习基础篇主要讲了时间管理、注意力管理、记忆力的小技巧。</td>
</tr>
</tbody></table>
<h1 id="bi-ji"><a href="#笔记" class="headerlink" title="笔记"></a>笔记<a href="#bi-ji" class="header-anchor">#</a></h1><h2 id="zhi-shi-dian-1"><a href="#知识点1" class="headerlink" title="知识点1"></a>知识点1<a href="#zhi-shi-dian-1" class="header-anchor">#</a></h2><p>###定义</p>
<h3 id="yong-tu"><a href="#用途" class="headerlink" title="用途"></a>用途<a href="#yong-tu" class="header-anchor">#</a></h3><p>###知识体系</p>
<p>###配图</p>
<p>流程图、概念图、思维导图、学科专业配图等</p>
<h1 id="zong-jie"><a href="#总结" class="headerlink" title="总结"></a>总结<a href="#zong-jie" class="header-anchor">#</a></h1><p>本书读了几章，有什么收获，对之前知识点有什么影响，对未来的什么方面有影响</p>
<p>可以把什么知识点用在什么地方，可以获得哪些利益，潜在风险是什么</p>
]]></content>
      <categories>
        <category>家庭教育</category>
        <category>学习方法</category>
      </categories>
      <tags>
        <tag>学习方法</tag>
      </tags>
  </entry>
</search>
