<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>波尔克</title>
    <url>/blog//2021/02/website_nickname/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="波尔克"><a href="#波尔克" class="headerlink" title="波尔克"></a>波尔克<a href="#波尔克" class="header-anchor">#</a></h1><p>（谐音“博儿客”）</p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍<a href="#介绍" class="header-anchor">#</a></h1><p>个人网站用了有四年了，期间一直都是用PHP+MySql的方式部署在阿里云，从备案域名折腾服务器，到调试各种插件，从制定学习计划，到学课程，又是边写文章边研究Markdown排版，种种事情花了很大功夫。今年1月份发生了一件事情——服务器到期，那会儿工作忙一直拖着续费的事情。阿里清空了磁盘，我也是事后才注意到通知短信，发现网站的文章数据全丢的那一刻，整个人浑身感觉都不好了。</p>
<p>痛定思痛，决定文章还是要继续写，写哪里呢CSDN、博客园、简书、掘金都只适合当存档的地方，毕竟没有个人网站用起来有感情。想起来之前工作的时候，为了写音视频直播学了Node，注意过Hexo框架，这个框架可以快速搭个人网站。哎哟不错哦，一拍大腿说干就干。谁让咱是行动派！</p>
<p>最终我花了一天时间，使用码云仓库+Hexo搭一个小型静态网站。优点是：免费，简单，便捷，最大优点是动静分离，静态资源放国内仓库，占磁盘空间的图片资源放CDN服务器，通过域名转发访问，加载效率杠杠滴。</p>
<p>这篇文章主要包含了个人网站的技术架构和常见问题。包括使用的oss管理平台、域名管理、评论管理、文章编辑与发布、网站编辑管理等功能的设计与实现。</p>
<a id="more"></a>

<h1 id="网站架构"><a href="#网站架构" class="headerlink" title="网站架构"></a>网站架构<a href="#网站架构" class="header-anchor">#</a></h1><table>
<thead>
<tr>
<th>名称</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>typora</td>
<td>markdown编辑器</td>
</tr>
<tr>
<td>hexo</td>
<td>博客服务</td>
</tr>
<tr>
<td>nodejs</td>
<td>hexo编译环境</td>
</tr>
<tr>
<td>gitee</td>
<td>码云代码仓库</td>
</tr>
<tr>
<td>next</td>
<td>hexo主题</td>
</tr>
<tr>
<td>七牛云</td>
<td>oss图片文件仓库</td>
</tr>
<tr>
<td>阿里云域名</td>
<td>域名转发、cdn转发</td>
</tr>
<tr>
<td>hexo-toc</td>
<td>文档插件显示二级目录，响应点击事件</td>
</tr>
<tr>
<td>hexo-admin</td>
<td>管理后台</td>
</tr>
<tr>
<td>hexo-wordcount</td>
<td>统计字数</td>
</tr>
<tr>
<td>hexo-renderer-markdown-it-plus</td>
<td>markdown解析插件</td>
</tr>
<tr>
<td>leanclound</td>
<td>阅读量统计插件，如何配置<a href="https://blog.csdn.net/lijing742180/article/details/87928554">参考文章</a></td>
</tr>
<tr>
<td>gitment</td>
<td>git评论云</td>
</tr>
<tr>
<td>haoyuePlayer</td>
<td>音乐播放</td>
</tr>
<tr>
<td>aplayer</td>
<td>音乐播放</td>
</tr>
<tr>
<td>baidu_push</td>
<td>文章推送</td>
</tr>
<tr>
<td>rating</td>
<td>评分</td>
</tr>
<tr>
<td>calendar</td>
<td>日历</td>
</tr>
<tr>
<td>live2d</td>
<td>看板娘</td>
</tr>
<tr>
<td>Mpic</td>
<td>图床发布工具，自动发布七牛</td>
</tr>
<tr>
<td>Carouscl</td>
<td><a href="https://getbootstrap.com/docs/4.0/components/carousel/">轮播图功能使用了Boostarp-Carouscl</a></td>
</tr>
<tr>
<td>valine-admin</td>
<td>评论云</td>
</tr>
<tr>
<td>hexo-related-popular-posts</td>
<td>文章推荐</td>
</tr>
<tr>
<td>widgetpack</td>
<td><a href="https://widgetpack.com/">文章评分</a></td>
</tr>
<tr>
<td>firestore</td>
<td><a href="https://www.liaofuzhan.com/posts/781439527.html">top排行</a></td>
</tr>
<tr>
<td>hexo-generator-index</td>
<td>分页</td>
</tr>
<tr>
<td>hexo-generator-archive</td>
<td>分页</td>
</tr>
<tr>
<td>hexo-generator-category</td>
<td>分页</td>
</tr>
<tr>
<td>hexo-generator-tag</td>
<td>分页</td>
</tr>
<tr>
<td>hexo-wordcount</td>
<td>字数与阅读时间</td>
</tr>
<tr>
<td>gulp</td>
<td>压缩代码</td>
</tr>
<tr>
<td>hexo-theme-Wikitten</td>
<td>文件树预览</td>
</tr>
<tr>
<td>hexo-directory-category</td>
<td>自定义分类页</td>
</tr>
<tr>
<td>hexo-statistics-charts</td>
<td>静态图表统计post、tags</td>
</tr>
<tr>
<td>hexo-online-server</td>
<td>在线编辑文章、页面、发布</td>
</tr>
<tr>
<td>hexo-photoswipe</td>
<td><a href="https://github.com/HarborZeng/hexo-photoswipe/blob/master/README_CN.md">滑动轮播点击图片展示器</a></td>
</tr>
<tr>
<td>giteement</td>
<td>评论云</td>
</tr>
</tbody></table>
<h1 id="模板架构"><a href="#模板架构" class="headerlink" title="模板架构"></a>模板架构<a href="#模板架构" class="header-anchor">#</a></h1><table>
<thead>
<tr>
<th>模板名称</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>android-xx-Tips</td>
<td>Android百问百答模板</td>
</tr>
<tr>
<td>book-note-model</td>
<td>读书笔记模板</td>
</tr>
<tr>
<td>draft</td>
<td>草稿模板</td>
</tr>
<tr>
<td>page</td>
<td>页面模板</td>
</tr>
<tr>
<td>post</td>
<td>文章模板</td>
</tr>
</tbody></table>
<h1 id="安装教程"><a href="#安装教程" class="headerlink" title="安装教程"></a>安装教程<a href="#安装教程" class="header-anchor">#</a></h1><h2 id="nodejs安装教程"><a href="#nodejs安装教程" class="headerlink" title="nodejs安装教程"></a>nodejs安装教程<a href="#nodejs安装教程" class="header-anchor">#</a></h2><p>步骤太简单了，难点就是找到合适版本、合适渠道的安装包，推荐国内使用方式2node中文网的方式下载安装</p>
<table>
<thead>
<tr>
<th>方式</th>
<th>缺点</th>
<th>优点</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://nodejs.org/zh-cn/">node官网</a>，点击链接下载，一路next同意协议安装</td>
<td>国外服务器下载慢</td>
<td>最新安装包</td>
</tr>
<tr>
<td><a href="http://nodejs.cn/">node中文网</a>，点击链接下载，一路next同意协议安装</td>
<td>安装包版本落后1-2个版本</td>
<td>国内服务器下载快</td>
</tr>
</tbody></table>
<h2 id="码云配置网站教程"><a href="#码云配置网站教程" class="headerlink" title="码云配置网站教程"></a>码云配置网站教程<a href="#码云配置网站教程" class="header-anchor">#</a></h2><h2 id="git使用教程"><a href="#git使用教程" class="headerlink" title="git使用教程"></a>git使用教程<a href="#git使用教程" class="header-anchor">#</a></h2><h2 id="hexo使用教程"><a href="#hexo使用教程" class="headerlink" title="hexo使用教程"></a>hexo使用教程<a href="#hexo使用教程" class="header-anchor">#</a></h2><p>hexo官网有详细步骤，小白可以参考百度上的安装教程博客</p>
<table>
<thead>
<tr>
<th>方式</th>
<th>步骤</th>
<th>缺点</th>
<th>优点</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://hexo.io/zh-cn/docs/">hexo官网</a>，权威hexo安装步骤</td>
<td>npm install -g hexo-cli；</td>
<td>不适合小白用户，命令行操作居多</td>
<td>简洁，明了，歧义少</td>
</tr>
<tr>
<td>搜索引擎“hexo安装步骤”</td>
<td><a href="https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html">《参考》</a></td>
<td>遇到问题较难解答</td>
<td>傻瓜式，上手快</td>
</tr>
</tbody></table>
<h1 id="hexo常见指令"><a href="#hexo常见指令" class="headerlink" title="hexo常见指令"></a>hexo常见指令<a href="#hexo常见指令" class="header-anchor">#</a></h1><table>
<thead>
<tr>
<th>指令</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>hexo init</td>
<td>在当前目录下创建工程</td>
</tr>
<tr>
<td>_config.yml</td>
<td>deploy:   type: git   repository: <a href="mailto:&#103;&#x69;&#x74;&#x40;&#103;&#x69;&#116;&#x68;&#117;&#x62;&#x2e;&#99;&#111;&#x6d;">&#103;&#x69;&#x74;&#x40;&#103;&#x69;&#116;&#x68;&#117;&#x62;&#x2e;&#99;&#111;&#x6d;</a>:liuxianan/liuxianan.github.io.git   branch: master</td>
</tr>
<tr>
<td>hexo clean</td>
<td>清除缓存</td>
</tr>
<tr>
<td>hexo g</td>
<td>生成web</td>
</tr>
<tr>
<td>hexo s</td>
<td>启动web服务并预览，在浏览器输入 <a href="http://localhost:4000/">http://localhost:4000</a></td>
</tr>
<tr>
<td>hexo d</td>
<td>发布pulic 目录下的静态页面至github</td>
</tr>
<tr>
<td>git clone url themes/yilia</td>
<td>下载指定主题到根目录/thems/yilia/ 下</td>
</tr>
<tr>
<td>hexo new “postName”</td>
<td>新建文章，hexo n</td>
</tr>
<tr>
<td>hexo new page “pageName”</td>
<td>#新建页面</td>
</tr>
<tr>
<td>hexo generate</td>
<td>生成静态页面至public目录，hexo g</td>
</tr>
<tr>
<td>hexo server</td>
<td>开启预览访问端口（默认端口4000，’ctrl + c’关闭server）</td>
</tr>
<tr>
<td>hexo deploy</td>
<td>hexo d</td>
</tr>
<tr>
<td>hexo s -g</td>
<td>生成并本地预览</td>
</tr>
</tbody></table>
<h1 id="markdwon使用技巧"><a href="#markdwon使用技巧" class="headerlink" title="markdwon使用技巧"></a>markdwon使用技巧<a href="#markdwon使用技巧" class="header-anchor">#</a></h1><p>更多markdwon技巧可以移步至我的<a href="https://idolcoder.gitee.io/quickshortkey/#/typora">Typora知识Wiki</a></p>
<h2 id="缩放图片四种种技巧"><a href="#缩放图片四种种技巧" class="headerlink" title="缩放图片四种种技巧"></a>缩放图片四种种技巧<a href="#缩放图片四种种技巧" class="header-anchor">#</a></h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">&lt;img src=&quot;&quot; width=&quot;50%&quot; height=&quot;50%&quot;&gt;</span><br><span class="line">![test image size](url)&#123;:class=&quot;img-responsive&quot;&#125;</span><br><span class="line">![test image size](url)&#123;:height=&quot;50%&quot; width=&quot;50%&quot;&#125;</span><br><span class="line">![test image size](url)&#123;:height=&quot;100px&quot; width=&quot;400px&quot;&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="设置字体颜色"><a href="#设置字体颜色" class="headerlink" title="设置字体颜色"></a>设置字体颜色<a href="#设置字体颜色" class="header-anchor">#</a></h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="HTML"><figure class="iseeu highlight /html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">style</span>=<span class="string">&quot;color:green&quot;</span>&gt;</span>**数学日记**<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
<h2 id="使用数学公式"><a href="#使用数学公式" class="headerlink" title="使用数学公式"></a>使用数学公式<a href="#使用数学公式" class="header-anchor">#</a></h2><table>
<thead>
<tr>
<th>文档名称</th>
<th>优点</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://katex.org/docs/supported.html#accents">KaTeX公式文档</a></td>
<td>网站清新，简洁，数学公式非常全，导航详细</td>
<td></td>
</tr>
<tr>
<td>CTEX公式文档</td>
<td>导航较为隐晦，除了数学公式外还有其他公式</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="markdown设置表格宽度"><a href="#markdown设置表格宽度" class="headerlink" title="markdown设置表格宽度"></a>markdown设置表格宽度<a href="#markdown设置表格宽度" class="header-anchor">#</a></h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CSS"><figure class="iseeu highlight /css"><table><tr><td class="code"><pre><span class="line">| a | b | d |</span><br><span class="line">|---|---|---|</span><br><span class="line">| 1 | &lt;div style=&quot;width: 150pt&quot;&gt;very very very very very lonng long long long long text&lt;/div&gt;| 3 |</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;div style=&quot;width: 150pt&quot;&gt;  &lt;div style=&quot;width: 50%&quot;&gt;  ..</span><br></pre></td></tr></table></figure>


<h2 id="markdown如何换行"><a href="#markdown如何换行" class="headerlink" title="markdown如何换行"></a>markdown如何换行<a href="#markdown如何换行" class="header-anchor">#</a></h2><p>markdown表格内换行需要使用<code>&lt;br&gt;</code></p>
<h2 id="markdown如何开启数学公式"><a href="#markdown如何开启数学公式" class="headerlink" title="markdown如何开启数学公式"></a>markdown如何开启数学公式<a href="#markdown如何开启数学公式" class="header-anchor">#</a></h2><p><a href="https://www.dazhuanlan.com/2020/02/29/5e59eaf910c97/">1.开启行内公式模块，默认是关闭的。</a></p>
<p>文件—&gt;偏好设置—&gt;Markdown,勾选内联公式，重启typora。</p>
<p>使用方式参考latext文档</p>
<h2 id="markdown设置字体颜色"><a href="#markdown设置字体颜色" class="headerlink" title="markdown设置字体颜色"></a>markdown设置字体颜色<a href="#markdown设置字体颜色" class="header-anchor">#</a></h2><p><strong>HTML方式：</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">　&lt;font color=&#x27;red&#x27;&gt; text &lt;/font&gt;</span><br></pre></td></tr></table></figure>
<p>效果：　<font color="red"> text </font></p>
<p><strong>KaTex/MathJax方式:</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">$\color&#123;red&#125;&#123;红色字&#125;$</span><br></pre></td></tr></table></figure>
<p>效果：$\color{red}{红色字}$</p>
<h2 id="markdown如何等比缩放图片"><a href="#markdown如何等比缩放图片" class="headerlink" title="markdown如何等比缩放图片"></a>markdown如何等比缩放图片<a href="#markdown如何等比缩放图片" class="header-anchor">#</a></h2><p>在img标签里面只设置宽，不设置高，图片就会等比例缩放。</p>
<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题<a href="#常见问题" class="header-anchor">#</a></h1><h2 id="如何搭建一个wiki页面"><a href="#如何搭建一个wiki页面" class="headerlink" title="如何搭建一个wiki页面"></a>如何搭建一个wiki页面<a href="#如何搭建一个wiki页面" class="header-anchor">#</a></h2><p>参考我的<a href="https://idolcoder.gitee.io/quickshortkey/#/">如何做一篇wiki</a></p>
<h2 id="码云部署hexo站点-css样式不显示"><a href="#码云部署hexo站点-css样式不显示？" class="headerlink" title="码云部署hexo站点 css样式不显示？"></a><strong>码云部署hexo站点 css样式不显示？</strong><a href="#码云部署hexo站点-css样式不显示" class="header-anchor">#</a></h2><p>原因：仓库地址与个性地址url不一致<br>解决：修改_config.yml<br>    <div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line">    url: https://ipvb.gitee.io/blog</span><br><span class="line">    root: /blog</span><br><span class="line">    ​```</span><br><span class="line"></span><br><span class="line">其他码云部署的问题参考[这里](https://gitee.com/help/articles/4136#article-header3)</span><br><span class="line"></span><br><span class="line">## hexo如何缩放图片</span><br><span class="line"></span><br><span class="line">`<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;&quot;</span> <span class="attr">width</span>=<span class="string">&quot;50%&quot;</span> <span class="attr">height</span>=<span class="string">&quot;50%&quot;</span>&gt;</span>`</span><br><span class="line"></span><br><span class="line">## hexo如何安装主题</span><br><span class="line"></span><br><span class="line">1. 找到合适的主题列表，推荐以下2个：</span><br><span class="line"></span><br><span class="line">   [有哪些好看的 Hexo 主题？](https://www.zhihu.com/question/24422335)</span><br><span class="line"></span><br><span class="line">   [hexo.thems](https://hexo.io/themes/)</span><br><span class="line"></span><br><span class="line">2. 安装主题至根目录，例如找到next主题，将其克隆岛根目录/thesms/next下</span><br><span class="line"></span><br><span class="line">    ```js</span><br><span class="line">     git clone https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure></div><br>3. 阅读<a href="https://github.com/iissnan/hexo-theme-next">next文档</a></p>
<pre><code>1. 引用主题：在config.yml中修改主题名称：`theme: next`
2. 发布时遇到 bug`&#123;% extends '_layout.swig' %&#125;`；输入指令解决：`npm i hexo-renderer-swig`
</code></pre>
<h2 id="hexo不显示二级目录"><a href="#hexo不显示二级目录？" class="headerlink" title="hexo不显示二级目录？"></a>hexo不显示二级目录？<a href="#hexo不显示二级目录" class="header-anchor">#</a></h2><p>原因：hexo解析目录是按照1级，1级下面找2级，2级下面找3级的顺序查找目录的，如果只有2级，没有1级，是会显示错误的。</p>
<p>解决：先写1级标题，再写2级标题，先写大标题，再写小标题。</p>
<p>原因：markdown解析问题</p>
<p>解决：参考<a href="https://www.cnblogs.com/Createsequence/p/14150758.html">渲染错误解决和超链接乱码解决方案</a>、参考<a href="https://convivae.top/posts/hexo-bo-ke-cai-keng/#%E6%96%B9%E6%B3%95-2">markdown-it的bug</a></p>
<h2 id="hexo点击二级目录不跳转"><a href="#hexo点击二级目录不跳转" class="headerlink" title="hexo点击二级目录不跳转?"></a>hexo点击二级目录不跳转?<a href="#hexo点击二级目录不跳转" class="header-anchor">#</a></h2><p>原因：markdown解析问题</p>
<p>解决：参考<a href="https://www.cnblogs.com/Createsequence/p/14150758.html">渲染错误解决和超链接乱码解决方案</a>、参考<a href="https://convivae.top/posts/hexo-bo-ke-cai-keng/#%E6%96%B9%E6%B3%95-2">markdown-it的bug</a></p>
<h2 id="hexo自动发布图片至七牛云"><a href="#hexo自动发布图片至七牛云？" class="headerlink" title="hexo自动发布图片至七牛云？"></a>hexo自动发布图片至七牛云？<a href="#hexo自动发布图片至七牛云" class="header-anchor">#</a></h2><p>阿里云-域名管理-解析设置-添加记录-设置以下参数</p>
<table>
<thead>
<tr>
<th>键</th>
<th>值</th>
</tr>
</thead>
<tbody><tr>
<td>记录类型</td>
<td>CNAME</td>
</tr>
<tr>
<td>主机记录</td>
<td>如cdn</td>
</tr>
<tr>
<td>记录值</td>
<td>从七牛云后台获取</td>
</tr>
</tbody></table>
<p>七牛云-域名管理-加速域名设置值如cdn.yangchaofan.cn；cdn就是主机记录值；创建完毕后，获得一个CNAME值，记住该值，填写至阿里云域名记录值中。</p>
<p><a href="https://portal.qiniu.com/kodo/overview"></a></p>
<h2 id="next如何打开百度分享"><a href="#next如何打开百度分享？" class="headerlink" title="next如何打开百度分享？"></a>next如何打开百度分享？<a href="#next如何打开百度分享" class="header-anchor">#</a></h2><p>主题文件中插入以下代码</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line">baidushare:</span><br><span class="line">  type: button</span><br><span class="line">  baidushare: <span class="literal">true</span></span><br></pre></td></tr></table></figure></div>
<h2 id="next如何添加搜索功能"><a href="#next如何添加搜索功能？" class="headerlink" title="next如何添加搜索功能？"></a>next如何添加搜索功能？<a href="#next如何添加搜索功能" class="header-anchor">#</a></h2><p>安装插件</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure></div>
<p>编辑全局配置</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: <span class="number">10000</span></span><br></pre></td></tr></table></figure></div>
<p>编辑主题配置</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">local_search:</span><br><span class="line">  enable: <span class="literal">true</span></span><br></pre></td></tr></table></figure></div>
<h2 id="next如何添加评论功能"><a href="#next如何添加评论功能？" class="headerlink" title="next如何添加评论功能？"></a>next如何添加评论功能？<a href="#next如何添加评论功能" class="header-anchor">#</a></h2><p>翻墙打开<a href="https://livere.com/">来比力官网</a>，注册填写域名，copy代码块中的data-uid</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line">&lt;!-- 来必力City版安装代码 --&gt;</span><br><span class="line">&lt;div id=<span class="string">&quot;lv-container&quot;</span> data-id=<span class="string">&quot;city&quot;</span> data-uid=<span class="string">&quot;这里是id&quot;</span>&gt;</span><br><span class="line">	&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">   (<span class="function"><span class="keyword">function</span>(<span class="params">d, s</span>) </span>&#123;</span><br><span class="line">       <span class="keyword">var</span> j, e = d.getElementsByTagName(s)[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">typeof</span> LivereTower === <span class="string">&#x27;function&#x27;</span>) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line"></span><br><span class="line">       j = d.createElement(s);</span><br><span class="line">       j.src = <span class="string">&#x27;https://cdn-city.livere.com/js/embed.dist.js&#x27;</span>;</span><br><span class="line">       j.async = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">       e.parentNode.insertBefore(j, e);</span><br><span class="line">   &#125;)(<span class="built_in">document</span>, <span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">	&lt;/script&gt;</span><br><span class="line">&lt;noscript&gt; 为正常使用来必力评论功能请激活JavaScript&lt;/noscript&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;!-- City版安装代码已完成 --&gt;</span><br></pre></td></tr></table></figure></div>
<p>配置完成后可以在评论<a href="https://livere.com/insight/communite">后台</a>管理评论内容。</p>
<h2 id="next如何安装valine"><a href="#next如何安装valine" class="headerlink" title="next如何安装valine"></a>next如何安装valine<a href="#next如何安装valine" class="header-anchor">#</a></h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">npm install valine --save</span><br></pre></td></tr></table></figure></div>
<h2 id="next配置gitment"><a href="#next配置gitment" class="headerlink" title="next配置gitment"></a>next配置gitment<a href="#next配置gitment" class="header-anchor">#</a></h2><p><a href="https://www.jianshu.com/p/d3ce2dd7900f?utm_campaign=maleskine&utm_content=note&utm_medium=seo_notes&utm_source=recommendation">Hexo 博客接入 Gitment 评论系统踩坑</a></p>
<p><a href="https://github.com/imsun/gitment/issues/16#">认证重定向错误</a></p>
<h2 id="next如何添加置顶功能"><a href="#next如何添加置顶功能？" class="headerlink" title="next如何添加置顶功能？"></a>next如何添加置顶功能？<a href="#next如何添加置顶功能" class="header-anchor">#</a></h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm uninstall hexo-generator-index --save</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install hexo-generator-index-pin-top --save</span></span><br></pre></td></tr></table></figure></div>
<p>文章插入top属性，top数值按大小倒序排序</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">title: 置顶</span><br><span class="line">date: 2019-09-09 09:09:09</span><br><span class="line">top: true</span><br><span class="line">top: 1</span><br></pre></td></tr></table></figure></div>
<p>设置置顶样式：</p>
<p>打开：<code>/blog/themes/next/layout/_macro</code>目录下的<code>post.swig</code>文件，定位到<code>&lt;div class=&quot;post-meta&quot;&gt;</code>标签下，插入如下代码：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="HTML"><figure class="iseeu highlight /html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;post-meta&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-time&quot;</span>&gt;</span></span><br><span class="line">在此之下插入代码，包含在 span块内        </span><br><span class="line">          &#123;% if post.top %&#125;</span><br><span class="line">            <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-thumb-tack&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">7D26CD</span>&gt;</span>置顶<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-divider&quot;</span>&gt;</span>|<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">          &#123;% endif %&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="next如何跳转至站内相对路径"><a href="#next如何跳转至站内相对路径？" class="headerlink" title="next如何跳转至站内相对路径？"></a>next如何跳转至站内相对路径？<a href="#next如何跳转至站内相对路径" class="header-anchor">#</a></h2><h2 id="hexo如何创建模板"><a href="#hexo如何创建模板？" class="headerlink" title="hexo如何创建模板？"></a>hexo如何创建模板？<a href="#hexo如何创建模板" class="header-anchor">#</a></h2><p><strong>模板有什么用？</strong></p>
<p>模板可以当做一类文章的格式，按照指定格式批量创建文章，减少重复内容的编写工作。如创建读书笔记模板、创建一类任务计划模板。</p>
<p><strong>创建模板步骤？</strong></p>
<ul>
<li>新建md文件，文件头插入以下内容，并将文件移动至<code>根目录/scaffolds</code> 下</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">title: 《超效学习方法解码》心得</span><br><span class="line">date: <span class="number">2021</span>-<span class="number">02</span>-<span class="number">17</span> <span class="number">11</span>:<span class="number">37</span>:<span class="number">23</span></span><br><span class="line">entitle:</span><br><span class="line">tags:</span><br><span class="line">categories:</span><br></pre></td></tr></table></figure></div>
<ul>
<li>使用指令读取模板创建文章</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> hexo new 模板名称 <span class="string">&quot;title&quot;</span></span></span><br><span class="line">hexo new book-note-model &quot;《超效学习方法解码》心得&quot;</span><br></pre></td></tr></table></figure></div>
<h2 id="hexo如何创建草稿"><a href="#hexo如何创建草稿？" class="headerlink" title="hexo如何创建草稿？"></a>hexo如何创建草稿？<a href="#hexo如何创建草稿" class="header-anchor">#</a></h2><p><strong>草稿的用途？</strong></p>
<p>文章写到一半，未完成，并不想发布。可以向存到指定位置。hexo提供了_drafts目录存放草稿。</p>
<p><strong>创建草稿的步骤？</strong></p>
<ul>
<li>​创建草稿</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> hexo new draft <span class="string">&quot;title&quot;</span></span></span><br><span class="line">hexo new draft &quot;Android性能优化百问百答&quot;</span><br><span class="line">INFO  Validating config</span><br><span class="line">INFO  Created: </span><br><span class="line">D:\workspace\gitblog\hexoblogcode\source\_drafts\Android性能优化百问百答.md</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<ul>
<li>发布草稿</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> hexo publish 布局类型 <span class="string">&quot;title&quot;</span></span></span><br><span class="line">hexo publish draft &quot;Android性能优化百问百答&quot;</span><br><span class="line">INFO  Validating config</span><br><span class="line">INFO  Published: D:\workspace\gitblog\hexoblogcode\source\_posts\Android性能优化百问百答.md</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<h2 id="next文章自适应屏幕宽度"><a href="#next文章自适应屏幕宽度" class="headerlink" title="next文章自适应屏幕宽度"></a>next文章自适应屏幕宽度<a href="#next文章自适应屏幕宽度" class="header-anchor">#</a></h2><p><code>\themes\next\source/css/_schemes/Picses/_layout.styl</code>在文件末尾添加代码</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CSS"><figure class="iseeu highlight /css"><table><tr><td class="code"><pre><span class="line">// 以下为新增代码！！修改post宽度</span><br><span class="line"><span class="selector-tag">header</span>&#123; <span class="attribute">width</span>: <span class="number">80%</span> <span class="meta">!important</span>; &#125;</span><br><span class="line"><span class="selector-tag">header</span><span class="selector-class">.post-header</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: auto <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-class">.main-inner</span> &#123; <span class="attribute">width</span>: <span class="number">80%</span>; &#125;</span><br><span class="line"><span class="selector-class">.content-wrap</span> &#123; <span class="attribute">width</span>: <span class="built_in">calc</span>(<span class="number">100%</span> - <span class="number">260px</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.header</span> &#123;</span><br><span class="line">  +tablet() &#123;</span><br><span class="line">    <span class="attribute">width</span>: auto <span class="meta">!important</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  +mobile() &#123;</span><br><span class="line">    <span class="attribute">width</span>: auto <span class="meta">!important</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-class">.main-inner</span> &#123;</span><br><span class="line">  +tablet() &#123;</span><br><span class="line">    <span class="attribute">width</span>: auto <span class="meta">!important</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  +mobile() &#123;</span><br><span class="line">    <span class="attribute">width</span>: auto <span class="meta">!important</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.content-wrap</span> &#123;</span><br><span class="line">  +tablet() &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span> <span class="meta">!important</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  +mobile() &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span> <span class="meta">!important</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<h2 id="next添加头像"><a href="#next添加头像" class="headerlink" title="next添加头像"></a>next添加头像<a href="#next添加头像" class="header-anchor">#</a></h2><p>打开themes/next/_config.yml</p>
<p>打开并放入头像/themes/next/source/images/</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CSS"><figure class="iseeu highlight /css"><table><tr><td class="code"><pre><span class="line">avatar: /images/avatar_2.gif</span><br></pre></td></tr></table></figure></div>
<h2 id="next统计字数"><a href="#next统计字数" class="headerlink" title="next统计字数"></a>next统计字数<a href="#next统计字数" class="header-anchor">#</a></h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">pm i --save hexo-wordcount</span><br></pre></td></tr></table></figure></div>
<p>在站点配置文件添加如下配置</p>
<pre><code># Dependencies: https://github.com/willin/hexo-wordcount
post_wordcount:
  item_text: true
  wordcount: true         #文章字数统计
  min2read: true          #文阅读时长
  totalcount: false       
  separated_meta: true
</code></pre>
<p>在NexT主题配置文件添加如下配置（NexT主题已支持该插件，有的话无需再添加）</p>
<pre><code># Dependencies: https://github.com/willin/hexo-wordcount
post_wordcount:
  item_text: true
  wordcount: true         #文章字数统计
  min2read: true          #文阅读时长
  totalcount: false       
  separated_meta: true
</code></pre>
<h2 id="next不蒜子失效问题"><a href="#next不蒜子失效问题" class="headerlink" title="next不蒜子失效问题"></a>next不蒜子失效问题<a href="#next不蒜子失效问题" class="header-anchor">#</a></h2><p>hexo-theme-next主题中使用了dn-lbstatics.qbox.me域名的文件位置为：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line">themes\next\layout\_third-party\analytics\busuanzi-counter.swi</span><br></pre></td></tr></table></figure></div>
<p>找到如下代码：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line">&lt;script <span class="keyword">async</span> src=<span class="string">&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></div>

<p>修改为：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line">&lt;script <span class="keyword">async</span> src=<span class="string">&quot;https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></div>


<h1 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明<a href="#使用说明" class="header-anchor">#</a></h1><ol>
<li> 定时使用typora编写markdown文章：编写markdown文件</li>
<li> 导出成html，发布在hexo：使用hexo s</li>
<li> hexo推送到码云指定仓库地址：hexo d</li>
<li> 将阿里云的域名解析至码云仓库地址：配置域名解析</li>
<li> 通过公网域名访问我的网站</li>
</ol>
<h1 id="支持"><a href="#支持" class="headerlink" title="支持"></a>支持<a href="#支持" class="header-anchor">#</a></h1><ol>
<li> <a href="https://support.typora.io/Resize-Image/">typora使用手册</a></li>
<li> <a href="https://gitee.com/help">Gitee 官方提供的使用手册</a></li>
<li> <a href="https://portal.qiniu.com/kodo/overview">七牛云</a> </li>
<li> <a href="https://homenew.console.aliyun.com/home/dashboard/ProductAndService">阿里云</a> </li>
<li> <a href="https://hexo.io/zh-cn/docs">hexo中文文档</a></li>
<li> <a href="http://theme-next.iissnan.com/third-party-services.html#comment-system">next中文文档</a></li>
<li> <a href="https://console.leancloud.cn/apps">leanclound统计云</a></li>
<li> <a href="https://livere.com/insight/communite">来比力评论云</a></li>
<li> <a href="https://www.kuaizhan.com/">快站畅言</a></li>
</ol>
<link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>杂谈</category>
        <category>日记</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>2015-2021学习计划</title>
    <url>/blog//2015/08/learing-plan/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="2015-2021学习计划及小结"><a href="#2015-2021学习计划及小结" class="headerlink" title="2015-2021学习计划及小结"></a>2015-2021学习计划及小结<a href="#2015-2021学习计划及小结" class="header-anchor">#</a></h1><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述<a href="#概述" class="header-anchor">#</a></h1><p>这里存放2015年-2021年的学习内容，包括已经学习的，正在学习的，</p>
<p>内容为：音频课程、视频课程、电子书、实体书、专栏课程、认证课程等。</p>
<p>内容来源自kindle、知乎、极客学院、慕课网、阿里云大学、光环国际、黑马培训、拉钩培训、三节课培训等</p>
<p>个人网站到期，很多资料未及时存档，只能根据自己的历史笔记一点点更新了。</p>
<p>每一条内容为：完成状态+任务名称+任务完成详情</p>
<p>已完成的任务显示如下，完成态+任务名称+删除线+点击跳转至文章总结或项目总结</p>
<ul>
<li><input checked disabled type="checkbox"> <del><a href>任务名称</a></del></li>
</ul>
<p>未完成的任务显示为，未完成态+任务名称</p>
<ul>
<li><input disabled type="checkbox"> 任务名称</li>
</ul>
<a id="more"></a>



<h1 id="2021"><a href="#2021" class="headerlink" title="2021"></a>2021<a href="#2021" class="header-anchor">#</a></h1><p>文章计划</p>
<ul>
<li><input disabled type="checkbox"> 《Android相机全解》</li>
<li><input disabled type="checkbox"> 编程WIki-计算机基础</li>
<li><input disabled type="checkbox"> 编程WIki-编程基础-C</li>
<li><input disabled type="checkbox"> <a href="http://idolcoder.gitee.io/cs-programming-knowledge/#/newnotes/Java">编程WIki-编程基础-Java</a></li>
<li><input disabled type="checkbox"> <a href="http://idolcoder.gitee.io/cs-programming-knowledge/#/newnotes/java/jvm">编程WIki-编程基础-JVM</a></li>
<li><input disabled type="checkbox"> <a href="http://idolcoder.gitee.io/cs-programming-knowledge/#/newnotes/android">编程WIki-编程基础-Android资深进阶指南</a></li>
<li><input disabled type="checkbox"> <a href="http://idolcoder.gitee.io/cs-programming-knowledge/#/newnotes/leetcode-solution">编程Wiki-算法-leetcode题解</a></li>
<li><input checked disabled type="checkbox"> <a href="http://idolcoder.gitee.io/blog/2021/02/android-bugfree-three-lines/"><del>《异常分析三剑客》</del></a></li>
<li><input checked disabled type="checkbox"> <a href="http://idolcoder.gitee.io/quickshortkey/#/git"><del>快捷键Wiki-《GIt全解——从配置文件到指令执行》</del></a></li>
<li><input checked disabled type="checkbox"> <a href="http://idolcoder.gitee.io/quickshortkey/#/adb"><del>快捷键Wiki-《ADB：开发及自测常用指令》</del></a></li>
<li><input disabled type="checkbox"> 《Activity 启动模式快问秒答》，SingleTop的坑，SingleInstance的坑，20种flags全解析，FLAG_ACTIVITY_NEW_TASK结合FLAG_ACTIVITY_MULTIPLE_TASK使用的坑</li>
</ul>
<p>修改文章  </p>
<ul>
<li><input disabled type="checkbox"> ​《BugFree三剑客》更新所有Log文件的字段参数及含义，如trace.txt\blockcanary的log\mtk的log\lecanary的log\Hrof日志\Systrace日志\TraceView日志</li>
</ul>
<p>学习计划</p>
<ul>
<li><input disabled type="checkbox"> 《数学思想概论》5辑</li>
<li><input checked disabled type="checkbox"> 《架构师修炼之道》</li>
<li><input disabled type="checkbox"> 《划归与归纳》</li>
<li><input disabled type="checkbox"> 《结构思考力用思维导图》</li>
<li><input disabled type="checkbox"> 《情报分析合集》</li>
<li><input checked disabled type="checkbox"> 《程序员三门课》</li>
<li><input checked disabled type="checkbox"> 《UML精粹》</li>
<li><input checked disabled type="checkbox"> <del>《如何高效学习》</del></li>
</ul>
<ul>
<li><input checked disabled type="checkbox"> 《极客时间-朱云技术管理课》</li>
<li><input checked disabled type="checkbox"> 《软件测试技术与模板》</li>
<li><input checked disabled type="checkbox"> <del>《超效学方法解码》</del></li>
<li><input checked disabled type="checkbox"> <del>《学习革命的解读》</del></li>
<li><input checked disabled type="checkbox"> 《改变你一生的学习计划》</li>
<li><input checked disabled type="checkbox"> 《当代学习理论十三讲》</li>
<li><input checked disabled type="checkbox"> 《新学习革命》</li>
<li><input checked disabled type="checkbox"> 《思维导图的运用》</li>
<li><input checked disabled type="checkbox"> 《7s倍速学习法》</li>
<li><input checked disabled type="checkbox"> 《攻克7大学习问题》</li>
<li><input checked disabled type="checkbox"> <del>《高效学习方法全集》</del></li>
</ul>
<h1 id="2020"><a href="#2020" class="headerlink" title="2020"></a>2020<a href="#2020" class="header-anchor">#</a></h1><p>存档资料恢复中</p>
<ul>
<li><input checked disabled type="checkbox"> 《九章算法2020》</li>
<li><input checked disabled type="checkbox"> 《得到：有效管理健康》</li>
<li><input checked disabled type="checkbox"> 《得到：大脑健康课》</li>
<li><input checked disabled type="checkbox"> 《Android自定义控件实战》</li>
<li><input checked disabled type="checkbox"> 《拉勾网：Android34讲》</li>
<li><input checked disabled type="checkbox"> 《Android进阶解密》</li>
<li><input checked disabled type="checkbox"> 《Android高效进阶数据AI》</li>
<li><input checked disabled type="checkbox"> 《极客时间-Java核心36讲》</li>
<li><input checked disabled type="checkbox"> 《极客时间-JVM原理》</li>
<li><input checked disabled type="checkbox"> 《慕课：Gradle3.0自动化项目构建技术精讲+实战》</li>
<li><input checked disabled type="checkbox"> 《慕课：Android代码混淆与加固技术》</li>
<li><input checked disabled type="checkbox"> 《慕课：Android图案解锁》</li>
<li><input checked disabled type="checkbox"> 《慕课：自定义实现日历控件》</li>
<li><input checked disabled type="checkbox"> 《慕课：Android高级特效-索引》</li>
<li><input checked disabled type="checkbox"> 《慕课：Android美女拼图小游戏》</li>
<li><input checked disabled type="checkbox"> 《慕课：打造个性的图片预览与多点触控》</li>
<li><input checked disabled type="checkbox"> 《慕课：Android电商活动中的刮刮卡》</li>
<li><input checked disabled type="checkbox"> 《慕课：Android自定义任意层级树形控件》</li>
</ul>
<h1 id="2015-2019"><a href="#2015-2019" class="headerlink" title="2015-2019"></a>2015-2019<a href="#2015-2019" class="header-anchor">#</a></h1><p>存档资料恢复中</p>
<ul>
<li><input checked disabled type="checkbox"> 《kindle：论语》</li>
<li><input checked disabled type="checkbox"> 《Java疯狂讲义》</li>
<li><input checked disabled type="checkbox"> 《Effice java》</li>
<li><input checked disabled type="checkbox"> 《重构》</li>
<li><input checked disabled type="checkbox"> 《代码整洁之道》</li>
<li><input checked disabled type="checkbox"> 《Android103例》</li>
<li><input checked disabled type="checkbox"> 《AndroidAPP研发录》</li>
<li><input checked disabled type="checkbox"> 《Android深入理解卷I-III》</li>
<li><input checked disabled type="checkbox"> 《Android源码设计模式》</li>
<li><input checked disabled type="checkbox"> 《Android埋点解决方案》</li>
<li><input checked disabled type="checkbox"> 《大话设计模式》</li>
<li><input checked disabled type="checkbox"> 《Android应用性能优化最佳实践》</li>
<li><input checked disabled type="checkbox"> 《Android开发高手课》</li>
<li><input checked disabled type="checkbox"> 《慕课：java设计模式Debug》</li>
<li><input checked disabled type="checkbox"> 《慕课：音视频WebRTC实时互动直播技术入门与实战》</li>
<li><input checked disabled type="checkbox"> 《慕课：《从0打造音视频直播系统》》</li>
<li><input checked disabled type="checkbox"> 《慕课：Top团队大牛带你玩转Android性能分析与优化》</li>
<li><input checked disabled type="checkbox"> 《慕课：BAT大牛 带你深度剖析Android 10大开源框架》</li>
<li><input checked disabled type="checkbox"> 《慕课：Jetpack全组件实战 开发短视频应用App》</li>
<li><input checked disabled type="checkbox"> 《慕课：主流开发方案实战京东移动端APP》</li>
<li><input checked disabled type="checkbox"> 《慕课：企业级Android应用架构设计与开发》</li>
<li><input checked disabled type="checkbox"> 《慕课：Android应用发展趋势必备武器 热修复与插件化》</li>
<li><input checked disabled type="checkbox"> 《慕课：剖析Framework面试 冲击Android高级职位》</li>
<li><input checked disabled type="checkbox"> 《慕课：Kotlin系统入门与进阶》</li>
<li><input checked disabled type="checkbox"> 《慕课：Java并发编程与高并发解决方案》</li>
<li><input checked disabled type="checkbox"> 《慕课：Android实现跨进程通信》</li>
<li><input checked disabled type="checkbox"> 《慕课：Android网络安全之加解密》</li>
<li><input checked disabled type="checkbox"> 《Socket网络编程进阶与实战》</li>
</ul>
<link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>规划</category>
        <category>个人教育</category>
      </categories>
      <tags>
        <tag>个人教育</tag>
      </tags>
  </entry>
  <entry>
    <title>职业稳定性杂谈</title>
    <url>/blog//2021/04/Career-stability-experience/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>&lt;%- toc(page.content) %&gt;</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言<a href="#前言" class="header-anchor">#</a></h1><p>之前在知乎写过一篇回答，<a href="https://www.zhihu.com/question/308110736/answer/628764663">《为什么都在说 90 后的辞职率高？》</a>，纯理性分析获得了300赞。今日在公众号上看到心理学家刘向明教授写的一篇名为<a href="https://mp.weixin.qq.com/s/ZyEWV1g_UzXODkViyFdNlw">《社会招聘，怎样测试稳定性？</a>的文章，让我对职业稳定性有了更深的理解。</p>
<p>先看看我之前的回答，再来看我的新感悟吧。</p>
<a id="more"></a>

<h1 id="price-muller辞职模型"><a href="#Price-Muller辞职模型" class="headerlink" title="Price-Muller辞职模型"></a>Price-Muller辞职模型<a href="#price-muller辞职模型" class="header-anchor">#</a></h1><blockquote>
<p>半年交接了近二十位90后离职,跟每个人也都谈过心，查了一些知网论文，得到以下见解。</p>
</blockquote>
<p>根据国外著名的“Price-Muller辞职模型”<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[为什么都在说 90 后的辞职率高？](https://www.zhihu.com/question/308110736/answer/628764663)
">[1]</span></a></sup>，我套用一句歌词来解释辞职者的内心世界：<br>“我载着希望而来，却攒够失望离开”</p>
<p><strong>Price-Muller模型</strong></p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://pic1.zhimg.com/80/v2-80d4c0415d689d0c61ff3276ae45c779_720w.jpg?source=1940ef5c" width="60%" alt>
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">
      图1-+号表示增加离职动机；-号表示减弱离职动机
      </div>
</center>

<p>1977年Price发布的第一版Price—Muller理论模型，基于社会学、心理学、经济学三个独立领域经典的“离职模型”研究成果。<br>在这以后Price—Muller模型发生了多次修订。上图所示就是Price最新的研究成果。</p>
<div class="note primary"><p>Price-Muller模型通过大量实验证明，总结并提出了<strong>4</strong>种影响离职的因素，</p></div>
<p><strong>1.环境因素（社会学、经济学）</strong></p>
<ul>
<li>亲属责任：保持当前留职状态，有助于完成亲属责任。因此亲属责任会减弱离职动机。</li>
<li>机会：机会与市场对劳动力的需求有关。随着经济市场繁荣发展，外部机会更多，会使当前工作的吸引力下降，增强离职的动机。</li>
</ul>
<p><strong>2.个体因素（心理学、经济学）</strong></p>
<ul>
<li>   一般培训：企业为了提高生产率，发起的个人自费参与的培训。一般培训的增多，会增加离职动机。</li>
<li>   工作参与度：工作参与度高的个人，往往工作努力，因此会获得更多回报，会减弱离职的动机。</li>
<li>  积极/消极情感：积极情感减弱离职动机；消极情感增加离职动机。</li>
</ul>
<p><strong>3.组织结构因素（社会学、心理学）</strong></p>
<ul>
<li>  自主性：个人支配自己工作权力越大，离职的动机越小。诸如总监让职场新人端茶倒水。会增加离职动机。</li>
<li>   公平性：个人会比对自己与组织中其他人薪酬，以判断是否公平。如今的个人会比对自己与整个市场同岗位薪酬。个人薪酬低于组织或市场同岗位薪酬，个人认为公平性低，增加离职动机。</li>
<li>工作压力：工作压力来源于四个维度：<br> ①资源匮乏<br> ②角色模糊<br> ③角色冲突<br> ④工作负荷<br> 工作压力增加，会增强离职的动机。</li>
<li>  薪酬：薪酬是重要的离职决定因素。薪酬包括了现金等各种福利。企业组织开出的薪酬低下，会增加个人离职动机。</li>
<li>  晋升机会：企业组织内部常见的垂直运动——晋升。企业组织晋升机会的存在，会激励个人情感，减弱离职动机。</li>
<li>  工作重复性（常规性）：有实验证明，工作被重复的程度，对离职有显著的影响。</li>
<li> 社会支持：上司、同事、亲属对工作的支持程度，对离职有显著影响。</li>
</ul>
<p><strong>4.过程因素（经济学）：</strong></p>
<ul>
<li>   工作满意度：个人对工作满意度是一种情绪累加结果，同时也是离职的决定性因素。工作满意度受前面三类型因素影响，包括环境因素、个体因素、组织结构因素。个人对工作满意度提升，会减弱离职动机。</li>
<li>   组织承诺度：个人对企业组织目标和价值观的信任程度，对离职动机有显著影响。</li>
<li>   工作寻找行为（职业搜寻理论）：失业是找高薪工作的一种投资。</li>
<li>   离职意图：积极主动离职、消极被动离职。</li>
</ul>
<div class="note warning"><p>如何理解离职模模型?</p></div>


<p>Priece—Muller模型有一个基础假设前提，如图</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://pic2.zhimg.com/80/v2-7ccab5b5f3b1179eafdd0f5b39376cec_720w.jpg?source=1940ef5c" width="60%" alt>
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">
      图2-假设个人是带有一些期望进入企业组织。
      </div>
</center>


<p>Priece-Muller理论模型提到的四个因素，都影响个人的期望。期望得不到满足，个人对组织的依附感降低，会增强个人离职动机，离职动机积累到一定数值，最终会促使个人主动离职。</p>
<p><strong>回到正题</strong></p>
<p>“90后为什么离职率高”？是一个开放性问题。<br>通过Price-Muller模型，我们可以试着将问题具象成<br>“与60后相比，相同的离职因素，为什么在90后身上产生了更显著的影响”<br>从Priece-Muller模型来看，可知有四类因素影响个体离职，分别是环境、个体、组织结构、工作过程。</p>
<p><strong>1.环境因素：</strong><br>环境因素，可从亲属责任说起：<br>结论：<br>根据笔者经验，60后普遍多兄弟姐妹，其中长子、长女的“亲属责任”更重，在后大饥荒时期、后大跃进时期的影响下，负责抚养弟妹的学费、替父母分担解决全家温饱，身上的“亲属责任”压力堪比泰山。<br>兄弟姐妹，早年成家后的妻女，繁重的亲属责任显著减弱了60后离职动机。<br>90后多为独生子女，其父母若无特殊病痛，皆可自食其力。相比60后，90后亲属责任压力偏小，90后的离职动机受亲属责任约束较小。</p>
<p><strong>2.个体因素：</strong><br>个体因素从工作参与度高低、消极/积极情感展开讨论：<br><strong>60后结论：</strong><br><strong>受时代背景影响</strong>，无论是<strong>工作参与度因素</strong>还是<strong>消极情感因素</strong>对60后离职动机<strong>影响微弱</strong>。<br>如包分配、大锅饭，个体因素中的工作参与度因素对60后离职动机影响微弱。<br>如上山下乡，务农养殖，在当时市场劳动背景下，个人工作中即使产生消极情感，也必须坚强克服。</p>
<p>可参考基于当时背景下创作的歌词：<br>“愿做xx的螺丝钉，艰苦朴素永不忘，集体主义思想放光芒”。<br>“石油滚滚流，千里飘油香，我为祖国采石油，我为xx献力量”<br>从歌词可以看出当时的个人普遍没有“离职”选项。<br>此处应为艰苦朴素的60后鼓掌。<br><strong>90后结论：</strong><br>改革开放之后，90后思想得以解放。<strong>工作参与程度</strong>和<strong>消极情感因素</strong>对90后离职动机产生了<strong>显著影响</strong>。具体表现如下：<br><strong>场外音：（受委屈了？！）</strong></p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://pic2.zhimg.com/80/v2-45f02ec8fa5ba85e61d99fc0a7de3874_720w.jpg?source=1940ef5c" width="30%" alt>
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">
      图3-受委屈了？！
      </div>
</center>

<p><strong>90后反应可参考诗词：</strong></p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://pic3.zhimg.com/80/v2-d30f80a5f69ea48558d486eea635d77b_720w.jpg?source=1940ef5c" width="30%" alt>
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">
      图4-“竹杖芒鞋轻胜马，谁怕，一蓑烟雨任平生”
      </div>
</center>


<p><strong>场外音：（欺负我？！）</strong></p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://pic4.zhimg.com/80/v2-e1a6d36bae2a9332bed97c423092027b_720w.jpg?source=1940ef5c" width="30%" alt>
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">
      图4-“竹杖芒鞋轻胜马，谁怕，一蓑烟雨任平生”
      </div>
</center>
**90后反应可参考歌词：**
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://pic4.zhimg.com/80/v2-7b530cec187fb9c841eee6f7cf264bed_720w.jpg?source=1940ef5c" width="30%" alt>
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">
      图5-“我的地盘，我做主”
      </div>
</center>

<p>下面是干货时间，我个人认为Price-Muller辞职模型有一个积极的作用：<br>”影响一个成年人辞职的4大影响因素”有高实践价值。<br>站在年轻人角度</p>
<ul>
<li>  通过辞职4大影响因素，来辅助个人决策是否应该离开当前所在公司；</li>
<li>  通过16个离职子因素，面试时大胆告诉HR你离开上家公司有理有据。</li>
</ul>
<p>站长企业管理者角度角度，</p>
<ul>
<li>  管理者正好应检验上面的16个子因素是否满足。有过改之，无过加勉，提升各个因素质量，让公司年轻骨干换发新活力。</li>
</ul>
<h1 id="测试候选人稳定性"><a href="#测试候选人稳定性" class="headerlink" title="测试候选人稳定性"></a>测试候选人稳定性<a href="#测试候选人稳定性" class="header-anchor">#</a></h1><div class="note warning"><p>什么是稳定性？<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[社会招聘，怎样测试稳定性](https://mp.weixin.qq.com/s/ZyEWV1g_UzXODkViyFdNlw)">[2]</span></a></sup></p></div>

<ul>
<li>校园招聘中的稳定性，主要是职业性向；</li>
<li>猎头招聘的稳定性是，主要是资源互补；</li>
<li>社会招聘的稳定性，是能迅速达到良好绩效+持续投入精力在同一岗位；</li>
</ul>
<p>笔者是社招民工，主要写一点社招稳定性的阅读心得，那么首先第一问来了</p>
<div class="note warning"><p><strong>稳定性的测试有哪些？</strong></p></div>

<p>1.意图行为测试</p>
<p>也叫TEACHER测试,主要用于测试能否“迅速”“达到良好绩效”两项指标。七个问题的首字母是TEACHER，因此，<strong>意图行为测试也叫TEACHER测试。</strong></p>
<p> 1 目标Target：举例说明，你怎么设定目标</p>
<p> 2 实施Execute：目标确定，你怎么投入实施</p>
<p> 3 调整Adjust：实施当中，你怎么调整方案</p>
<p> 4 改正Correct：发现错误，你怎么改正行为</p>
<p> 5 求助Help：遇到难题，你怎么寻求帮助</p>
<p> 6 坚持Endure：遇到挫败，你怎么坚持目标</p>
<p> 7 收获Reap：行动之后，你怎么确认收获</p>
<p><strong>2.社会学习测试</strong></p>
<p>首字母是BANANA，因此，它也叫BANANA测试，或者叫“香蕉测试”</p>
<p> 1 行为Behavior：你把哪些人作为行为榜样</p>
<p> 2 身边Around：哪些行为榜样就在你身边</p>
<p> 3 注意Notable：怎么注意到这些行为的</p>
<p> 4 尝试Attempt：怎么尝试改变自己的行为</p>
<p> 5 自然Natural：新行为如何变得自然</p>
<p> 6 提高Advance：新行为带来哪些提高</p>
<p>有此项能力的人，会表现四种行为：观察他人、模仿他人、改变自身行为、提高个人能力。</p>
<p>不具备此项能力的人，只有崇拜，无法学习大师，因为看不到自己应该学什么，哪里有不足。</p>
<p><strong>3.理性选择测试</strong></p>
<p>这六个问题的首字母是ORANGE，因此，理性选择测试也叫ORANGE测试，或者叫“桔子测试”。</p>
<p> 1 机会Opportunity：换工作想获得什么机会</p>
<p> 2 偶然Random：换工作是不是偶然想法</p>
<p> 3 摆脱Avoid：换工作是想摆脱什么</p>
<p> 4 关注Notice：关注了哪些招聘信息</p>
<p> 5 收集Gather：收集了我们的什么信息</p>
<p> 6 询问Enquire：想问我们什么问题</p>
<p>测试候选人换工作，是不是理性选择，是问上述六个问题。</p>
<div class="note warning"><p><strong>理性测试有两大规则：</strong></p></div>

<ul>
<li>只倾听，不追问，避免引起候选者深入思考</li>
<li>交叉验证，1-6的问题都可以互相验证候选人的陈述是否前后一致</li>
</ul>
<div class="note warning"><p><strong>如何使用上述三项测试？：</strong></p></div>

<p><strong>三项都要做，有以下原因：</strong></p>
<ul>
<li>只做香蕉测试和桔子测试，选出来的人是猪八戒，是机会主义者，学习能力强，但不追求绩效</li>
<li>只做TEACHER测试，选出来的人是沙僧，工作能力，成长慢，学习慢，需要很长时间才能达到良好绩效</li>
</ul>
<p>猪八戒需要公司花费很大精力扭转它的工作价值观；</p>
<p>沙僧则需要给它安排教练辅导，手把手的教他工作。</p>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.zhihu.com/question/308110736/answer/628764663">为什么都在说 90 后的辞职率高？</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://mp.weixin.qq.com/s/ZyEWV1g_UzXODkViyFdNlw">社会招聘，怎样测试稳定性</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li></ol></div></div><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>杂谈</category>
        <category>日记</category>
      </categories>
      <tags>
        <tag>程序人生，杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>mtk-log</title>
    <url>/blog//2021/02/mtk-log/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="mtk-log"><a href="#MTK-log" class="headerlink" title="MTK log"></a><a href="https://www.pianshen.com/article/4121163154/">MTK log</a><a href="#mtk-log" class="header-anchor">#</a></h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍<a href="#介绍" class="header-anchor">#</a></h2><p>mtklog是由log生成工具MTKLogger生成的一系列问题追踪文件，其主要作用就是对系统或者应用产生的异常进行快速定位，从而解决问题。</p>
<p>log文件名称为：<br>crash_log ：崩溃日志，主要输出 程序崩溃造成的crash log<br>events_log：事件日志，主要输出记录各个activity周期及事件<br>kernel_log：底层驱动，按键，低内存相关log<br>sys_log：系统日志，Exception定位点<br>radio_log：输出通话，网络状态变化<br>main_log：详尽输出每一步的log</p>
<a id="more"></a>

<h2 id="开启和关闭"><a href="#开启和关闭" class="headerlink" title="开启和关闭"></a>开启和关闭<a href="#开启和关闭" class="header-anchor">#</a></h2><p>（1）在拨号盘界面输入*#9646633# ：<br>（2）进入EngineerMode的第一个Telephony界面：<br>（3）向左滑动进入Log and Debugging界面：<br>（4）点击MTKLogger 菜单：点击log设置图标可进入log设置界面，如果我只要打印MobileLog可将ModemLog，NetworkLog，GPSlog关闭，点击蓝底色1 即可：<br>（5）点击开始（红色播放按键）按键：<br>（6）log 开启：<br>（7）当我们已经发现异常时，当关闭log，并截图记录时间点，下拉进入下拉栏界面，点击MTKLogger is running：<br>（8）点击停止按键</p>
<h2 id="log总览"><a href="#Log总览" class="headerlink" title="Log总览**"></a>Log总览**<a href="#log总览" class="header-anchor">#</a></h2><ul>
<li><strong>Android Log</strong></li>
</ul>
<ol>
<li>Android java层和native层 log</li>
<li>main log、system log、radio log、event log</li>
</ol>
<ul>
<li><strong>Kernel Log</strong></li>
</ul>
<ol>
<li>Linux Kernel内核和驱动log</li>
<li>UART Log</li>
</ol>
<ul>
<li><strong>Exception Datebase(db)</strong></li>
</ul>
<p>系统死机/重启等问题发生时候的原始RAW data</p>
<h2 id="log-tools"><a href="#Log-Tools" class="headerlink" title="Log Tools"></a><strong>Log Tools</strong><a href="#log-tools" class="header-anchor">#</a></h2><ul>
<li>mtklogger</li>
<li>PC tool</li>
</ul>
<p><img src="http://cdn.yangchaofan.cn/blog/20210227/br8ouvYv45G7.jpg?imageslim" alt="mark"></p>
<h3 id="手机端mtklogger"><a href="#手机端mtklogger" class="headerlink" title="手机端mtklogger"></a><strong>手机端mtklogger</strong><a href="#手机端mtklogger" class="header-anchor">#</a></h3><p><img src="http://cdn.yangchaofan.cn/blog/20210227/DiGViDp5mmch.png?imageslim" alt="mark"></p>
<p><img src="http://cdn.yangchaofan.cn/blog/20210227/qgVnqzd6p6IJ.png?imageslim" alt="mark"></p>
<h4 id="个人优化"><a href="#个人优化" class="headerlink" title="个人优化"></a><strong>个人优化</strong><a href="#个人优化" class="header-anchor">#</a></h4><h5 id="mtklog抓取完整kernel-log"><a href="#mtklog抓取完整kernel-log" class="headerlink" title="mtklog抓取完整kernel log"></a><strong>mtklog抓取完整kernel log</strong><a href="#mtklog抓取完整kernel-log" class="header-anchor">#</a></h5><ul>
<li><strong>默认抓不全原因</strong></li>
</ul>
<p>由于Mobilelog service运行要在android system init阶段，而从kernel启动到这个阶段，kernel log已经在不断地送入log ring buffer，log量大的情况下ring buffer就会被覆盖</p>
<p>默认抓取到的kernel_log.boot不是从0s开始，对于研发debug阶段,只能靠抓取uart log来获取0s开始的log，非常影响debug效率</p>
<ul>
<li><strong>解决方法</strong></li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">alps&#x2F;kernel-3.18&#x2F;init&#x2F;Kconfig</span><br><span class="line">config LOG_BUF_SHIFT</span><br><span class="line">       default 17  --- &gt; 21   2^21&#x3D;2MB buffer</span><br><span class="line"></span><br><span class="line">alps&#x2F;system&#x2F;core&#x2F;liblog&#x2F;include&#x2F;private&#x2F;android_logger.h</span><br><span class="line">#define LOG_BUFFER_SIZE (2048 * 1024)    #log和logd一致</span><br><span class="line">123456</span><br></pre></td></tr></table></figure></div>
<h3 id="电脑端pc-tool"><a href="#电脑端PC-tool" class="headerlink" title="电脑端PC tool"></a><strong>电脑端PC tool</strong><a href="#电脑端pc-tool" class="header-anchor">#</a></h3><h4 id="adb"><a href="#adb" class="headerlink" title="adb"></a><strong>adb</strong><a href="#adb" class="header-anchor">#</a></h4><h5 id="logcat"><a href="#logcat" class="headerlink" title="logcat"></a><strong>logcat</strong><a href="#logcat" class="header-anchor">#</a></h5><ul>
<li><strong>介绍</strong></li>
</ul>
<p>logcat是android中的一个命令行工具，可以用于得到程序的log信息</p>
<p>常见的日志纪录方法包括：</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">v(String,String) (vervbose)</td>
<td align="left">显示全部信息</td>
</tr>
<tr>
<td align="left">d(String,String)(debug)</td>
<td align="left">显示调试信息</td>
</tr>
<tr>
<td align="left">i(String,String)(information)</td>
<td align="left">显示一般信息</td>
</tr>
<tr>
<td align="left">w(String,String)(waning)</td>
<td align="left">显示警告信息</td>
</tr>
<tr>
<td align="left">e(String,String)(error)</td>
<td align="left">显示错误信息</td>
</tr>
</tbody></table>
<p>例如：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;开发过程中获取log</span><br><span class="line">Log.i(&quot;MyActivity&quot;,&quot;MyClass.getView() - get item number&quot;+position);</span><br><span class="line">&#x2F;&#x2F;adb获取log</span><br><span class="line">adb logcat</span><br><span class="line">1234</span><br></pre></td></tr></table></figure></div>
<p>adb logcat输出的日志格式如下：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">I&#x2F;ActivityManager( 1754): Waited long enough for: ServiceRecord&#123;2b24178c u0 com.google.android.gms&#x2F;.checkin.CheckinService&#125;</span><br></pre></td></tr></table></figure></div>
<ul>
<li><strong>实例</strong></li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">adb logcat –b radio</span><br><span class="line">adb logcat –b system</span><br><span class="line">adb logcat –b events</span><br><span class="line">adb logcat –b main</span><br><span class="line">1234</span><br></pre></td></tr></table></figure></div>
<ul>
<li><strong>优势</strong></li>
</ul>
<ol>
<li>缓冲区强大，不会因为数据量过大而丢失log</li>
<li>过滤性能好</li>
<li>语法简洁，使用方便</li>
</ol>
<h5 id="提取db"><a href="#提取db" class="headerlink" title="提取db"></a><strong>提取db</strong><a href="#提取db" class="header-anchor">#</a></h5><ul>
<li><strong>位置</strong></li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">&#x2F;data&#x2F;aee_exp</span><br><span class="line">&#x2F;data&#x2F;vendor&#x2F;mtklog&#x2F;aee_exp</span><br><span class="line">12</span><br></pre></td></tr></table></figure></div>
<h4 id="gat"><a href="#GAT" class="headerlink" title="GAT"></a><strong>GAT</strong><a href="#gat" class="header-anchor">#</a></h4><p><img src="http://cdn.yangchaofan.cn/blog/20210227/nwDUjynnBdXh.png?imageslim" alt="mark"></p>
<ul>
<li><strong>BugReport</strong></li>
</ul>
<p><img src="http://cdn.yangchaofan.cn/blog/20210227/VRnI24X9QxKP.png?imageslim" alt="mark"></p>
<ul>
<li><strong>DB puller</strong></li>
</ul>
<p><img src="http://cdn.yangchaofan.cn/blog/20210227/POXrsi3L2V0k.png?imageslim" alt="mark"></p>
<ul>
<li><strong>Mediatek LogView</strong></li>
</ul>
<p><img src="http://cdn.yangchaofan.cn/blog/20210227/59zvGw73P6Qr.png?imageslim" alt="mark"></p>
<h2 id="各种mode抓mobile-log"><a href="#各种mode抓mobile-log" class="headerlink" title="各种mode抓mobile log"></a><strong>各种mode抓mobile log</strong><a href="#各种mode抓mobile-log" class="header-anchor">#</a></h2><h3 id="normal-mode"><a href="#Normal-mode" class="headerlink" title="Normal mode"></a><strong>Normal mode</strong><a href="#normal-mode" class="header-anchor">#</a></h3><ol>
<li>GAT (user版本只能抓main log，eng版本还能抓到kernel log)</li>
<li>mtklogger(user版本通过*#<em>#3646633#</em>#*进入工模选择)，会暂时录制到/data/log_temp下，等SD卡ready后再copy到mtklog/mobilelog/APLog路径下</li>
</ol>
<h3 id="meta-modepc-meta-tool"><a href="#Meta-mode-PC-meta-tool" class="headerlink" title="Meta mode(PC meta tool)"></a><strong>Meta mode(PC meta tool)</strong><a href="#meta-modepc-meta-tool" class="header-anchor">#</a></h3><ul>
<li>会先录制到/data/log_temp/meta/下，等外卡ready后再copy到sdcard1/mtklog/mobilelog/APLog路径下，然后删除源文件(data/log_temp)。</li>
</ul>
<h3 id="factory-modepower-down-key"><a href="#Factory-mode-power-down-key" class="headerlink" title="Factory mode(power + down key)"></a><strong>Factory mode(power + down key)</strong><a href="#factory-modepower-down-key" class="header-anchor">#</a></h3><ul>
<li>同Meta mode</li>
</ul>
<h3 id="recovery-modepower-up-key"><a href="#Recovery-mode-power-up-key" class="headerlink" title="Recovery mode(power + up key)"></a><strong>Recovery mode(power + up key)</strong><a href="#recovery-modepower-up-key" class="header-anchor">#</a></h3><ol>
<li>先存在tmp/recovery.log，Reboot进入normal后存在cache/recovery</li>
<li>user 版本需要下载eng的recovery.img和boot.img才能抓log</li>
</ol>
<h3 id="ipo-mode"><a href="#IPO-mode" class="headerlink" title="IPO mode"></a><strong>IPO mode</strong><a href="#ipo-mode" class="header-anchor">#</a></h3><ol>
<li>设置IPO关机后，关机期间的log会录制到/data/log_temp/ipo/下，等再次开机后再copy到/mtklog/mobilelog/APLog路径下，然后删除源文件。</li>
<li>GAT</li>
</ol>
<h2 id="各种场景抓log"><a href="#各种场景抓log" class="headerlink" title="各种场景抓log"></a><strong>各种场景抓log</strong><a href="#各种场景抓log" class="header-anchor">#</a></h2><h3 id="preloader-amp-lk阶段没有logo或卡在logo界面开机log"><a href="#Preloader-amp-LK阶段（没有logo或卡在logo界面）开机log" class="headerlink" title="Preloader &amp; LK阶段（没有logo或卡在logo界面）开机log"></a><strong>Preloader &amp; LK阶段（没有logo或卡在logo界面）开机log</strong><a href="#preloader-amp-lk阶段没有logo或卡在logo界面开机log" class="header-anchor">#</a></h3><ul>
<li>抓取uart log</li>
</ul>
<h3 id="kernel阶段有logo或开机动画开机log"><a href="#Kernel阶段（有logo或开机动画-开机log" class="headerlink" title="Kernel阶段（有logo或开机动画)开机log"></a>Kernel阶段（有logo或开机动画)开机log<a href="#kernel阶段有logo或开机动画开机log" class="header-anchor">#</a></h3><ol>
<li>如果是User版本，先用对应ENG 版本的lk 替换掉user 版本的lk</li>
<li>或者在user load的<code>alps/bootable/bootloader/lk/app/mt_boot/mt_boot.c</code>中，将所有<code>printk.disable_uart=1</code>改成<code>printk.disable_uart=0</code>，然后重新编译lk, download lk 即可。</li>
</ol>
<h3 id="android阶段有开机动画开机log"><a href="#Android阶段（有开机动画）开机log" class="headerlink" title="Android阶段（有开机动画）开机log"></a><strong>Android阶段（有开机动画）开机log</strong><a href="#android阶段有开机动画开机log" class="header-anchor">#</a></h3><p>Adbd进程起来后，可以使用GAT抓取开机log（录制前先关机）。</p>
<p>若mtklogger可用，可以通过设置mobile log开机自启动录制开机log。</p>
<p>停止录制状态下mtklogger-&gt;settings-&gt;mobile log-&gt;start automticaly</p>
<p>若TP无法使用，可以参考FAQ06939使用adb命令控制mtklogger录制。</p>
<h3 id="user-build-抓开机向导或者不开机log"><a href="#user-build-抓开机向导或者不开机log" class="headerlink" title="user build 抓开机向导或者不开机log"></a><strong>user build 抓开机向导或者不开机log</strong><a href="#user-build-抓开机向导或者不开机log" class="header-anchor">#</a></h3><p>编译一版eng版本对应软件，做如下修改：</p>
<p><a href="https://ad.plus/?utm_source=pianshen.com&utm_medium=protag-in_article_video&utm_campaign=brand_logo">Powered by <strong>Ad.Plus</strong></a></p>
<p><video class="pa_video pa_size_640_360" playsinline muted width="640" height="360" style="box-sizing: border-box; display: inline-block; vertical-align: baseline; overflow: hidden; max-width: 100%; height: 225px; transition: height 0s ease-out 0s; width: 400px;"></video></p>
<iframe src="https://imasdk.googleapis.com/js/core/bridge3.444.1_zh.html#goog_420327109" allowfullscreen allow="autoplay" width="640" height="360" style="box-sizing: border-box; height: 225px !important; width: 400px !important; border: 0px; opacity: 1; margin: 0px; padding: 0px; position: relative; color-scheme: light;"></iframe>



<ol>
<li><code>alps/system/core/rootdir/init.rc</code></li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="R"><figure class="iseeu highlight /r"><table><tr><td class="code"><pre><span class="line">on property:ro.debuggable=<span class="number">1</span></span><br><span class="line">    <span class="comment"># Give writes to anyone for the trace folder on debug builds.</span></span><br><span class="line">    <span class="comment"># The folder is used to store method traces.</span></span><br><span class="line">    chmod <span class="number">0773</span> /data/misc/trace</span><br><span class="line">    start console</span><br><span class="line">//add begin</span><br><span class="line">on property:ro.debuggable=<span class="number">0</span></span><br><span class="line">    <span class="comment"># Give writes to anyone for the trace folder on debug builds.</span></span><br><span class="line">    <span class="comment"># The folder is used to store method traces.</span></span><br><span class="line">    chmod <span class="number">0773</span> /data/misc/trace</span><br><span class="line">    start console</span><br><span class="line">setprop persist.sys.usb.config mass_storage,adb //add end</span><br><span class="line">123456789101112</span><br></pre></td></tr></table></figure></div>
<ol>
<li><code>alps/kernel-3.18/drivers/misc/mediatek/mtprof/bootprof.c</code></li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MT_PRINTK_UART_CONSOLE</span></span><br><span class="line">    <span class="comment">//mt_disable_uart();</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure></div>
<ol>
<li><code>alps/build/make/core/main.mk</code></li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="MAKEFILE"><figure class="iseeu highlight /makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ifeq</span> (true,<span class="variable">$(<span class="built_in">strip</span> <span class="variable">$(enable_target_debugging)</span>)</span>)  <span class="comment"># Target is more debuggable and adbd is on by default</span></span><br><span class="line">  ADDITIONAL_DEFAULT_PROPERTIES += ro.debuggable=1  <span class="comment"># Enable Dalvik lock contention logging.</span></span><br><span class="line">  ADDITIONAL_BUILD_PROPERTIES += dalvik.vm.lockprof.threshold=500   <span class="comment"># Include the debugging/testing OTA keys in this build.</span></span><br><span class="line">  INCLUDE_TEST_OTA_KEYS := true</span><br><span class="line"><span class="keyword">else</span> <span class="comment"># !enable_target_debugging</span></span><br><span class="line">  <span class="comment"># Target is less debuggable and adbd is off by default</span></span><br><span class="line">  ADDITIONAL_DEFAULT_PROPERTIES += ro.debuggable=1</span><br><span class="line"><span class="keyword">endif</span> <span class="comment"># !enable_target_debugging</span></span><br><span class="line">12345678</span><br></pre></td></tr></table></figure></div>
<p>编译好后，user版本刷入eng版本的lk+boot， 抓取uart 或者上层log</p>
<p>如需抓取开机向导前的log，由于系统还未正式起来，请焊uart线，uart log中输入<code>adb logcat &amp;</code>将上层log输出到uart log中</p>
<h2 id="aee异常机制"><a href="#AEE异常机制" class="headerlink" title="AEE异常机制"></a><strong>AEE异常机制</strong><a href="#aee异常机制" class="header-anchor">#</a></h2><h3 id="aee介绍"><a href="#AEE介绍" class="headerlink" title="AEE介绍"></a><strong>AEE介绍</strong><a href="#aee介绍" class="header-anchor">#</a></h3><p><code>AEE (Android Exception Engine)</code>是安卓的一个异常捕获和调试信息生成机制。</p>
<p>手机发生错误（异常重启/卡死）时生成db文件（一种被加密过的二进制文件）</p>
<h3 id="why-do-we-need-aee"><a href="#why-do-we-need-AEE" class="headerlink" title="why do we need AEE"></a><strong>why do we need AEE</strong><a href="#why-do-we-need-aee" class="header-anchor">#</a></h3><p>用来保存和记录异常发生时候的所有内存信息，通过调试和仿真这些信息，可以追踪到异常的原因</p>
<h3 id="db文件介绍"><a href="#DB文件介绍" class="headerlink" title="DB文件介绍"></a><strong>DB文件介绍</strong><a href="#db文件介绍" class="header-anchor">#</a></h3><table>
<thead>
<tr>
<th align="left"><strong>File</strong></th>
<th align="left"><strong>Description</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>__exp_main.txt</strong></td>
<td align="left">异常类型，调用栈等关键信息</td>
</tr>
<tr>
<td align="left">_exp_detail.txt</td>
<td align="left">详细异常信息</td>
</tr>
<tr>
<td align="left"><strong>SYS_ANDROID_LOG</strong></td>
<td align="left">android buffer log(logcat -d -v time *:v)</td>
</tr>
<tr>
<td align="left"><strong>SYS_KERNEL_LOG</strong></td>
<td align="left">kernel log</td>
</tr>
<tr>
<td align="left"><strong>SYS_LAST_KMSG</strong></td>
<td align="left">上次重启前的kernel log</td>
</tr>
<tr>
<td align="left"><strong>SYS_MINI_RDUMP</strong></td>
<td align="left">类似coredump，可以用gdb/trace32调试</td>
</tr>
<tr>
<td align="left">SYS_WDT_LOG</td>
<td align="left">看门狗复位信息</td>
</tr>
<tr>
<td align="left">SYS_REBOOT_REASON</td>
<td align="left">重启时的硬件记录的信息</td>
</tr>
<tr>
<td align="left">SYS_VERSION_INFO</td>
<td align="left">kernel版本，用于和vmlinux对比，只有匹配的vmlinux才能用于分析这个异常</td>
</tr>
<tr>
<td align="left">SYS_ANDROID_EVENT_LOG</td>
<td align="left">android event log(logcat -b events -v time -d *:v)</td>
</tr>
<tr>
<td align="left">SYS_ANDROID_RADIO_LOG</td>
<td align="left">android buffer log(logcat -b radio -v time -d *:v)</td>
</tr>
<tr>
<td align="left"><strong>PROCESS_COREDUMP</strong></td>
<td align="left">native program core dump</td>
</tr>
<tr>
<td align="left"><strong>SYS_PROPERTIES</strong></td>
<td align="left">system properties</td>
</tr>
<tr>
<td align="left">SWT_JBT_TRACES</td>
<td align="left">/data/anr/.</td>
</tr>
<tr>
<td align="left">ZZ_INTERNAL</td>
<td align="left">基本异常信息</td>
</tr>
<tr>
<td align="left">SYS_CPU_INFO</td>
<td align="left">cpu 信息(top -n 1 -d 1 -m 30 -t)</td>
</tr>
<tr>
<td align="left">SYS_MEMORY_INFO</td>
<td align="left">memory information (/proc/meminfo)</td>
</tr>
</tbody></table>
<ul>
<li><strong>重启原因记录</strong></li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">last_reboot_reason</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> fiq_step;</span><br><span class="line">    <span class="keyword">uint32_t</span> exp_type; <span class="comment">/* 0xaeedeadX: X=1 (HWT), X=2 (KE), X=3 (nested panic) */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> reboot_mode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> last_irq_enter[NR_CPUS];</span><br><span class="line">    <span class="keyword">uint64_t</span> jiffies_last_irq_enter[NR_CPUS];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> last_irq_exit[NR_CPUS];</span><br><span class="line">    <span class="keyword">uint64_t</span> jiffies_last_irq_exit[NR_CPUS];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint64_t</span> jiffies_last_sched[NR_CPUS];</span><br><span class="line">    <span class="keyword">char</span> last_sched_comm[NR_CPUS][TASK_COMM_LEN];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint8_t</span> hotplug_data1[NR_CPUS], <span class="keyword">uint8_t</span> hotplug_data2;</span><br><span class="line">    <span class="keyword">uint64_t</span> hotplug_data3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> mcdi_wfi, mcdi_r15, deepidle_data, sodi_data, spm_suspend_data;</span><br><span class="line">    <span class="keyword">uint64_t</span> cpu_dormant[NR_CPUS];</span><br><span class="line">    <span class="keyword">uint32_t</span> clk_data[<span class="number">8</span>], suspend_debug_flag;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint8_t</span> cpu_dvfs_vproc_big, cpu_dvfs_vproc_little, cpu_dvfs_oppidx, cpu_dvfs_status;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint8_t</span> gpu_dvfs_vgpu, gpu_dvfs_oppidx, gpu_dvfs_status;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint64_t</span> ptp_cpu_big_volt, ptp_cpu_little_volt, ptp_gpu_volt, ptp_temp;</span><br><span class="line">    <span class="keyword">uint8_t</span> ptp_status;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint8_t</span> thermal_temp1, thermal_temp2, thermal_temp3, thermal_temp4, thermal_temp5;</span><br><span class="line">    <span class="keyword">uint8_t</span> thermal_status;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *kparams;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728293031323334</span></span><br></pre></td></tr></table></figure></div>
<h2 id="实际应用总结"><a href="#实际应用总结" class="headerlink" title="实际应用总结"></a><strong>实际应用总结</strong><a href="#实际应用总结" class="header-anchor">#</a></h2><h3 id="usr状态不同现象手机如何抓取有效log"><a href="#usr状态，不同现象手机如何抓取有效log" class="headerlink" title="usr状态，不同现象手机如何抓取有效log"></a><strong>usr状态，不同现象手机如何抓取有效log</strong><a href="#usr状态不同现象手机如何抓取有效log" class="header-anchor">#</a></h3><ol>
<li>可正常开机</li>
</ol>
<p>A：MTKlogger基本足矣</p>
<ol>
<li>卡logo，不开机</li>
</ol>
<p>A：</p>
<ul>
<li>刷入eng的lk和boot，再跳线抓取uart log，并开启logcat抓取从开机到异常出现时的所有底层和上层log</li>
<li>如果偶尔可以开机，第一时间进入系统提取db信息</li>
<li>如上述方式无法提取到关键db，则需要通过flashtool来回读db的原始raw分区，再通过自制expdb解压工具展开</li>
</ul>
<h3 id="debug阶段手机如何抓取有效log"><a href="#debug阶段，手机如何抓取有效log" class="headerlink" title="debug阶段，手机如何抓取有效log"></a><strong>debug阶段，手机如何抓取有效log</strong><a href="#debug阶段手机如何抓取有效log" class="header-anchor">#</a></h3><ol>
<li>无ctp情况下如何调试手机</li>
</ol>
<p>A：连接adb，通过adb发送ctp报点与手势，来操作手机</p>
<ol>
<li>无lcd情况下如何调试手机</li>
</ol>
<p>A：使用GAT工具，实时抓取手机内部frame buffer，投影到电脑上，并用adb命令操作手机</p>
<ol>
<li>UART Log量太大，无法找出重要log怎么办</li>
</ol>
<p>A：采用adb logcat方式实时过滤带关键字关键level的log （包括kernel log）</p>
<h3 id="log分析与调试技巧"><a href="#Log分析与调试技巧" class="headerlink" title="Log分析与调试技巧"></a><strong>Log分析与调试技巧</strong><a href="#log分析与调试技巧" class="header-anchor">#</a></h3><h4 id="android开机流程图"><a href="#Android开机流程图" class="headerlink" title="Android开机流程图"></a><strong>Android开机流程图</strong><a href="#android开机流程图" class="header-anchor">#</a></h4><p><img src="http://cdn.yangchaofan.cn/blog/20210227/Qm2wlH7QktoL.png?imageslim" alt="mark"></p>
<h4 id="bootprof"><a href="#bootprof" class="headerlink" title="bootprof"></a><strong>bootprof</strong><a href="#bootprof" class="header-anchor">#</a></h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">adb shell cat &#x2F;proc&#x2F;bootprof or mktlog bootprof file</span><br></pre></td></tr></table></figure></div>
<p><img src="http://cdn.yangchaofan.cn/blog/20210227/Xchbq9MizBGV.png?imageslim" alt="mark"></p>
<h4 id="实际案例不开机类"><a href="#实际案例（不开机类）" class="headerlink" title="实际案例（不开机类）"></a><strong>实际案例（不开机类）</strong><a href="#实际案例不开机类" class="header-anchor">#</a></h4><h5 id="文件系统损坏导致挂载失败"><a href="#文件系统损坏导致挂载失败" class="headerlink" title="文件系统损坏导致挂载失败"></a><strong>文件系统损坏导致挂载失败</strong><a href="#文件系统损坏导致挂载失败" class="header-anchor">#</a></h5><p>System mount fail 导致 service 起不来，readback system分区对比看是否文件破坏。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">[138:kworker&#x2F;u16:2]device-mapper: verity: 179:30: metadata block 716579 is corrupted</span><br><span class="line">[246:init]JBD2: IO error reading journal superblock</span><br><span class="line">[246:init]EXT4-fs (dm-0): error loading journal</span><br><span class="line">[246:init]fs_mgr: __mount(source&#x3D;&#x2F;dev&#x2F;block&#x2F;dm-0,target&#x3D;&#x2F;system,type&#x3D;ext4)&#x3D;-1  &lt;&lt;&#x3D;&#x3D;&#x3D;文件系统挂载失败</span><br><span class="line">[246:init]EXT4-fs (mmcblk0p31): VFS: Can&#39;t find ext4 filesystem</span><br><span class="line">12345</span><br></pre></td></tr></table></figure></div>
<p>经常遇到无法开机的问题，低概率、难复现，而且软、硬体跨度大，不易掌握与追踪；</p>
<p>事后分析:</p>
<p>部分有硬件实际损坏、系统映像档被破坏，或用户拔电池导致系统核心文件损坏…等几种原因。其中一部分导致无法开机的问题是由于不当操作使得文件损坏导致的。</p>
<p>PS:产线也会报小概率不开机的问题。</p>
<p>Donwload完整性检查和开机检查客制化</p>
<p>检查kernel log是否有<strong>emmc i/o error</strong>相关log</p>
<p>如果是单机问题检查emmc相关供电或作替换物料交叉实验</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">[ 5.030802] &lt;0&gt;.(0)[165:mmcqd&#x2F;0]mmcblk0: error -110 transferring data, sector 5448262, nr 442, cmd</span><br><span class="line">response 0x900, card status 0x0</span><br><span class="line">[ 5.032358] &lt;0&gt;.(0)[165:mmcqd&#x2F;0]blk_update_request: I&#x2F;O error, dev mmcblk0, sector 5448262</span><br><span class="line">[ 5.130190] &lt;0&gt;.(0)[179:init]EXT4-fs (dm-0): unable to read superblock</span><br><span class="line">[ 5.131325] &lt;0&gt;.(0)[179:init]fs_mgr: __mount(source&#x3D;&#x2F;dev&#x2F;block&#x2F;dm-0,target&#x3D;&#x2F;system,type&#x3D;ext4)&#x3D;-1  &lt;&lt;&#x3D;&#x3D;&#x3D;文件系统挂载失败</span><br><span class="line">12345</span><br></pre></td></tr></table></figure></div>
<h5 id="preloader-hang-by-mem-test-fail"><a href="#preloader-hang-by-mem-test-fail" class="headerlink" title="preloader hang by mem test fail"></a><strong>preloader hang by mem test fail</strong><a href="#preloader-hang-by-mem-test-fail" class="header-anchor">#</a></h5><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">[50:31:154] [MEM] complex R&#x2F;W mem test fail :FFFFFFFF</span><br><span class="line">[50:31:155] &lt;ASSERT&gt; memory.c:line 105 0</span><br><span class="line">[50:31:155] PL fatal error</span><br><span class="line">[50:31:155] PL delay for Long Press Reboot</span><br><span class="line">[50:31:159] power key is pressed</span><br><span class="line">[50:36:117] [PLF]Emergency Dwld mode(timeout: 5s)</span><br><span class="line">[50:36:119] mtk_arch_reset at pre-loader!</span><br><span class="line">1234567</span><br></pre></td></tr></table></figure></div>
<ul>
<li><strong>场景追溯</strong></li>
</ul>
<ol>
<li>此问题发生的背景，是产线样机？研发样机？还是客退机？</li>
<li>问题发生概率如何？有固定的复现路径吗？目前遇到的问题是在什么测试下发生的？</li>
<li>问题发生是在一台机器，还是多台机器都有遇到？—- 如果是单机问题该memory硬件问题可能性大</li>
<li>用料是否为MTK QVL上已经验证OK的？其他项目上是否已经使用过？</li>
</ol>
<link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>Android</category>
        <category>BugFree</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>BugFree</tag>
      </tags>
  </entry>
  <entry>
    <title>BugFree三剑客异常、日志、工具</title>
    <url>/blog//2021/02/android-bugfree-three-lines/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="bugfree三剑客异常-日志-工具android开发排查问题小结"><a href="#BugFree三剑客异常、日志、工具—Android开发排查问题小结" class="headerlink" title="BugFree三剑客异常、日志、工具—Android开发排查问题小结"></a>BugFree三剑客异常、日志、工具—Android开发排查问题小结<a href="#bugfree三剑客异常-日志-工具android开发排查问题小结" class="header-anchor">#</a></h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言<a href="#前言" class="header-anchor">#</a></h1><p>程序员编写程序、调试代码的时候不可避免的会遇到各种问题，如页面显示不正确，如数据层数据组装操作未按照期望的业务逻辑执行。</p>
<p>造成这些问题的原因大多分为以下几种：有些是条件语句执行错误，有些是Java层的Exception如空指针、集合边界越界问题，有些是较难找到原因的OOM、ANR、Crash、系统SWT重启问题。面对扑面而来的问题，程序员很容易束手无策。笔者结合自己的经验，总结了BugFree中必不可少的三剑客：异常、日志、工具，期望通过这3个“帮手”，帮助各位排查开发难题。</p>
<a id="more"></a>

<h1 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a>参考阅读<a href="#参考阅读" class="header-anchor">#</a></h1><p><a href="/ye-jincheng-website/blog/2021/02/mtk-log/index.html">Mtk Log使用指南</a></p>
<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常<a href="#异常" class="header-anchor">#</a></h1><h2 id="异常的分类"><a href="#异常的分类" class="headerlink" title="异常的分类"></a>异常的分类<a href="#异常的分类" class="header-anchor">#</a></h2><p>Android是一个庞大而复杂的系统，涉及多种语言，所以其异常也很复杂。根据android系统架构层次，我们也把android异常层次化，分为JE、NE、KE、EE、其他类别</p>
<table>
<thead>
<tr>
<th>w</th>
<th>w</th>
</tr>
</thead>
<tbody><tr>
<td>JE <br>(Java layer exception)</td>
<td>一般是在应用层和框架层发生的异常，通常是由Java代码，XML代码引起的。比如各种RuntimeException, ANR（Application Not Responding）、SWT（Software Watchdog Timeout）等</td>
</tr>
<tr>
<td>NE <br>(Native layer exception)</td>
<td>发生在Linux用户空间的异常，通常是由C/C++代码和库文件引起的。比如内核发出的NE信号（SIGILL、 SIGABRT、 SIGBUS等）</td>
</tr>
<tr>
<td>KE<br> (Kernel layer execption)</td>
<td>通常指内核故障或内核错误，由于在内核模式下出错，这类异常是非常严重的，往往会导致重启、死机或无法开机等</td>
</tr>
<tr>
<td>EE <br>(External (Modem) exception)</td>
<td>从名字看就能猜到Modem这一部分是比较特殊的，独立的。Modem有自己的内存空间和代码，为手机通讯提供服务，一旦这一部分发生异常，需要MDlog，此log需用AEE-LogVie工具解析，解析是需要对应版本的数据文件</td>
</tr>
</tbody></table>
<h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志<a href="#日志" class="header-anchor">#</a></h1><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途<a href="#用途" class="header-anchor">#</a></h2><h3 id="搜索关键异常"><a href="#搜索关键异常" class="headerlink" title="搜索关键异常"></a><strong>搜索关键异常</strong><a href="#搜索关键异常" class="header-anchor">#</a></h3><p><strong>1.常见应用crash</strong></p>
<p>（系统提示***已停止运行） 可以在main log中或crash_log中直接搜索“ fatal exception” ；也可以在event_log中搜索am_crash快速定位到问题</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>原理</th>
</tr>
</thead>
<tbody><tr>
<td>uncaughtException</td>
<td>Android 顶级异常捕获</td>
</tr>
<tr>
<td>Exception</td>
<td>Java 异常基类</td>
</tr>
<tr>
<td>NetworkOnMainThreadException</td>
<td>网络异常</td>
</tr>
<tr>
<td>ANR Warning</td>
<td>ANR TAG</td>
</tr>
<tr>
<td>Application Not Response</td>
<td>ANR TAG</td>
</tr>
<tr>
<td>FATAL</td>
<td>异常 TAG</td>
</tr>
<tr>
<td>ANRManager</td>
<td>ANR TAG</td>
</tr>
<tr>
<td>Log的TAG</td>
<td>Log工具类的TAG</td>
</tr>
</tbody></table>
<p><strong>2.应用闪退</strong></p>
<p>应用闪退一般有如下三种原因：</p>
<p>1).目前遇到最多的主要是因为low memory killer机制在内存达到一定阈值的时候会将大于对应adj进程给kill掉（这个一般在kernel log中搜索关键字“ low memory kill ”就可以确认哪些是因为lmk机制而被kill）;一般此情况下跟性能有关……。 </p>
<p>2). 关联进程被kill导致;</p>
<p><img src="E:\学习资料\mtklog学习\kill.png" alt="kill"></p>
<p>一般在进行闪退分析时可以在events log中搜索关键字” am_kill “或者” in dying proc “等</p>
<p>3).应用本身逻辑有执行finish动作而出现，比如点击锁屏通知进入某个对应界面而界面没有出现，这种情况需要分析对应的main_log、event_log；</p>
<p>a：根据出现闪退时间点在event_log搜索am_resume_activity等am_*_activity相关判断这过程中应用是否有启动和退出的动作。 </p>
<p>b: 在main_log或sys_log搜索“ACT-AM_”相关信息查看对应activy生命周期相关信息。</p>
<p>其次就根据log跟踪对应代码流程……</p>
<h3 id="搜索oom"><a href="#搜索OOM" class="headerlink" title="搜索OOM"></a>搜索OOM<a href="#搜索oom" class="header-anchor">#</a></h3><h4 id="oom描述"><a href="#OOM描述" class="headerlink" title="OOM描述"></a>OOM描述<a href="#oom描述" class="header-anchor">#</a></h4><p>Android应用内存管理机制是在Java内存管理机制基础上改进的，所以造成OOM的原因两者差不多，即所有对象都在堆上分配空间，堆是有大小限制的，当分配的对象不能被回收仍然占据堆空间，新分配的对象不能获取足够的堆空间时，就会OOM。为什么会这样呢？这就是GC不足的地方，GC只能回收自己记录（有向树）里面不可达的对象，对可达对象认为是有用的，不会被回收。但是可达对象并非一定是有用对象，他们可能是废弃对象（死对象、冗余对象、电灯泡，僵尸），但却无法被GC回收，占据着进程堆空间，下面是网上的一个对象实例化简图</p>
<img src="http://images2015.cnblogs.com/blog/625153/201704/625153-20170420202014712-1062539791.jpg">



<h4 id="oom情景"><a href="#OOM情景" class="headerlink" title="OOM情景"></a>OOM情景<a href="#oom情景" class="header-anchor">#</a></h4><p>资源对象没有回收，如cursor，bitmap等</p>
<p>1通常关闭Cursor的方法：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line">Cursor cursor = mDownloadManager.query(<span class="keyword">new</span> Query());</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cursor.moveToFirst()) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> index = cursor.getColumnIndex(DownloadManager.COLUMN_ID);</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> downloadId = cursor.getLong(index);</span><br><span class="line"></span><br><span class="line">ids.add(downloadId);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">while</span> (cursor.moveToNext());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">cursor.close();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<p>另外，在adapter中使用cursor时，需在cursor改变的时候先关闭原来的cursor， 但通常我们都是用android提供的CursorAdapter，其changeCursor函数会将原来的Cursor释放掉，并替换为新的Cursor，所以你不用担心原来的Cursor没有被关闭。</p>
<p>2 注册没有对应的去注册，如各种监听</p>
<p>3 生命周期问题引起的无法回收，如果static、线程等</p>
<p>4其他所有发生OOM情景最终都可以认为是对象没有被回收，如，cursor没有close()，bitmap没有recycle()，监听没有unregister…()等等都是因为对象没有被回收，GC认为这些对象是可达的、正在使用的，导致这些应该被回收的对象不能被回收，最终造成OOM。</p>
<p>大多数的回收方法，如close()、recycle()、unregister…()，其实都是把不再使用的对象置为null，这样GC就能回收原来对象所占空间。所以在编程的时候，对全局变量，特别是容器之类的对象和status 修饰对象，要关注其生命周期，不再需要就及时置为null或调用相应的回收方法</p>
<h4 id="oom的分析思路"><a href="#OOM的分析思路" class="headerlink" title="OOM的分析思路"></a>OOM的分析思路<a href="#oom的分析思路" class="header-anchor">#</a></h4><h5 id="工具准备"><a href="#工具准备" class="headerlink" title="工具准备"></a>工具准备<a href="#工具准备" class="header-anchor">#</a></h5><p>1.log</p>
<p>2.MAT</p>
<p>3.Profiler</p>
<p>4.hprof</p>
<h5 id="复现场景"><a href="#复现场景" class="headerlink" title="复现场景"></a>复现场景<a href="#复现场景" class="header-anchor">#</a></h5><p>1.按log所显示的步骤，多次重复该步骤</p>
<p>2.抓取hrof日志</p>
<p>3.设定怀疑点</p>
<p>4.打印该点的内存大小，如bitmap、集合、集合持有的对象</p>
<h5 id="确认怀疑点"><a href="#确认怀疑点" class="headerlink" title="确认怀疑点"></a>确认怀疑点<a href="#确认怀疑点" class="header-anchor">#</a></h5><p>及时释放掉该对象</p>
<h4 id="oom分类"><a href="#OOM分类" class="headerlink" title="OOM分类"></a>OOM分类<a href="#oom分类" class="header-anchor">#</a></h4><p>内存泄露</p>
<ul>
<li>Context泄露</li>
<li>Handler泄露</li>
<li>Cache泄漏</li>
<li>线程未释放导致的泄漏</li>
</ul>
<p>内存抖动</p>
<ul>
<li>频繁创建对象</li>
</ul>
<p>内存溢出</p>
<ul>
<li>可用内存不足</li>
<li>瞬时申请内存超过了系统可分配内存</li>
<li>大图、长图、宽图</li>
<li>序列过多的图片</li>
</ul>
<h4 id="oom优化思路"><a href="#OOM优化思路" class="headerlink" title="OOM优化思路"></a>OOM优化思路<a href="#oom优化思路" class="header-anchor">#</a></h4><p>这些问题大多是比较难解的问题，大部分都是随机的，往往都是很难复现的，找出规律是很重要的！</p>
<p>另外，内存泄露不容易发现，一些轻微的泄露，可能要使用一个月才能发现，所以对自己的模块，要自己去检查有没有OOM，可以下班时挂上monkey，有时候是能跑出来的</p>
<p>从OOM联想到性能问题，性能问题很多是界面刷新、对象生命周期、冗余操作、不必要的线程等引起的……</p>
<h3 id="搜索swt"><a href="#搜索SWT" class="headerlink" title="搜索SWT"></a>搜索SWT<a href="#搜索swt" class="header-anchor">#</a></h3><table>
<thead>
<tr>
<th>序号</th>
<th>步骤</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><img src="http://cdn.yangchaofan.cn/blog/20210227/MTCwv77J4QE9.png"></td>
</tr>
<tr>
<td></td>
<td><img src="http://cdn.yangchaofan.cn/blog/20210227/iedG22YWjV1n.png"></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>具体信息主要查找log文件有sys_log和mtklog\aee_exp\db.fatal.00.SWT\db.fatal.00.SWT.dbg.DEC</p>
<h3 id="搜索死机"><a href="#搜索死机" class="headerlink" title="搜索死机"></a>搜索死机<a href="#搜索死机" class="header-anchor">#</a></h3><p>这里说的死机就是冻屏，停留在一个界面没反应。死机问题很少遇到，且大多不是一个用层问题，下面简单说下可能造成死机的原因和分析需要信息</p>
<h4 id="工具准备"><a href="#工具准备-1" class="headerlink" title="工具准备"></a>工具准备<a href="#工具准备" class="header-anchor">#</a></h4><p>MTK提供了多种抓取和查看LOG的工具, 如:mtklogger，GAT，Catcher，LogView，QAAT等，这些工具在文档《MediaTek_Logging_SOP》中都有描述</p>
<p><img src="http://cdn.yangchaofan.cn/blog/20210227/382aVmPG0k6V.jpg?imageslim" alt="mark"></p>
<h5 id="mtklogger"><a href="#Mtklogger" class="headerlink" title="Mtklogger*"></a>Mtklogger*<a href="#mtklogger" class="header-anchor">#</a></h5><p>Mtklogger是抓取log的apk，整合了ModemLog，MobileLog，NetworkLog and SystemLogger，在工程模式操作就可以打相关log了。</p>
<h5 id="gat"><a href="#GAT" class="headerlink" title="GAT"></a><strong>GAT</strong><a href="#gat" class="header-anchor">#</a></h5><p>基于SDK调试开发的GUI工具，新增了Log Recoder，Debug Configuration Setting，DBpuller，adb command，Process Information view，Profiling Tools，LogView，Plug-in Script。是调试和抓log的神器，使用说明阅读文档《GAT_User_Guide(Customer).pdf》</p>
<p>工具获取路径（以W1444版本为例）：</p>
<p>私服SVN：\rd\MTK_TOOL\AndroidTool\W1444\W1444_full.zip\Debugging Tools (Binary)\GAT</p>
<h5 id="catcher"><a href="#Catcher" class="headerlink" title="Catcher"></a><strong>Catcher</strong><a href="#catcher" class="header-anchor">#</a></h5><p>是抓取和解析ModemLog的PC端工具，我们经常使用来查看ModemLog，使用说明阅读文档《Catcher_User_Manual_for_Customer.pdf》</p>
<p>工具获取路径：</p>
<p>私服SVN：\rd\MTK_TOOL\AndroidTool\W1444\W1444_full.zip\Catcher</p>
<h5 id="logview"><a href="#LogView" class="headerlink" title="LogView"></a><strong>LogView</strong><a href="#logview" class="header-anchor">#</a></h5><p>可以查看APlog，Taglog，MTKlog，但最常用的是用来查看NE时产生的AEE DB文件里的log，具体使用参考《GAT_User_Guide(Customer).pdf》</p>
<p>工具获取路径：</p>
<p>此工具已集成到GAT</p>
<h5 id="qaat"><a href="#QAAT" class="headerlink" title="QAAT"></a><strong>QAAT</strong><a href="#qaat" class="header-anchor">#</a></h5><p>快速分析log的工具，涵盖错误类型较广，很多地方都可以用，其实他的原理就是过滤关键字，把各种类型的错误过滤出来，是一个分析LOG非常便捷的工具，具体使用参考《MediaTek_Logging_SOP.pdf》</p>
<p><strong>死机可能原因：</strong></p>
<ol>
<li><p>输入系统或者输入驱动问题</p>
</li>
<li><p>系统逻辑问题或阻塞</p>
</li>
<li><p>Surfacefinger问题</p>
</li>
<li><p>显示系统或LCM驱动问题</p>
</li>
</ol>
<p><strong>相关信息和抓log：</strong></p>
<ol>
<li><p>确认adb是否可用</p>
</li>
<li><p>抓取bugreport，adb bugreport &gt; d:/bugreport.txt</p>
</li>
<li><p>抓取dumpstate信息，adb shell dumpstate &gt; d:/dumpstate.txt</p>
</li>
<li><p>抓取CPU信息，adb shell top –t –m 5 &gt; d:/cpu.txt</p>
</li>
<li><p>确认是否可以拨打电话，adb shell am start –a android.intent.action.CALL tel:10086(看界面是否能够更新)</p>
</li>
<li><p>查看按键和触屏报点，adb shell getevent</p>
</li>
<li><p>抓取Surfacefinger进程信息，先adb shell ps –p找出pid，然后使用adb shell rtt –f bt –p pid &gt; rtt.txt</p>
</li>
</ol>
<h3 id="搜索重启"><a href="#搜索重启" class="headerlink" title="搜索重启"></a>搜索重启<a href="#搜索重启" class="header-anchor">#</a></h3><p>从异常分类来看，重启异常大多数和NE、KE和硬件问题有关，JE方面引起重启死机大多是和系统进程有关，如system_process进程发生了Crash、SWT、JVM Error，AP应用一般是不会引起重启死机的，但偶尔也会</p>
<p>72平台上，发送短信内容为‘==’时会重启</p>
<img src="http://images2015.cnblogs.com/blog/625153/201704/625153-20170420202046243-314090766.jpg">



<p>虽然是Mms引起的，但最终也是System_process挂掉了，导致重启</p>
<p>重启异常分析步骤（JE）：</p>
<ol>
<li><p>确认异常类型（用QAAT跑一下做初步判断，如果是NE、KE让驱动人员帮忙解决）</p>
</li>
<li><p>找到第一时间发生错误的地方，因为后面的错误多半是因为前面错误引起的，那就没有意义</p>
</li>
<li><p>根据JE类型，结合对应工具分析LOG</p>
</li>
</ol>
<h3 id="搜索anr"><a href="#搜索ANR" class="headerlink" title="搜索ANR"></a>搜索ANR<a href="#搜索anr" class="header-anchor">#</a></h3><h4 id="anr定义"><a href="#ANR定义" class="headerlink" title="ANR定义"></a><strong>ANR定义</strong><a href="#anr定义" class="header-anchor">#</a></h4><p>Application Not Responding</p>
<h4 id="anr种类"><a href="#ANR种类" class="headerlink" title="ANR种类"></a><strong>ANR种类</strong><a href="#anr种类" class="header-anchor">#</a></h4><p><strong>1). Key Dispatch Timeout (8s)</strong></p>
<p>按键或触摸事件在特定时间内无响应（origin:5s）</p>
<p>KEY_DISPATCHING_TIMEOUT = 8*1000</p>
<p><strong>2) .Broadcast Timeout</strong></p>
<p>BroadcastReceiver在特定时间内无法处理完成</p>
<p>BROADCAST_FG_TIMEOUT: 10s</p>
<p>BROADCAST_BG_TIMEOUT: 60s</p>
<p>按键和广播事件时间内未响应，时间限定定义在<strong>ActivityManagerService.java</strong>类中</p>
<p><strong>3).Service Timeout （20s）——-小概率类型</strong></p>
<p>Service在特定的时间内无法处理完成</p>
<p>service时间内未响应时间限定在<strong>ActiveServices.java</strong>类中</p>
<p>SERVICE_TIMEOUT = 20*1000;</p>
<h4 id="anr原因"><a href="#ANR原因" class="headerlink" title="ANR原因"></a>ANR原因<a href="#anr原因" class="header-anchor">#</a></h4><p>1）应用进程有一个主线程（main thread）和一个信息队列(main message queue) main thead == activity thread</p>
<p>2）主线程负责处理像Draw、Listen、receive等UI事件</p>
<p>3）主线程负责从消息队列中取出信息并分发它</p>
<p>4）主线程在完成当前信息处理之前，不会再取信息队列中的信息</p>
<p>5）如果主线程在处理当前信息时卡住，没有及时分发，ANR就会出现</p>
<h4 id="anr的分析思路"><a href="#ANR的分析思路" class="headerlink" title="ANR的分析思路"></a>ANR的分析思路<a href="#anr的分析思路" class="header-anchor">#</a></h4><h5 id="工具准备"><a href="#工具准备-2" class="headerlink" title="工具准备"></a>工具准备<a href="#工具准备" class="header-anchor">#</a></h5><p>1 MTKlog，主要是其中的Aee_exp和MobileLog</p>
<p>2Trace.txt文件（data/anr目录下）或者bugreport日志（使用adb bugreport &gt; bugreport.txt或者GAT工具输出）</p>
<p>3BlockCanary，记录超时后的log</p>
<p>4一般当出现异常（JE\SWT\NE\KE等）时，会在手机中的/data/aee_exp目录下保存异常的db。 对于异常的类型和具体信息，需要通过GAT工具解析db档案</p>
<p>5.bugreport</p>
<p>6.aee_exp</p>
<h5 id="trace分析流程"><a href="#Trace分析流程" class="headerlink" title="Trace分析流程"></a>Trace分析流程<a href="#trace分析流程" class="header-anchor">#</a></h5><table>
<thead>
<tr>
<th>序号</th>
<th>步骤</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><img src="http://cdn.yangchaofan.cn/blog/20210227/iITTadTui5mQ.png?imageslim" alt="mark"></td>
</tr>
<tr>
<td></td>
<td><img src="http://cdn.yangchaofan.cn/blog/20210227/JwYHHTncMMip.png?imageslim" alt="mark"></td>
</tr>
<tr>
<td></td>
<td><img src="http://cdn.yangchaofan.cn/blog/20210227/VkiuF6SpNL7b.png?imageslim" alt="mark"></td>
</tr>
<tr>
<td></td>
<td><img src="http://cdn.yangchaofan.cn/blog/20210227/FwcDyrQFhFAa.png?imageslim" alt="mark"></td>
</tr>
<tr>
<td></td>
<td><img src="http://cdn.yangchaofan.cn/blog/20210227/poTh8Et0Or0w.png?imageslim" alt="mark"></td>
</tr>
<tr>
<td></td>
<td><img src="http://cdn.yangchaofan.cn/blog/20210227/5M4Dwh0H2ugg.png?imageslim" alt="mark"></td>
</tr>
<tr>
<td></td>
<td><img src="http://cdn.yangchaofan.cn/blog/20210227/2H8AlTBdueFO.png?imageslim" alt="mark"></td>
</tr>
<tr>
<td></td>
<td><img src="http://cdn.yangchaofan.cn/blog/20210227/Dl36A6cYlbzF.png?imageslim" alt="mark"></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="anr解决方案"><a href="#ANR解决方案" class="headerlink" title="ANR解决方案"></a>ANR解决方案<a href="#anr解决方案" class="header-anchor">#</a></h4><p>1)：UI线程尽量只做跟UI相关的工作</p>
<p>2)：耗时的工作（比如数据库操作，I/O，连接网络或者别的有可能阻碍UI线程的操作）把它放入单独的线程处理</p>
<p>3)：尽量用Handler来处理UIthread和别的thread之间的交互</p>
<h4 id="anr优化思路"><a href="#ANR优化思路" class="headerlink" title="ANR优化思路"></a>ANR优化思路<a href="#anr优化思路" class="header-anchor">#</a></h4><p>优化UI线程的任务：</p>
<p>1)：UI线程尽量只做跟UI相关的工作</p>
<p>2)：耗时的工作（比如数据库操作，I/O，连接网络或者别的有可能阻碍UI线程的操作）把它放入单独的线程处理</p>
<p>3)：尽量用Handler来处理UIthread和别的thread之间的交互</p>
<p>UI线程的主要任务是：</p>
<p>1).Activity:onCreate(), onResume(), onDestroy(), onKeyDown(), onClick()等</p>
<p>2).AsyncTask: onPreExecute(), onProgressUpdate(), onPostExecute(), onCancel等</p>
<p>3).Mainthread handler: handleMessage(), post*(runnable r)等</p>
<h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具<a href="#工具" class="header-anchor">#</a></h1><table>
<thead>
<tr>
<th>工具包名称</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>联发科MTK组件</td>
<td>MTKLogger</td>
</tr>
<tr>
<td></td>
<td>GAT</td>
</tr>
<tr>
<td></td>
<td>LogView</td>
</tr>
<tr>
<td></td>
<td>QAAT</td>
</tr>
<tr>
<td>BlockCanary</td>
<td>开源框架，卡顿日志</td>
</tr>
<tr>
<td>Android SDK</td>
<td>ADB LogCat</td>
</tr>
<tr>
<td></td>
<td>MAT</td>
</tr>
<tr>
<td>Android Studio</td>
<td>Profile</td>
</tr>
<tr>
<td></td>
<td>TraceView</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="adb"><a href="#adb" class="headerlink" title="adb"></a>adb<a href="#adb" class="header-anchor">#</a></h2><ol>
<li>adb logcat&gt;main.txt 重定向log</li>
<li>adb logcat -b main -v time&gt;app.log 打印应用程序的log</li>
<li>adb logcat -bradio -v time&gt; radio.log 打印射频相关的log，SIM STK 也会在里面，modem相关的ATcommand等。</li>
<li>adb logcat -bevents -v time 打印系统事件的日志，比如触屏事件；</li>
</ol>
<link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>Android</category>
        <category>BugFree</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>BugFree</tag>
      </tags>
  </entry>
  <entry>
    <title>《学习革命解读》心得</title>
    <url>/blog//2021/02/learn-relovation-notes/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍<a href="#书籍" class="header-anchor">#</a></h1><table>
<thead>
<tr>
<th>名称</th>
<th>详情</th>
</tr>
</thead>
<tbody><tr>
<td><strong>封面</strong></td>
<td><img src="http://cdn.yangchaofan.cn/q4YBAFxP4wGABmEDAADtx3MZXfQ102_b.jpg" width="50%" height="50%"></td>
</tr>
<tr>
<td><strong>作者</strong></td>
<td><a href="https://book.douban.com/search/%E5%88%98%E8%A8%80">刘言</a></td>
</tr>
<tr>
<td><strong>出版社</strong></td>
<td>青海人民出版社</td>
</tr>
<tr>
<td><strong>介绍</strong></td>
<td>书籍每一开分为左右两页，左侧为精华总结、心得、名人关于学习的见解，对人有启发；右侧是作者的解读，主要讲了：<br>实用的学习总论如正文的思考训练、数学学习方法；<br>走出学习的困境，消除错误学习观念、消除学习疲劳的方法，消除学习的三大障碍<br>快速学习法的20个事件，如控制大脑学习韵律节奏、通过五官影响学习感受</td>
</tr>
</tbody></table>
<a id="more"></a>

<h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记<a href="#笔记" class="header-anchor">#</a></h1><p>印象深刻值书钱的有两部分：数学学习法和思考训练法</p>
<h2 id="思考的训练"><a href="#思考的训练" class="headerlink" title="思考的训练"></a>思考的训练<a href="#思考的训练" class="header-anchor">#</a></h2><table>
<thead>
<tr>
<th>训练名称</th>
<th>描述</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>抽象与概括</td>
<td>对一类事物进行分析，总结出主要特征。</td>
<td>1-6岁，抽象概括大多数来自于实物，从苹果数量学习数字的抽象<br>6-12岁，抽象开阔来自于文字、符号，如角的特征是端点、射线、平面</td>
</tr>
<tr>
<td>分类</td>
<td>把具有相同特征的事物归成一类</td>
<td>单调函数有许多函数；反比例函数也包含很多函数</td>
</tr>
<tr>
<td>类比</td>
<td>从一事物的特征而联想到另一事物，并进行比较,通常需要联想+比较</td>
<td>看到鸟，想到飞机，比较鸟和飞机的不同<br>看到圆，想到圆柱体，比较两者不同</td>
</tr>
<tr>
<td>分析与综</td>
<td>思考一个概念时，必须联系其他概念，使用上述方法</td>
<td>做一个数学题，联想该题目有关的基础概念、基本解题思路<br> 数学学习一章节，画出该章的刚要、知识结构；画出与前面章节的联系，建立连接</td>
</tr>
<tr>
<td>绎与推理</td>
<td>根据已知条件，经过思考活动推导出的结论</td>
<td>借助包含关系推导，如数轴上a大于b，b大于c，则a大于c</td>
</tr>
</tbody></table>
<h1 id="数学学习法"><a href="#数学学习法" class="headerlink" title="数学学习法"></a>数学学习法<a href="#数学学习法" class="header-anchor">#</a></h1><p>##定义</p>
<p>描述了学习数学学科的方法</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法<a href="#方法" class="header-anchor">#</a></h2><h3 id="方法概览"><a href="#方法概览" class="headerlink" title="方法概览"></a>方法概览<a href="#方法概览" class="header-anchor">#</a></h3><table>
<thead>
<tr>
<th>名称</th>
<th>定义</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>数学归纳法</td>
<td>是证明与自然数有关的解题方法，先证明n取第一个值k0，k，k+1，分别证明命题为真，即可证明命题为真</td>
<td>证明等式<br>证明整除<br>证明不等式<br>证明数列通项公式<br>证明先猜想后结论的命题</td>
</tr>
<tr>
<td>因式分解法</td>
<td>把一个<a href="https://baike.baidu.com/item/%E5%A4%9A%E9%A1%B9%E5%BC%8F/10660961">多项式</a>在一个范围(如<a href="https://baike.baidu.com/item/%E5%AE%9E%E6%95%B0/296419">实数</a>范围内分解，即所有项均为实数)化为几个<a href="https://baike.baidu.com/item/%E6%95%B4%E5%BC%8F/5961855">整式</a>的积的形式，这种式子变形叫做这个多项式的因式分解，也叫作把这个多项式分解因式。</td>
<td>多项式化简<br>多项式相除<br>多项式分解<br>一元高次多项式方程求根<br>化简分式<br></td>
</tr>
<tr>
<td>分析综合法</td>
<td>从已知条件出发，逐步推理。是综合法。<br>从结论找条件，是分析法。<br></td>
<td>综合法是由已知找未知的解法<br>分析法是由结果找原因的方法<br>由果找因、由因找果的关键是找“可知”、“需知”的联系</td>
</tr>
<tr>
<td>分类讨论法</td>
<td>对象全体无法使用同一种方法去处理。必须分割为不重复、不遗漏的情况，分别求解</td>
<td>需要分类定义的概念如绝对值<br>需要分类描述的性质如幂函数、指数函数、对数函<br>需要对参数进行分类描述<br>图形相对位置的变化</td>
</tr>
<tr>
<td>变更问题法</td>
<td>将问题进行适当的变更，变为容易求解的问题</td>
<td>换元法<br>反证法<br>特殊化法<br>放缩变换，同乘、同除、同加、同减<br>用熟知的定力、公式、命题替换求解目标<br>分解简化欲证明的结论<br>替换等价问题<br>对图形平移、旋转、翻转、压缩变化，改变求解的范围<br>数形结合，用图形描述数字的规律</td>
</tr>
<tr>
<td>反证法</td>
<td>从否定结论出发，经过推理，得到与已知定理相矛盾的结果，并且矛盾的结果是由否定结论导致，故而得到原命题是不容否定的结论。</td>
<td>关于否定性结论的命题<br>唯一性结论的命题<br>至多、至少类结论命题<br>难以直接使用已知条件导出结论的命题</td>
</tr>
<tr>
<td>类比法</td>
<td>两个对象都有相同的属性，其中一个对象还有另外的属性是前提，做出这个对象也有这些属性的判断。</td>
<td>降维类比<br>结构类比<br>简化成比原题简单的类比<br>类比猜想</td>
</tr>
<tr>
<td>配方法</td>
<td>补充恰当的子项可以配成完全平方公式  <img src="http://cdn.yangchaofan.cn/clip_image001.png"></td>
<td>分解因式<br>化简二次根式<br>证明等式<br>证明不等式<br>解方程<br>解不等式<br>求函数的最值<br>解析几何问题<br></td>
</tr>
<tr>
<td>放缩法</td>
<td>处理数式问题，把某些项放大或缩小，舍弃或增加某些项，可以取得简化题目过程求解的效果</td>
<td>求极值<br>计算结果<br>解方程<br>解方程组<br>证明不等式<br></td>
</tr>
<tr>
<td>解析法</td>
<td>通过建立坐标系，把图形问题转化为点的坐标的数值问题</td>
<td>利用距离公式证明线段相等<br>利用定比分点公式证明比例关系<br>利用斜率证明两直线平行<br>利用斜率证明直线垂直<br>两直线夹角的正切公式证明角相等<br>利用两直线的交点坐标结合第三条直线方程证明三线共点<br>换元法</td>
</tr>
<tr>
<td>换元法</td>
<td>把某个数学式子看成新的未知数，将难题转化为已知的定理、公式</td>
<td>将数学式的整体代换<br>将数学式的整体代换<br>平均数代换<br>比值代换<br>对称代换<br>倒数代换<br>三角代换<br>不等量代换<br>常数代换<br>坐标代换</td>
</tr>
<tr>
<td>构造法</td>
<td>针对问题题型，构造该题型的辅助公式、图形</td>
<td>参考构造法策略说明</td>
</tr>
</tbody></table>
<h3 id="因式分解"><a href="#因式分解" class="headerlink" title="因式分解"></a>因式分解<a href="#因式分解" class="header-anchor">#</a></h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义<a href="#定义" class="header-anchor">#</a></h4><p>把一个<a href="https://baike.baidu.com/item/%E5%A4%9A%E9%A1%B9%E5%BC%8F">多项式</a>在一个范围化为几个<a href="https://baike.baidu.com/item/%E6%95%B4%E5%BC%8F">整式</a>的积的形式，这种式子变形叫做这个多项式的<strong>因式分解</strong>，也叫作把这个多项式分解因式。</p>
<h4 id="策略1"><a href="#策略-1" class="headerlink" title="策略[1]"></a>策略<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[百度百科因式分解](https://baike.baidu.com/item/%E5%9B%A0%E5%BC%8F%E5%88%86%E8%A7%A3/384402?fr=aladdin#1)">[1]</span></a></sup><a href="#策略1" class="header-anchor">#</a></h4><ol>
<li>▪ <a href="https://baike.baidu.com/item/%E5%9B%A0%E5%BC%8F%E5%88%86%E8%A7%A3/384402?fr=aladdin#4_1">提公因式法</a></li>
</ol>
<ol>
<li>▪ <a href="https://baike.baidu.com/item/%E5%9B%A0%E5%BC%8F%E5%88%86%E8%A7%A3/384402?fr=aladdin#4_2">公式法</a></li>
<li>▪ <a href="https://baike.baidu.com/item/%E5%9B%A0%E5%BC%8F%E5%88%86%E8%A7%A3/384402?fr=aladdin#4_3">十字相乘法</a></li>
<li>▪ <a href="https://baike.baidu.com/item/%E5%9B%A0%E5%BC%8F%E5%88%86%E8%A7%A3/384402?fr=aladdin#4_4">双十字相乘法</a></li>
<li>▪ <a href="https://baike.baidu.com/item/%E5%9B%A0%E5%BC%8F%E5%88%86%E8%A7%A3/384402?fr=aladdin#4_5">轮换对称法</a></li>
<li>▪ <a href="https://baike.baidu.com/item/%E5%9B%A0%E5%BC%8F%E5%88%86%E8%A7%A3/384402?fr=aladdin#4_6">分组分解法</a></li>
<li>▪ <a href="https://baike.baidu.com/item/%E5%9B%A0%E5%BC%8F%E5%88%86%E8%A7%A3/384402?fr=aladdin#4_7">拆添项法</a></li>
<li>▪ <a href="https://baike.baidu.com/item/%E5%9B%A0%E5%BC%8F%E5%88%86%E8%A7%A3/384402?fr=aladdin#4_8">配方法</a></li>
<li>▪ <a href="https://baike.baidu.com/item/%E5%9B%A0%E5%BC%8F%E5%88%86%E8%A7%A3/384402?fr=aladdin#4_9">因式定理法</a></li>
</ol>
<ol>
<li>▪ <a href="https://baike.baidu.com/item/%E5%9B%A0%E5%BC%8F%E5%88%86%E8%A7%A3/384402?fr=aladdin#4_10">换元法</a></li>
<li>▪ <a href="https://baike.baidu.com/item/%E5%9B%A0%E5%BC%8F%E5%88%86%E8%A7%A3/384402?fr=aladdin#4_11">综合除法</a></li>
<li>▪ <a href="https://baike.baidu.com/item/%E5%9B%A0%E5%BC%8F%E5%88%86%E8%A7%A3/384402?fr=aladdin#4_12">主元法</a></li>
<li>▪ <a href="https://baike.baidu.com/item/%E5%9B%A0%E5%BC%8F%E5%88%86%E8%A7%A3/384402?fr=aladdin#4_13">特殊值法</a></li>
<li>▪ <a href="https://baike.baidu.com/item/%E5%9B%A0%E5%BC%8F%E5%88%86%E8%A7%A3/384402?fr=aladdin#4_14">待定系数法</a></li>
<li>▪ <a href="https://baike.baidu.com/item/%E5%9B%A0%E5%BC%8F%E5%88%86%E8%A7%A3/384402?fr=aladdin#4_15">二次多项式</a></li>
</ol>
<h3 id="构造法"><a href="#构造法" class="headerlink" title="构造法"></a>构造法<a href="#构造法" class="header-anchor">#</a></h3><h4 id="定义"><a href="#定义-1" class="headerlink" title="定义"></a>定义<a href="#定义" class="header-anchor">#</a></h4><p>针对问题题型，构造该题型的辅助公式、图形</p>
<h4 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略<a href="#策略" class="header-anchor">#</a></h4><p>方程</p>
<p>函数</p>
<p>复数</p>
<p>数列</p>
<p>不等式</p>
<p>点</p>
<p>线段</p>
<p>三角形</p>
<p>正方形</p>
<p>圆</p>
<p>长方体</p>
<h3 id="换元法"><a href="#换元法" class="headerlink" title="换元法"></a>换元法<a href="#换元法" class="header-anchor">#</a></h3><h4 id="定义"><a href="#定义-2" class="headerlink" title="定义"></a>定义<a href="#定义" class="header-anchor">#</a></h4><p>把某个数学式子看成新的未知数，将难题转化为已知的定理、公式</p>
<h4 id="策略"><a href="#策略-1" class="headerlink" title="策略"></a>策略<a href="#策略" class="header-anchor">#</a></h4><p>将数学式的部分内容代换</p>
<p>将数学式的整体代换</p>
<p>平均数代换</p>
<p>比值代换</p>
<p>对称代换</p>
<p>倒数代换</p>
<p>三角代换</p>
<p>不等量代换</p>
<p>常数代换</p>
<p>坐标代换</p>
<h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途<a href="#用途" class="header-anchor">#</a></h3><p>解恒等变形的问题</p>
<p>解方程</p>
<p>解方程组</p>
<p>解不等式、证明不等式</p>
<p>求函数极值</p>
<p>解坐标变换</p>
<p>解微积分</p>
<h3 id="解析法"><a href="#解析法" class="headerlink" title="解析法"></a>解析法<a href="#解析法" class="header-anchor">#</a></h3><h4 id="定义"><a href="#定义-3" class="headerlink" title="定义"></a>定义<a href="#定义" class="header-anchor">#</a></h4><p>通过建立坐标系，把图形问题转化为点的坐标的数值问题</p>
<h4 id="用途"><a href="#用途-1" class="headerlink" title="用途"></a>用途<a href="#用途" class="header-anchor">#</a></h4><p>利用距离公式证明线段相等</p>
<p>利用定比分点公式证明比例关系</p>
<p>利用斜率证明两直线平行</p>
<p>利用斜率证明直线垂直</p>
<p>利用两直线夹角的正切公式证明角相等</p>
<p>利用三角形坐标面积公式证明第三点坐标适合前两点连线方程证明三点共线</p>
<p>利用两直线的交点坐标结合第三条直线方程证明三线共点</p>
<p>换元法</p>
<h3 id="放缩法"><a href="#放缩法" class="headerlink" title="放缩法"></a>放缩法<a href="#放缩法" class="header-anchor">#</a></h3><h4 id="定义"><a href="#定义-4" class="headerlink" title="定义"></a>定义<a href="#定义" class="header-anchor">#</a></h4><p>处理数式问题，把某些项放大或缩小，舍弃或增加某些项，可以取得简化题目过程求解的效果</p>
<h4 id="用途"><a href="#用途-2" class="headerlink" title="用途"></a>用途<a href="#用途" class="header-anchor">#</a></h4><p>求极值</p>
<p>计算结果</p>
<p>解方程</p>
<p>解方程组</p>
<p>证明不等式</p>
<h3 id="配方法"><a href="#配方法" class="headerlink" title="配方法"></a>配方法<a href="#配方法" class="header-anchor">#</a></h3><h4 id="定义"><a href="#定义-5" class="headerlink" title="定义"></a>定义<a href="#定义" class="header-anchor">#</a></h4><p>补充恰当的子项可以配成完全平方公式  <img src="http://cdn.yangchaofan.cn/clip_image001.png"></p>
<h4 id="用途"><a href="#用途-3" class="headerlink" title="用途"></a>用途<a href="#用途" class="header-anchor">#</a></h4><p>分解因式</p>
<p>化简二次根式</p>
<p>证明等式</p>
<p>证明不等式</p>
<p>解方程</p>
<p>解不等式</p>
<p>求函数的最值</p>
<p>解析几何问题</p>
<h3 id="类比法"><a href="#类比法" class="headerlink" title="类比法"></a>类比法<a href="#类比法" class="header-anchor">#</a></h3><h4 id="定义"><a href="#定义-6" class="headerlink" title="定义"></a>定义<a href="#定义" class="header-anchor">#</a></h4><p>两个对象都有相同的属性，其中一个对象还有另外的属性是前提，做出这个对象也有这些属性的判断。</p>
<h4 id="策略"><a href="#策略-2" class="headerlink" title="策略"></a>策略<a href="#策略" class="header-anchor">#</a></h4><p>降维类比</p>
<p>结构类比</p>
<p>简化成比原题简单的类比</p>
<p>类比猜想</p>
<h3 id="反证法"><a href="#反证法" class="headerlink" title="反证法"></a>反证法<a href="#反证法" class="header-anchor">#</a></h3><h4 id="定义"><a href="#定义-7" class="headerlink" title="定义"></a>定义<a href="#定义" class="header-anchor">#</a></h4><p>从否定结论出发，经过推理，得到与已知定理相矛盾的结果，并且矛盾的结果是由否定结论导致，故而得到原命题是不容否定的结论。</p>
<h4 id="用途"><a href="#用途-4" class="headerlink" title="用途"></a>用途<a href="#用途" class="header-anchor">#</a></h4><p>关于否定性结论的命题</p>
<p>唯一性结论的命题</p>
<p>至多、至少类结论命题</p>
<p>难以直接使用已知条件导出结论的命题<img src="file:///C:/Users/lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image001.png" alt="img"></p>
<h3 id="变更问题法"><a href="#变更问题法" class="headerlink" title="变更问题法"></a>变更问题法<a href="#变更问题法" class="header-anchor">#</a></h3><p>又称化繁为简</p>
<h4 id="定义"><a href="#定义-8" class="headerlink" title="定义"></a>定义<a href="#定义" class="header-anchor">#</a></h4><p>将问题进行适当的变更，变为容易求解的问题</p>
<h4 id="策略"><a href="#策略-3" class="headerlink" title="策略"></a>策略<a href="#策略" class="header-anchor">#</a></h4><p>换元法</p>
<p>反证法</p>
<p>特殊化法</p>
<p>用熟知的定力、公式、命题替换求解目标</p>
<p>分解简化欲证明的结论</p>
<p>替换等价问题</p>
<p>对图形平移、旋转、翻转、压缩变化，改变求解的范围</p>
<p>数形结合，用图形描述数字的规律</p>
<p>放缩变换，同乘、同除、同加、同减</p>
<h3 id="数学归纳法"><a href="#数学归纳法" class="headerlink" title="数学归纳法"></a>数学归纳法<a href="#数学归纳法" class="header-anchor">#</a></h3><h4 id="定义"><a href="#定义-9" class="headerlink" title="定义"></a>定义<a href="#定义" class="header-anchor">#</a></h4><p>是证明与自然数有关的解题方法，先证明n取第一个值k0，k，k+1，分别证明命题为真，即可证明命题为真</p>
<h4 id="用途"><a href="#用途-5" class="headerlink" title="用途"></a>用途<a href="#用途" class="header-anchor">#</a></h4><p>证明等式</p>
<p>证明整除</p>
<p>证明不等式</p>
<p>证明数列通项公式</p>
<p>证明先猜想后结论的命题</p>
<h3 id="分析综合法"><a href="#分析综合法" class="headerlink" title="分析综合法"></a>分析综合法<a href="#分析综合法" class="header-anchor">#</a></h3><h4 id="定义"><a href="#定义-10" class="headerlink" title="定义"></a>定义<a href="#定义" class="header-anchor">#</a></h4><p>从已知条件出发，逐步推理。是综合法。</p>
<p>综合法是由已知找未知的解法</p>
<p>从结论找条件，是分析法。</p>
<p>分析法是由结果找原因的方法。</p>
<h4 id="用途"><a href="#用途-6" class="headerlink" title="用途"></a>用途<a href="#用途" class="header-anchor">#</a></h4><p>由果找因、由因找果的关键是找“可知”、“需知”的联系</p>
<h3 id="分类讨论法"><a href="#分类讨论法" class="headerlink" title="分类讨论法"></a>分类讨论法<a href="#分类讨论法" class="header-anchor">#</a></h3><h4 id="定义"><a href="#定义-11" class="headerlink" title="定义"></a>定义<a href="#定义" class="header-anchor">#</a></h4><p>对象全体无法使用同一种方法去处理。必须分割为不重复、不遗漏的情况，分别求解。</p>
<h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤<a href="#步骤" class="header-anchor">#</a></h4><p>确定标准</p>
<p>恰当分类</p>
<p>逐类讨论</p>
<p>归纳结论</p>
<h4 id="用途"><a href="#用途-7" class="headerlink" title="用途"></a>用途<a href="#用途" class="header-anchor">#</a></h4><p>需要分类定义的概念如绝对值</p>
<p>需要分类描述的性质如幂函数、指数函数、对数函数</p>
<p>需要对参数进行分类描述</p>
<p>图形相对位置的变化</p>
<h3 id="知识体系"><a href="#知识体系" class="headerlink" title="知识体系"></a>知识体系<a href="#知识体系" class="header-anchor">#</a></h3><h3 id="配图"><a href="#配图" class="headerlink" title="配图"></a>配图<a href="#配图" class="header-anchor">#</a></h3><p>流程图、概念图、思维导图、学科专业配图等</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结<a href="#总结" class="header-anchor">#</a></h1><p>本书读了几章，有什么收获，对之前知识点有什么影响，对未来的什么方面有影响</p>
<p>可以把什么知识点用在什么地方，可以获得哪些利益，潜在风险是什么</p>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://baike.baidu.com/item/%E5%9B%A0%E5%BC%8F%E5%88%86%E8%A7%A3/384402?fr=aladdin#1">百度百科因式分解</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>家庭教育</category>
        <category>学习方法</category>
      </categories>
      <tags>
        <tag>学习方法</tag>
      </tags>
  </entry>
  <entry>
    <title>《高效学习方法全集》日记</title>
    <url>/blog//2021/02/super-learn-skills/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="高效学习方法全集高中版"><a href="#高效学习方法全集高中版" class="headerlink" title="高效学习方法全集高中版"></a>高效学习方法全集高中版<a href="#高效学习方法全集高中版" class="header-anchor">#</a></h1><table>
<thead>
<tr>
<th>名称</th>
<th>详情</th>
</tr>
</thead>
<tbody><tr>
<td><strong>封面</strong></td>
<td><img src="http://cdn.yangchaofan.cn/%E9%AB%98%E6%95%88%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E9%AB%98%E4%B8%AD%E7%89%88.jpg" width="50%" height="50%"></td>
</tr>
<tr>
<td><strong>作者</strong></td>
<td>新教育学习研究机构</td>
</tr>
<tr>
<td><strong>出版社</strong></td>
<td>湖北教育出版社</td>
</tr>
<tr>
<td><strong>介绍</strong></td>
<td>此书有许多状元的学习经验方法总结。譬如预习一节，关于预习的3个目的；譬如复习一节，黄金五分钟和睡前复习法，譬如如何做题一章有做题的禁忌、题目的选择、做题的时机、做题的思考、最后总结等</td>
</tr>
</tbody></table>
<a id="more"></a>

<h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记<a href="#笔记" class="header-anchor">#</a></h1><h1 id="预习"><a href="#预习" class="headerlink" title="预习"></a>预习<a href="#预习" class="header-anchor">#</a></h1><p>##定义</p>
<p>是学习的第一步，作为听课的前置条件。</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法<a href="#方法" class="header-anchor">#</a></h2><h3 id="预习的目的"><a href="#预习的目的" class="headerlink" title="预习的目的"></a>预习的目的<a href="#预习的目的" class="header-anchor">#</a></h3><p>知晓当前章节的知识结构，准确知道老师讲的内容在知识结构的那一位置</p>
<p>跟旧章节知识建立联系，混淆、易错的地方集中精力克服</p>
<p>通过课后题检验预习的结果</p>
<p>跟上老师的节奏，超过老师的节奏，集中精力和时间思考重点、难点</p>
<p>提前知晓课本上有什么</p>
<p>老师讲的内容是否是课本上的，有选择性的记课本上没有的内容笔记</p>
<p>记老师反复提及的笔记</p>
<p>记听不懂的</p>
<h3 id="预习的内容"><a href="#预习的内容" class="headerlink" title="预习的内容"></a>预习的内容<a href="#预习的内容" class="header-anchor">#</a></h3><p>知识结构</p>
<p>基本概念、定力</p>
<p>复述知识</p>
<p>做课后题，标出错误、不会做、看不懂的地方</p>
<p>整理提问列表</p>
<p>##知识体系</p>
<p>预习-听课-练习-复习-总结</p>
<p>##配图</p>
<p>暂无：流程图、概念图、思维导图、学科专业配图等</p>
<h1 id="如何复习"><a href="#如何复习" class="headerlink" title="如何复习"></a>如何复习<a href="#如何复习" class="header-anchor">#</a></h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义<a href="#定义" class="header-anchor">#</a></h2><p>复习是指学习全流程过程中，复述回忆所处流程的内容，通常在每个步骤都会发生复习行为。</p>
<h2 id="方法"><a href="#方法-1" class="headerlink" title="方法"></a>方法<a href="#方法" class="header-anchor">#</a></h2><p><strong>黄金5分钟：</strong>下课后立刻复习，这节课主要内容是什么，老师是如何引导知识点的，中间是如何推导的，最后是如何总结的，老师用了哪些思维技巧，如何将老师讲的内容放入自己的知识结构</p>
<p><strong>利用目录</strong>，能否根据目录复述</p>
<p><strong>利用知识体系结构</strong>，能复述整张知识体系，每个知识细节，每个知识点的关联</p>
<p><strong>睡前闭眼复习法</strong>：第一节课讲了数学，数学讲了1-5个知识点，第一个知识点是xx；第二即可是历史，讲了法国大革命，背景是，过程是，意义是；第三节课是自习，做了两套题，错题是，错的概念是，解决思路是</p>
<h1 id="如何听音频"><a href="#如何听音频" class="headerlink" title="如何听音频"></a>如何听音频<a href="#如何听音频" class="header-anchor">#</a></h1><h2 id="定义"><a href="#定义-1" class="headerlink" title="定义"></a>定义<a href="#定义" class="header-anchor">#</a></h2><p>音频作为摄取知识的一种介质，可以重复听，可根据遍数、吸收程度调节音频进度、播放速度</p>
<h2 id="方法"><a href="#方法-2" class="headerlink" title="方法"></a>方法<a href="#方法" class="header-anchor">#</a></h2><p><strong>五遍法</strong></p>
<p>第一遍，光听不看文本</p>
<p>第二遍，把自己听到的东西写下来</p>
<p>第三遍，边方录音，边对照自己写的内容，找出错误的，确实的</p>
<p>第四遍，一边听，一边跟读</p>
<p>第五遍，不看文本，跟着音频朗读</p>
<h1 id="如何学数学"><a href="#如何学数学" class="headerlink" title="如何学数学"></a>如何学数学<a href="#如何学数学" class="header-anchor">#</a></h1><h2 id="定义"><a href="#定义-2" class="headerlink" title="定义"></a>定义<a href="#定义" class="header-anchor">#</a></h2><p>描述了学习数学的推荐方法</p>
<h2 id="方法"><a href="#方法-3" class="headerlink" title="方法"></a>方法<a href="#方法" class="header-anchor">#</a></h2><p>例题要重读，重复读概念、定理、公式、知识结构</p>
<p>多本书跳着读，同一概念，这本书看不懂，看看其他参考书怎么说的。</p>
<h1 id="如何考试"><a href="#如何考试" class="headerlink" title="如何考试"></a>如何考试<a href="#如何考试" class="header-anchor">#</a></h1><h2 id="定义"><a href="#定义-3" class="headerlink" title="定义"></a>定义<a href="#定义" class="header-anchor">#</a></h2><p>描述了考试的基本原则和策略</p>
<h2 id="方法"><a href="#方法-4" class="headerlink" title="方法"></a>方法<a href="#方法" class="header-anchor">#</a></h2><p>考试的原则：得分优先，随难度、耗时跳过部分</p>
<p>考试的原则: 通揽试卷，简单、难易分布心中有数</p>
<h1 id="如何做题"><a href="#如何做题" class="headerlink" title="如何做题"></a>如何做题<a href="#如何做题" class="header-anchor">#</a></h1><h2 id="定义"><a href="#定义-4" class="headerlink" title="定义"></a>定义<a href="#定义" class="header-anchor">#</a></h2><p>描述了做题的流程，做题的基本步骤和注意事项</p>
<h2 id="方法"><a href="#方法-5" class="headerlink" title="方法"></a>方法<a href="#方法" class="header-anchor">#</a></h2><h3 id="做题的禁忌"><a href="#做题的禁忌" class="headerlink" title="做题的禁忌"></a>做题的禁忌<a href="#做题的禁忌" class="header-anchor">#</a></h3><p>禁止一道题做15分钟以上</p>
<p>禁止一道题思考3分钟以上</p>
<p>禁止背诵一个段落20分钟以上，超过限定时间就跳过</p>
<h3 id="题目的选择"><a href="#题目的选择" class="headerlink" title="题目的选择"></a>题目的选择<a href="#题目的选择" class="header-anchor">#</a></h3><p>基础题</p>
<p>例题</p>
<p>母题</p>
<p>考试原题</p>
<h3 id="做题的时机"><a href="#做题的时机" class="headerlink" title="做题的时机"></a>做题的时机<a href="#做题的时机" class="header-anchor">#</a></h3><p>预习后</p>
<p>课堂听讲后，复习完毕知识后</p>
<p>老师讲了什么公式、定力，如何推导的，老师讲了哪些例题，例题有哪些解法，例题的解题思路是什么，例题的突破点在哪里</p>
<h3 id="做题时的思考"><a href="#做题时的思考" class="headerlink" title="做题时的思考"></a>做题时的思考<a href="#做题时的思考" class="header-anchor">#</a></h3><p>题目是否隐含了命题意图</p>
<p>题目是否隐含了答题方向</p>
<p>该题考查什么知识点，哪一类型知识点</p>
<p>是否碰到过类似的题</p>
<p>此类题型通常可以采用哪种可行方法</p>
<p>此类题的基本解题思路是什么？解题突破点是什么？第一步做什么，第二部做什么。</p>
<p>推导过程是否合理，考虑情况是否全面？</p>
<p>这道题是否有价值，对考试有什么帮助</p>
<p>这一类提问方式是否有规律，是否有固定的答题方法，如提问求角的余弦值，就是考察三余弦定力</p>
<h3 id="做题后的总结"><a href="#做题后的总结" class="headerlink" title="做题后的总结"></a>做题后的总结<a href="#做题后的总结" class="header-anchor">#</a></h3><p>对题目归类，放入例题、母题、基础题、错题中</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结<a href="#总结" class="header-anchor">#</a></h1><p>此书有许多状元的学习经验方法总结。譬如预习、如何做题、如何听音频、如何学数学、如何考试等。可以当做小技术点融入到自己的做题步骤、预习步骤中。</p>
<link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>家庭教育</category>
        <category>学习方法</category>
      </categories>
      <tags>
        <tag>学习方法</tag>
      </tags>
  </entry>
  <entry>
    <title>《如何高效学习》心得</title>
    <url>/blog//2021/02/study-more-efficiency/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="如何高效学习"><a href="#如何高效学习" class="headerlink" title="如何高效学习"></a>如何高效学习<a href="#如何高效学习" class="header-anchor">#</a></h1><table>
<thead>
<tr>
<th><strong>名称</strong></th>
<th><strong>详情</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>封面</strong></td>
<td><img src="http://cdn.yangchaofan.cn/s27172838.jpg" width="25%"></td>
</tr>
<tr>
<td><strong>作者</strong></td>
<td>[<a href="https://book.douban.com/author/625722/">加拿大] 斯科特·扬</a></td>
</tr>
<tr>
<td><strong>出版社</strong></td>
<td>机械工业出版社</td>
</tr>
<tr>
<td><strong>介绍</strong></td>
<td>“学习的最高原则：定义出学习的活动，并做到它们”<br>如何用整体学习法学会作者提倡的整体学习法？如何用比喻记住比喻技术——比喻法-光线摄入眼球，眼球对光的感觉，视网膜的感觉，大脑对光的感觉，大脑中的声音<br><img src="http://cdn.yangchaofan.cn/biyufa.png" width="20%"><br>当我的思维库里有如此多的思维技术，我该如何运用呢？<br>学习理论和学习技术是整体性学习策略的重要组成部分，它俩同等重要，没有先后。<br>我喜欢在这两个技术中融入自己的学习方法，如《学习革命的解读》、《超效学方法解码》、《高效学习方法全集》中的一些方法。<br>将“学习理论”和“学习技术”应用实践到生活中去是非常必要的步骤，我喜欢做一些智力挑战、智力思维训练巩固我的整体性学习策略。<br>我需要选择，选择将哪些技术当作我习惯技术——好比趁手的兵器。<br>我需要问为什么，当前场景下为什么需要使用这种技术，而不用其他技术；<br>我需要练习薄弱的思维，我思维弱项是处理抽象数据、数学公式等，那我就要着重训练内在化、随意信息的处理。<br></td>
</tr>
</tbody></table>
<a id="more"></a>

<h1 id="整体性学习技术"><a href="#整体性学习技术" class="headerlink" title="整体性学习技术"></a>整体性学习技术<a href="#整体性学习技术" class="header-anchor">#</a></h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义<a href="#定义" class="header-anchor">#</a></h2><p>整体性学习是一种学习理论，通过结构-模型-高速公路三种概念描述了大脑是如何运转，是作者斯科特杨结合自身一年通过MIT33门考试得来的学习方法实践。</p>
<h2 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分<a href="#组成部分" class="header-anchor">#</a></h2><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构<a href="#结构" class="header-anchor">#</a></h3><p>结构是指优秀的知识地图，在各个坐标物之间建立尽可能多$N : N$的关系。</p>
<h4 id="好的结构例子"><a href="#好的结构例子" class="headerlink" title="好的结构例子"></a>好的结构例子<a href="#好的结构例子" class="header-anchor">#</a></h4><table>
<thead>
<tr>
<th>名称</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>感知结构</td>
<td>你的五官摄取的声音、视觉图像、情感构成了最直接的感知结构</td>
</tr>
<tr>
<td>关系结构</td>
<td>思维导图、逻辑树、组织结构图等关系，能最简洁的表达出关系结构</td>
</tr>
<tr>
<td>数学结构</td>
<td>成熟的数学结构是最好的模型工具</td>
</tr>
</tbody></table>
<img src="http://cdn.yangchaofan.cn/jiegou.png" width="50%">

<h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型<a href="#模型" class="header-anchor">#</a></h3><p>模型是地图上的坐标物，是简化的地图，是地图上的一个个快照、坐标点。具体来说，模型是压缩过后的概念。<strong>是一份没有建立各个点之间联系的坐标系</strong>。比喻法是最好的建立模型的工具。<img src="http://cdn.yangchaofan.cn/model.png" width="50%"></p>
<p><strong>模型更抽象也是解释更具体的得例子</strong></p>
<img src="http://cdn.yangchaofan.cn/qipan.png" width="50%">

<h3 id="高速公路"><a href="#高速公路" class="headerlink" title="高速公路"></a>高速公路<a href="#高速公路" class="header-anchor">#</a></h3><p>高速公路是将知识地图链接起来的最佳力量。通过使用比喻法、联想法能建立强有力的知识链接。</p>
<img src="http://cdn.yangchaofan.cn/freeway.png" width="50%">

<h2 id="顺序"><a href="#顺序" class="headerlink" title="顺序"></a>顺序<a href="#顺序" class="header-anchor">#</a></h2><table>
<thead>
<tr>
<th>阶段名称</th>
<th>定义</th>
<th>步骤</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>获取</td>
<td>通过五官摄取知识的必要步骤</td>
<td>简化:规律法、分解小问题、缩小范文等记忆方法在这一步非常关键<br>容量:容量比精读，有的时候更有用，读100本书比读1-2本知道的多<br>速度:30分钟读完一篇文章比1个小时读完，大脑的吸收率前者高后者低<br></td>
<td></td>
</tr>
<tr>
<td>理解</td>
<td>是理解的初级阶段，主要为理解语言表面意思</td>
<td>使用基本的语言能力存储知识</td>
<td>认识数学符号的意义，死记硬背文言文、数学定理等</td>
</tr>
<tr>
<td>拓展</td>
<td>是理解的中级阶段，大多数无法到达这一步<br><font color="red">也是整体性学习方法的真正开始第一步</font><br>运用它解决实际生活问题；了解它的推导过程，背景意义,了解每个组成部分的真实含义；了解可以改变哪些成分，改变会产生怎样变化；了解它与其他概念的相同、不同之处。</td>
<td>深度扩展:在它的内部找寻联系，它的组成部分能产生怎样联系？<br>横向扩展：类似的结论、相反的结论；结论的事实、在其他维度类似的结论…<br>纵向扩展：比喻法、内在和是最好的方法，如奶牛和女人皮肤<br></td>
<td></td>
</tr>
<tr>
<td>纠错</td>
<td>是理解的高级阶段</td>
<td></td>
<td>生物进化模拟公司演化存在问题，要有发现问题的能力<br></td>
</tr>
<tr>
<td>应用</td>
<td>将知识运用于实践</td>
<td></td>
<td>如SMART法管理企业、5W法做策划案，编程做游戏</td>
</tr>
<tr>
<td>测试</td>
<td>主要测试以上各个步骤</td>
<td>测验获取阶段:我以前看过这个知识吗？<br>测验理解阶段:我现在知道知识的字面含义吗<br>测验拓展阶段:我知道知识从哪里推导吗，与那些知识有联系吗?<br>测验纠错阶段:我有发现不恰当的联系并删除吗？<br>测试应用阶段：我将知识用到了生活中哪些方面？</td>
<td></td>
</tr>
<tr>
<td>复盘</td>
<td>以上环节哪一个是弱项；每天用整体学习法，哪一点做得不够好</td>
<td>1.不擅长获取吗？<br>不擅长理解吗？<br>不擅长拓展吗？<br>我今天又做纠错吗<br>我今天有将知识运用到生活吗<br></td>
<td></td>
</tr>
</tbody></table>
<h2 id="获取知识"><a href="#获取知识" class="headerlink" title="获取知识"></a>获取知识<a href="#获取知识" class="header-anchor">#</a></h2><h3 id="定义"><a href="#定义-1" class="headerlink" title="定义"></a><strong>定义</strong><a href="#定义" class="header-anchor">#</a></h3><p>通过你的五官获取知识，如双眼、眼神经、大脑，将书本、音频、视频内容存入在脑海中。</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法<a href="#方法" class="header-anchor">#</a></h3><h4 id="阅读法"><a href="#阅读法" class="headerlink" title="阅读法"></a>阅读法<a href="#阅读法" class="header-anchor">#</a></h4><p><strong>以下方法练习频率：一个月为单位，任意材料，每天15分钟指读法、15分钟练习阅读法、15分钟积极阅读法</strong></p>
<table>
<thead>
<tr>
<th><div style="width: 10%">方法名称 </div></th>
<th><div style="width: 20%">定义    </div></th>
<th><div style="width: 30%">实践步骤 </div></th>
<th><div style="width: 20%">优点 </div></th>
<th><div style="width: 20%"> 缺点 </div></th>
</tr>
</thead>
<tbody><tr>
<td>指读法</td>
<td>手指按着课本，每一行一个字一个字的滑动过去，边滑边用眼睛看</td>
<td><img src="http://cdn.yangchaofan.cn/zhidufa.png" width="50%"></td>
<td>手指提供控制眼睛阅读速度、眼睛聚焦精准的能力</td>
<td>1.前期不熟练的情况下，阅读速度较慢；<br>2.不适合手机、PC、Web，只时和书本</td>
</tr>
<tr>
<td>练习阅读法</td>
<td>训练尽可能快的速度理解内容，而非记住、吸收该内容</td>
<td><strong>3分钟训练法</strong><br>1.挑选课本<br>2.在内容上指定位置开始，设定3分钟闹钟，设为a<br>3.在该位置开始阅读,直到时间结束，计算3分钟阅读的总字数，大约为行数*单行平均字数，设为b<br>4.求出阅读速度 $v=a/b$<br>5.在该位置开始阅读，直到时间结束，尽可能多的记下知识点（不翻书的情况），写到列表中R<br>6.再度一遍教材，记录所有的知识点，写到列表Q中<br>7.比对列表R和Q，写出正确的知识点个数T、错误的知识点个数E<br>8.求出正确率 $t=T/Q$ ,错误率$e=E/Q$</td>
<td>1.可以量化阅读速度、正确率、错误率<br></td>
<td>1.比指读法耗时；<br>2.需要大量练习</td>
</tr>
<tr>
<td>积极阅读法</td>
<td></td>
<td>1.准备:阅读材料、笔记本<br>2.阅读完一页或3分钟，在笔记本回答3个问题<br>3.1这一部分的主题是什么？<br>3.2我怎样才能记住主题部分观点？<br>3.2我如何做才能拓展及应用这部分主题<br></td>
<td>3.1促使你准确获取信息<br>3.2迫使你使用联系法、视觉法、比喻法<br>3.3强迫你应用到不同场景中</td>
<td>非常耗时，需要大量练习</td>
</tr>
</tbody></table>
<p><strong>积极阅读法的例子</strong></p>
<p>读完心理学的条件反射。回答3个问题</p>
<p>1.这一部分的主题是什么？</p>
<ul>
<li>反射的发现者是巴甫洛夫</li>
<li>反射的的条件是刺激引发反应</li>
</ul>
<p>2.我该怎样才能记住这部分观点？</p>
<ul>
<li>相像一幅图画，画中是巴甫洛夫的身体，脖子上长着狗头，嘴巴张开漏出了舌头</li>
</ul>
<p>3.我该怎样拓展这部分主题？</p>
<ul>
<li>听到电视机里的手机铃声，我会不受控制的掏出自己手机查看</li>
</ul>
<h4 id="笔记流"><a href="#笔记流" class="headerlink" title="笔记流"></a>笔记流<a href="#笔记流" class="header-anchor">#</a></h4><h5 id="笔记流定义"><a href="#笔记流定义" class="headerlink" title="笔记流定义"></a><strong>笔记流定义</strong><a href="#笔记流定义" class="header-anchor">#</a></h5><p>提供一个画面、绘图文件，用来联系学到的东西。通常未划线、画圈。</p>
<h5 id="笔记流的原则"><a href="#笔记流的原则" class="headerlink" title="笔记流的原则"></a><strong>笔记流的原则</strong><a href="#笔记流的原则" class="header-anchor">#</a></h5><p>通过重复训练，达到一次学会,在听课时不关注笔记是否漂亮，只关注笔记效果和笔记的目的。</p>
<p>禁止写冗长段落，用短语替代完整句子，降低可读性。减少时间、细节、过程等用词。</p>
<p>画出主题、主题之间间联系箭头、关系用短语描述，最终整理出一张网状图。</p>
<h5 id="笔记流的难点"><a href="#笔记流的难点" class="headerlink" title="笔记流的难点"></a><strong>笔记流的难点</strong><a href="#笔记流的难点" class="header-anchor">#</a></h5><p>记录技术的扩展：融合联想、对比、比喻法</p>
<p>记录信息的选择：什么是重点，什么是核心，什么是难点，什么是考点</p>
<p>记录信息的删减：删除哪些信息，重新建立联系</p>
<p>以下方法练习频率：2周内，每天练习1次，课堂听课使用混合型笔记流，建立课堂上的知识点联系；下课后写一份课下笔记流，重新梳理知识点联系。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>定义</th>
<th>步骤</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>混合型笔记流</td>
<td>课堂听课时记录的笔记</td>
<td>1.画出主题短语<br>2.减少段落内容、减少长句<br>3..使用箭头、箭头描述在主体间建立联系<br>4.多使用配图和图标、符号</td>
<td>保持思路紧跟课堂节奏</td>
<td>损失少量笔记精度</td>
</tr>
<tr>
<td>课下笔记流</td>
<td>下课后根据课堂内容、参考资料整理出的笔记</td>
<td>1.传统的线性式笔记，兼顾可读性和礼节性</td>
<td>1.最完整，最详细的笔记<br>2.学习初期强烈推进使用课下笔记流+混合笔记流两份笔记的形式</td>
<td>耗时</td>
</tr>
<tr>
<td>评注流</td>
<td>课题听课时候信息量大，导致跟不上的采用的笔记方式</td>
<td>1.只写老师评语、个人评语、主题<br>2.只写评语之间的联系</td>
<td>比混合型笔记写的内容少，速度更快，更容易跟上信息量大的课堂场景</td>
<td>损失笔记的精度</td>
</tr>
</tbody></table>
<h5 id="笔记流的例子"><a href="#笔记流的例子" class="headerlink" title="笔记流的例子"></a>笔记流的例子<a href="#笔记流的例子" class="header-anchor">#</a></h5><table>
<thead>
<tr>
<th>名称</th>
<th>例子</th>
<th>总结</th>
</tr>
</thead>
<tbody><tr>
<td><strong>综合笔笔记流的例子</strong></td>
<td><img src="http://cdn.yangchaofan.cn/zonghebijiliu.png" width="50%" height="50%"></td>
<td></td>
</tr>
<tr>
<td>内在化的笔记流</td>
<td><img src="http://cdn.yangchaofan.cn/%E8%AE%A9%E7%AC%A6%E5%8F%B7%E5%8A%A8%E8%B5%B7%E6%9D%A5%20%E7%9A%84%E7%AC%94%E8%AE%B0%E6%B5%81.png"></td>
<td></td>
</tr>
<tr>
<td>压缩笔记流的例子</td>
<td><img src="http://cdn.yangchaofan.cn/%E7%AC%94%E8%AE%B0%E5%8E%8B%E7%BC%A9%E7%A4%BA%E4%BE%8B.png" width="50%"></td>
<td></td>
</tr>
<tr>
<td>流程图笔记流的例子</td>
<td><img src="http://cdn.yangchaofan.cn/%E6%B5%81%E7%A8%8B%E5%9B%BE%2B%E6%AF%94%E5%96%BB%E6%B3%95%E7%9A%84%E7%BB%BC%E5%90%88%E7%AC%94%E8%AE%B0%E6%B5%81.png"></td>
<td></td>
</tr>
</tbody></table>
<h2 id="联系观点"><a href="#联系观点" class="headerlink" title="联系观点"></a>联系观点<a href="#联系观点" class="header-anchor">#</a></h2><h3 id="定义"><a href="#定义-2" class="headerlink" title="定义"></a>定义<a href="#定义" class="header-anchor">#</a></h3><p>联系观点是一组步骤的统称，包括<font color="red">理解</font>和<font color="red">拓展</font>两个步骤。<strong>主要用途</strong>是<font color="red">将信息转化为知识模型的过程</font></p>
<h3 id="方法"><a href="#方法-1" class="headerlink" title="方法"></a>方法<a href="#方法" class="header-anchor">#</a></h3><table>
<thead>
<tr>
<th>名称</th>
<th>定义</th>
<th>步骤</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>比喻</td>
<td>将物体与其他物体联系在一起，将不熟悉的知识和熟悉的知识建立桥梁</td>
<td>1.确定要理解的信息，a<br>2.在个人经验、知识库中找与信息相似的东西，直到找十几个相似的知识，Q<br>3.重复上述过程，修改集合Q中的知识，并描述a和Q中元素的联系</td>
<td>1.在两个物体身上找到一点相似的地方<br>2.视觉、听觉、感觉、过程、原理、情感、声音</td>
<td>容易忘记使用比喻</td>
</tr>
<tr>
<td>视觉</td>
<td>适合抽象信息</td>
<td></td>
<td>能将抽象信息变得具体</td>
<td></td>
</tr>
<tr>
<td>内在化</td>
<td>适合具体信息</td>
<td></td>
<td>赋予知识情感、五官的感觉，如变重变轻、变快、气味、音调、光亮强度</td>
<td></td>
</tr>
<tr>
<td>比喻内在化</td>
<td>将比喻、内在化、视觉方法融为一体</td>
<td>综上3个步骤</td>
<td></td>
<td></td>
</tr>
<tr>
<td>图表法</td>
<td>组合图表展现内容<br>常见类型有3种：流程图、概念图、图像</td>
<td>学习对应的图表绘制方式</td>
<td>重复训练可以达到1分钟画一幅粗略图表</td>
<td>非常耗时</td>
</tr>
<tr>
<td>图表内在化</td>
<td>将图表法+比喻内在化融为一体</td>
<td>综上全部步骤</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="比喻"><a href="#比喻" class="headerlink" title="比喻"></a>比喻<a href="#比喻" class="header-anchor">#</a></h4><h5 id="定义"><a href="#定义-3" class="headerlink" title="定义"></a>定义<a href="#定义" class="header-anchor">#</a></h5><p>将一个物体与另外一个物体联系起来的工具。如女性身材和沙漏比喻，形容女性身材曼妙，沙子不停向下流淌；肌肉壮的像头牛。</p>
<h5 id="比喻的技巧"><a href="#比喻的技巧" class="headerlink" title="比喻的技巧"></a><strong>比喻的技巧</strong><a href="#比喻的技巧" class="header-anchor">#</a></h5><p>有<font color="red"><strong>找寻比喻的意识</strong></font>，在整体学习每一步都使用比喻，在阅读信息的时候比喻</p>
<p>有<font color="red"><strong>找到更好比喻的意识</strong></font>，每次比喻都列举10-20个比喻，直到找个最好的哪个</p>
<p>有<font color="red"><strong>修改比喻的意识</strong></font>，没有合适的比喻，就在列举出的比喻中修改，改成合适的</p>
<p>有<font color="red"><strong>测试比喻的意识</strong></font>，每次使用比喻，都要检查是否理解错误，改善理解错误的比喻</p>
<h5 id="比喻的例子"><a href="#比喻的例子" class="headerlink" title="比喻的例子"></a><strong>比喻的例子</strong><a href="#比喻的例子" class="header-anchor">#</a></h5><p>女性身体-沙漏</p>
<p>男性肌肉-公牛</p>
<p>女性皮肤-牛奶</p>
<p>条件反射-狗吐舌头</p>
<p>条件反射-雪地里找脚印的路</p>
<p>导数-汽车仪表盘里程表和速度表</p>
<h5 id="比喻的练习"><a href="#比喻的练习" class="headerlink" title="比喻的练习"></a>比喻的练习<a href="#比喻的练习" class="header-anchor">#</a></h5><p>每个主题写20个比喻。</p>
<p>每个主题写20个比喻后修改5个比喻</p>
<p>将比喻讲给其他人听，别人是否能理解。</p>
<h4 id="内在化"><a href="#内在化" class="headerlink" title="内在化"></a>内在化<a href="#内在化" class="header-anchor">#</a></h4><h5 id="定义"><a href="#定义-4" class="headerlink" title="定义"></a>定义<a href="#定义" class="header-anchor">#</a></h5><p>将知识转化未视觉、听觉、动觉的信息。</p>
<h5 id="内在化技巧"><a href="#内在化技巧" class="headerlink" title="内在化技巧"></a>内在化技巧<a href="#内在化技巧" class="header-anchor">#</a></h5><table>
<thead>
<tr>
<th>步骤</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>清楚的描述概念</td>
<td>生物学过程还是面向对象的代码</td>
</tr>
<tr>
<td>在脑海中建立图像</td>
<td>手写图案，脑海中画出图案</td>
</tr>
<tr>
<td>脑海中让图案动起来</td>
<td>行列式想象成左右手搬东西，搬东西需要左手先，右手后</td>
</tr>
<tr>
<td>调动身体其他器官与图像建立联系</td>
<td>脚步、身体躯干弯腰、挺直身体等，张开嘴咬，伸出鼻子闻</td>
</tr>
<tr>
<td>加入情感</td>
<td>悲伤、恐惧、兴趣盎然、害怕，如砸到脚、高兴的跳起来</td>
</tr>
<tr>
<td>调整图案的运动模式、调整身体的动作、调整情感</td>
<td>优化上述步骤</td>
</tr>
</tbody></table>
<h5 id="内在化的例子"><a href="#内在化的例子" class="headerlink" title="内在化的例子"></a><strong>内在化的例子</strong><a href="#内在化的例子" class="header-anchor">#</a></h5><p>行列式计算-使用右手、左手搬物体，感觉变轻了</p>
<p>比喻法-光线摄入眼球，眼球对光的感觉，视网膜的感觉，大脑对光的感觉，大脑中的声音</p>
<img src="http://cdn.yangchaofan.cn/biyufa.png" width="20%">



<h2 id="随意信息的处理"><a href="#随意信息的处理" class="headerlink" title="随意信息的处理"></a>随意信息的处理<a href="#随意信息的处理" class="header-anchor">#</a></h2><h3 id="定义"><a href="#定义-5" class="headerlink" title="定义"></a>定义<a href="#定义" class="header-anchor">#</a></h3><p>作者将学习类信息分为5种，随意信息作为其中之一。具体表现未抽象的信息：</p>
<ul>
<li>日期</li>
<li>解剖学术语</li>
<li>编程术语</li>
<li>数学符号</li>
<li>公司规章制度</li>
<li>科学公式</li>
</ul>
<h3 id="方法"><a href="#方法-2" class="headerlink" title="方法"></a>方法<a href="#方法" class="header-anchor">#</a></h3><p>推荐联想法和笔记流法(上文提到)。</p>
<h4 id="联想法"><a href="#联想法" class="headerlink" title="联想法"></a>联想法<a href="#联想法" class="header-anchor">#</a></h4><p>联想法有以下三步，每一步都需要重复找到最佳实践。</p>
<table>
<thead>
<tr>
<th>步骤</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>将信息写成一个线性的清单，罗列成一组最小化信息</td>
<td>$V=1+X/b$写成如下清单:<br>V=1；<br>加上；<br>X；<br>除以；<br>b</td>
</tr>
<tr>
<td>给清单中的每一项设定有实际意义的物体图像</td>
<td>V=1，一只手胜利姿势;<br>x，X战警<br>b,气泡枪；<br></td>
</tr>
<tr>
<td>创建每个物体的联系</td>
<td>胜利姿势与X战警的联系是，X战警战胜了坏蛋，举着胜利手势；<br>X战警与气泡枪的联系是，X战警另外一只手扛着气泡枪<br></td>
</tr>
</tbody></table>
<p><strong>联想步骤示例</strong></p>
<img src="http://cdn.yangchaofan.cn/liantiao-联想法示例.png" width="50%">

<p><strong>注意事项</strong></p>
<table>
<thead>
<tr>
<th>难点</th>
<th>解决办法</th>
</tr>
</thead>
<tbody><tr>
<td>符号重复</td>
<td>改进符号，给符号加上不同颜色，如红色a、蓝色a</td>
</tr>
<tr>
<td>联系断裂</td>
<td>重复练习<br>联系链长度适中5-15个最佳</td>
</tr>
<tr>
<td>符号难以辨认回忆</td>
<td>改进符号，使用一般受欢迎的的常识，减少特殊场景的物体</td>
</tr>
<tr>
<td>触发点丢失</td>
<td>重复练习<br>将知识标题加入联系链中<br></td>
</tr>
</tbody></table>
<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习<a href="#练习" class="header-anchor">#</a></h3><p>每天设定时间按照步骤练习3-5个公式、3-5个定理、3-5个长句子等。</p>
<h2 id="知识的延伸"><a href="#知识的延伸" class="headerlink" title="知识的延伸"></a>知识的延伸<a href="#知识的延伸" class="header-anchor">#</a></h2><h3 id="定义"><a href="#定义-6" class="headerlink" title="定义"></a>定义<a href="#定义" class="header-anchor">#</a></h3><p>延伸是整体性学习的最后一步。用于将知识应用到实际生活。延伸是一种创造性过程，这个过程没有固定步骤。你需要结合你的生活经验、已经习得知识进行联想、比喻、内在化，直至动手实践它。</p>
<h3 id="方法"><a href="#方法-3" class="headerlink" title="方法"></a>方法<a href="#方法" class="header-anchor">#</a></h3><h4 id="生活应用"><a href="#生活应用" class="headerlink" title="生活应用"></a>生活应用<a href="#生活应用" class="header-anchor">#</a></h4><p>以下是作者经常用来延伸的方法，即将新习得的内容，延伸至以下几个领域；也可以通过模仿表格提供的例子，将习得的知识延伸到具体生活中去。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>例子</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>统计学</td>
<td>利用统计学知识，通过搜索引擎，统计竞品书记字数、价格、书名，给我即将出版的付费文字制定价格。</td>
<td>跟生活结合</td>
</tr>
<tr>
<td>会计学</td>
<td>利用会计知识，理清个人资产、负债情况，预测未来收益、负债，以及自己可承担的负债上限等</td>
<td>跟生活结合</td>
</tr>
<tr>
<td>计算机</td>
<td>计算机科学编写、调试、运行、纠错都是可以借鉴的学习思想；编写程序可以锻炼理性思维；算法可以用来提高生活效率</td>
<td>跟工作结合</td>
</tr>
</tbody></table>
<h5 id="练习"><a href="#练习-1" class="headerlink" title="练习"></a>练习<a href="#练习" class="header-anchor">#</a></h5><p>将习得的新知识，花5-10分钟罗列生活中20个用处。写有创意的思路，尽可能实践这些想法。</p>
<h4 id="纠错"><a href="#纠错" class="headerlink" title="纠错"></a>纠错<a href="#纠错" class="header-anchor">#</a></h4><h5 id="定义"><a href="#定义-7" class="headerlink" title="定义"></a>定义<a href="#定义" class="header-anchor">#</a></h5><p>纠错是发现问题，让事情回到正规，让自己对知识的理解回到正规上的唯一办法。</p>
<h5 id="方法"><a href="#方法-4" class="headerlink" title="方法"></a>方法<a href="#方法" class="header-anchor">#</a></h5><table>
<thead>
<tr>
<th>名称</th>
<th>定义</th>
<th>例子</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>分类法</td>
<td>分清楚是书写错误还是概念理解错误<br></td>
<td>1.模型建立不当<br>2.比喻不当<br>3.模型之间的联系描述错误<br>4.粗心写错了内容<br></td>
<td>简单的错误用简单的方法重复大量练习；复杂的概念理解错误，需要仔细查看整体学习步骤，查看每一个环节模型定义、比喻法、内在化过程是否有理解或使用错误</td>
</tr>
<tr>
<td>散弹枪法</td>
<td>单位时间内，每一个知识的测试都做一做<br></td>
<td>1.主题下有3个知识，3分钟把3个知识的测试都做一做；10分钟把3个知识实践以下，最后发现3个知识的问题<br>2.广泛测试主题下的每个知识，重复实践每个知识</td>
<td>发现每个知识的不同问题；多发现不同知识的不同问题</td>
</tr>
<tr>
<td>日历法</td>
<td>每一天都做练习，禁止考前集中做</td>
<td>1.每天、每周做一遍练习题，类似天考、周考、月考、</td>
<td>每天花3分钟练习所学知识，比考前一礼拜练习全部知识有效果</td>
</tr>
</tbody></table>
<blockquote>
<p>比喻法记住上面三个方法：分类法-在红豆和绿豆中分类出红豆；散弹枪法-把红豆装进散弹枪；日历法-将装满红豆的散弹枪对着日历射击，射中的天数可以出去游玩。</p>
</blockquote>
<h4 id="做实际项目"><a href="#做实际项目" class="headerlink" title="做实际项目"></a>做实际项目<a href="#做实际项目" class="header-anchor">#</a></h4><p>做实际项目是学会知识最佳途径，理解 、做题什么的都不如它有效果。如果有足够多的时间，可以规划做一些真实项目检验你所学的知识。</p>
<table>
<thead>
<tr>
<th>知识名称</th>
<th>实际项目</th>
<th>目标</th>
</tr>
</thead>
<tbody><tr>
<td>编程</td>
<td>设计1个需要1个月完成的项目，比如一个日历APP、美颜APP等</td>
<td>发布上架<br>推广宣传获得100个用户<br></td>
</tr>
<tr>
<td>历史</td>
<td>设计需要1个月完成的具体历史问题的论文</td>
<td>5000字<br>100赞<br>阅读量50000<br></td>
</tr>
<tr>
<td>财务会计</td>
<td>设计需要1个月完成的优化某个公司财务的方案</td>
<td></td>
</tr>
<tr>
<td>学习方法</td>
<td>设计需要7天完成的学习数学的方法合集</td>
<td>数学知识描述<br>学数学的步骤<br>思想<br>故事联想<br>数学实际知识应用<br></td>
</tr>
</tbody></table>
<h1 id="费曼技巧"><a href="#费曼技巧" class="headerlink" title="费曼技巧"></a>费曼技巧<a href="#费曼技巧" class="header-anchor">#</a></h1><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途<a href="#用途" class="header-anchor">#</a></h2><p><strong>理解那些你没有真正掌握的知识点</strong></p>
<p><strong>记住你能理解，却在考试忘掉的知识点</strong></p>
<h2 id="方法"><a href="#方法-5" class="headerlink" title="方法"></a>方法<a href="#方法" class="header-anchor">#</a></h2><table>
<thead>
<tr>
<th>名称</th>
<th>实践</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>选择要学习的概念</td>
<td>对于该概念，要有深入理解的动机<br>拿白纸，在中间写下概念名称<br></td>
<td></td>
</tr>
<tr>
<td>设想你是老师，正在试图教会一个新生知识点</td>
<td>对于该新生，你要当作纯小白、小学生<br><font color="red">把你的解释过程录音、写文字记录下来。记住这一步至关重要</font><br>因为在自我解释那些你认为已经理解或不理解的知识的过程中，你会理解的更好，原先混淆的地方也得以理清 <br></td>
<td></td>
</tr>
<tr>
<td>询问自己是否有疑惑</td>
<td>如果有请停止向下学习，返回至学习步骤，重新阅读参考材料，听讲座，找老师解答。直到搞懂位置</td>
<td></td>
</tr>
<tr>
<td>整体化学习技巧</td>
<td>比喻、内在化、联想法、笔记流，重新理解它。</td>
<td></td>
</tr>
</tbody></table>
<h1 id="高效率学生"><a href="#高效率学生" class="headerlink" title="高效率学生"></a>高效率学生<a href="#高效率学生" class="header-anchor">#</a></h1><p>斯科特杨认为高效率的学生应该有以下特点：</p>
<table>
<thead>
<tr>
<th>特点</th>
<th>特点解释</th>
</tr>
</thead>
<tbody><tr>
<td>能量管理</td>
<td>1.增加日常能量储备：<br>每周3-5次运动，每次40分钟；<br>每天7-8小时睡眠<br>禁止高糖、高脂肪、高蛋白质食物<br>建议粗纤维、粗加工食物<br>一天7杯水<br>多餐、少吃、每餐7分饱<br>2.2/8原则<br>20%的时间处理不重要的事情，80%的时间处理重要的事情<br>重要的事情只做1-2件<br>精力充沛的时间点做重要的事情<br>3.番茄闹钟，25+5原则<br></td>
</tr>
<tr>
<td>不要“学习”</td>
<td>1.不要表演“学习”,即不要嘴里没有东西，还要假装在吃个不停。<br>2.要买菜、摘菜、洗菜、炒菜、夹菜、咀嚼、消化、吸收，去做学习（吃饭）应该做的事情<br>3.学习的最高原则：定义出学习的活动，并做到它们：<br>整体学习法规定的每个活动</td>
</tr>
<tr>
<td>绝不拖延</td>
<td>周日目标体系法<br>甘特图法<br>2/8法<br></td>
</tr>
<tr>
<td>批处理</td>
<td>20%的时间处理以下事情：不重要的、单个时间小于1小时<br>不重要的任务：一次性完成，不要拆分到多个时间段<br></td>
</tr>
<tr>
<td>有组织</td>
<td>关键事件组织规划一些：<br>随身笔记本，随时记、日积月累<br>任务日历、甘特图、思维导图工具的便捷打开方式<br></td>
</tr>
</tbody></table>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结<a href="#总结" class="header-anchor">#</a></h1><p>学习理论和学习技术是整体性学习策略的重要组成部分，它俩同等重要，没有先后。</p>
<p>我喜欢在这两个技术中融入自己的学习方法，如《学习革命的解读》、《超效学方法解码》、《高效学习方法全集》中的一些方法。</p>
<p>将“学习理论”和“学习技术”应用实践到生活中去是非常必要的步骤，我喜欢做一些智力挑战、智力思维训练巩固我的整体性学习策略。</p>
<p>当我的思维库里有如此多的思维技术，我该如何运用呢？</p>
<p>我需要选择，选择将哪些技术当作我习惯技术——好比趁手的兵器。</p>
<p>我需要问为什么，当前场景下为什么需要使用这种技术，而不用其他技术；</p>
<p>我需要练习薄弱的思维，我思维弱项是处理抽象数据、数学公式等，那我就要着重训练内在化、随意信息的处理。</p>
<link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>家庭教育</category>
        <category>学习方法</category>
      </categories>
      <tags>
        <tag>学习方法</tag>
      </tags>
  </entry>
  <entry>
    <title>《超效学习方法解码》心得</title>
    <url>/blog//2021/02/chao-xiao-xue-xi-fang-fa-jie-ma/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="超效学习方法解码"><a href="#《超效学习方法解码》" class="headerlink" title="《超效学习方法解码》"></a>《超效学习方法解码》<a href="#超效学习方法解码" class="header-anchor">#</a></h1><table>
<thead>
<tr>
<th>名称</th>
<th>详情</th>
</tr>
</thead>
<tbody><tr>
<td><strong>封面</strong></td>
<td><img src="http://cdn.yangchaofan.cn/gaoxiao%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95.jpg" width="50%" height="50%"></td>
</tr>
<tr>
<td><strong>作者</strong></td>
<td>曹婷</td>
</tr>
<tr>
<td><strong>出版社</strong></td>
<td>星火教育研究院</td>
</tr>
<tr>
<td><strong>介绍</strong></td>
<td>分为学习基础篇、学习修炼篇、学习问题对症篇；学习对症篇主要解决语文、数学、英文、历史、政治的疑难杂症；学习修炼篇提供了预习、听课、复习、做题的基本思路，克服困难的方法；学习基础篇主要讲了时间管理、注意力管理、记忆力的小技巧。</td>
</tr>
</tbody></table>
<a id="more"></a>

<h1 id="如何预习"><a href="#如何预习" class="headerlink" title="如何预习"></a>如何预习<a href="#如何预习" class="header-anchor">#</a></h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义<a href="#定义" class="header-anchor">#</a></h2><p>预习是学习行为的第一步，在预习之后才能展开听课行为。</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法<a href="#方法" class="header-anchor">#</a></h2><p>阅读主题知识结构，理解知识结构</p>
<p>基本概念定理，理解内容</p>
<p>复述记忆，一页一记法复述知识</p>
<p>课后练习，理解困难，做题困难，看不懂</p>
<p>整理问题列表，用于听课过程中解答</p>
<h1 id="如何听课"><a href="#如何听课" class="headerlink" title="如何听课"></a>如何听课<a href="#如何听课" class="header-anchor">#</a></h1><h2 id="定义"><a href="#定义-1" class="headerlink" title="定义"></a>定义<a href="#定义" class="header-anchor">#</a></h2><p>听课行为发生于预习行为之后，听课是一种吸收知识的行为，具体行为表现为听音频、看视频、阅读教材讲义等文字内容、动手实践等</p>
<p>听课的动机目的是</p>
<ul>
<li>解决预习过程中遇到的问题，</li>
<li>完善预习后建立的知识体系，</li>
<li>利用听课时间背诵重点知识，</li>
<li>有选择的跳过非核心知识背诵。</li>
</ul>
<h2 id="方法"><a href="#方法-1" class="headerlink" title="方法"></a>方法<a href="#方法" class="header-anchor">#</a></h2><p><strong>解答问题列表：</strong>使用预习后准备的提问列表，在听课中解决提问</p>
<p><strong>背诵时机选择：</strong>已经听懂的知识，但没记住；此时在讲不重要的知识，则可以背诵前面重要的知识</p>
<p>预习过后已经看懂的主题，听课中可以集中精力背诵该主题，减少听的时间</p>
<p>听课中，抽出精力背诵重点精华内容，老师重复讲的，章节段落核心，讲解思路，老师对知识点联系的描述，重点，难点，画外音，<strong>以及课本上没有的内容</strong></p>
<p><strong>符号笔记：</strong>听课中，老师提到的内容，<strong>如果在课本已有</strong>，用符号标记如波浪线、三角号、着重号标记；<strong>如果课本没有</strong>，则记住关键字，课后提问、搜索引擎。</p>
<h1 id="如何学数学"><a href="#如何学数学" class="headerlink" title="如何学数学"></a>如何学数学<a href="#如何学数学" class="header-anchor">#</a></h1><h2 id="定义"><a href="#定义-2" class="headerlink" title="定义"></a>定义<a href="#定义" class="header-anchor">#</a></h2><p>数学是一门抽象思维学科，有着独特的描述语言和符号</p>
<h2 id="方法"><a href="#方法-2" class="headerlink" title="方法"></a>方法<a href="#方法" class="header-anchor">#</a></h2><h2 id="如何做例题"><a href="#如何做例题" class="headerlink" title="如何做例题"></a>如何做例题<a href="#如何做例题" class="header-anchor">#</a></h2><h3 id="定义"><a href="#定义-3" class="headerlink" title="定义"></a>定义<a href="#定义" class="header-anchor">#</a></h3><p>例题是基础题，一般为简单题，主要用于表现定理、公式的基本特征，可用于训练解题步骤</p>
<h3 id="方法"><a href="#方法-3" class="headerlink" title="方法"></a>方法<a href="#方法" class="header-anchor">#</a></h3><p>将例题当做训练解题步骤的母题</p>
<h3 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤<a href="#解题步骤" class="header-anchor">#</a></h3><h4 id="审题"><a href="#审题" class="headerlink" title="审题"></a>审题<a href="#审题" class="header-anchor">#</a></h4><p>了解题意</p>
<p>获取题目直接条件：概念常用的性质、特定条件、函数的定义域、值域、方程变量的取值范围、图形的取值范围</p>
<p>分析题目隐含条件</p>
<p>明确题目考察要求</p>
<p>找寻数学基本工具，概念、公式、定理</p>
<h4 id="求解"><a href="#求解" class="headerlink" title="求解"></a>求解<a href="#求解" class="header-anchor">#</a></h4><p><strong>联想条件的直接结论</strong>，可根据直接条件联想条件可得出的结论；根据结论再联想它对应的结论；可重复联系对应结论；</p>
<p><strong>溯源结论推导过程</strong>，条件-推导过程-结论-结论推出的结论-结论的结论推导出的结论，有时考察的并非条件、结论，考察的是推导过程，所以要溯源推导过程，过程中的变量、不变量是解题的关键</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结<a href="#总结" class="header-anchor">#</a></h4><p>题目条件的总结：直接条件的获取方式、间接条件的推导过程，思考去掉条件，会引起什么变化；思考逆向推导的能力，即由结论找寻条件的过程；总结题目的描述规律、考察规律、解题步骤、题型划分等</p>
<h2 id="如何检验答案"><a href="#如何检验答案" class="headerlink" title="如何检验答案"></a>如何检验答案<a href="#如何检验答案" class="header-anchor">#</a></h2><h3 id="定义"><a href="#定义-4" class="headerlink" title="定义"></a>定义<a href="#定义" class="header-anchor">#</a></h3><p>检验答案正确性，是做题的关键步骤，必要时会导致答案的修改</p>
<h3 id="方法"><a href="#方法-4" class="headerlink" title="方法"></a>方法<a href="#方法" class="header-anchor">#</a></h3><h4 id="方法1基本概念检验法"><a href="#方法1基本概念检验法" class="headerlink" title="方法1基本概念检验法"></a>方法1基本概念检验法<a href="#方法1基本概念检验法" class="header-anchor">#</a></h4><p>概念性错误是最容易忽视的，基本概念、法则、公式的适用条件是否满足，是否位于边界情况，都是要严格检查的。</p>
<h4 id="方法2对称原理检验法"><a href="#方法2对称原理检验法" class="headerlink" title="方法2对称原理检验法"></a>方法2对称原理检验法<a href="#方法2对称原理检验法" class="header-anchor">#</a></h4><p>对称的公式、定理，势必导致结论的对称，利用对称原理可以快速检验反比例函数和二次函数的答案</p>
<h4 id="方法3特殊情形检验法"><a href="#方法3特殊情形检验法" class="headerlink" title="方法3特殊情形检验法"></a>方法3特殊情形检验法<a href="#方法3特殊情形检验法" class="header-anchor">#</a></h4><p>特殊值、特例、极端情况是检验答案的快捷方法</p>
<h4 id="方法4不变量检验法"><a href="#方法4不变量检验法" class="headerlink" title="方法4不变量检验法"></a>方法4不变量检验法<a href="#方法4不变量检验法" class="header-anchor">#</a></h4><p>某一类数学问题在变化、变形过程中，有的量保持不变，不变的量可以验证答案的正确性。</p>
<p>如图形旋转、平移、翻转时，图形面积、体积不变。</p>
<h4 id="方法5等价关系检验法"><a href="#方法5等价关系检验法" class="headerlink" title="方法5等价关系检验法"></a>方法5等价关系检验法<a href="#方法5等价关系检验法" class="header-anchor">#</a></h4><p>等价替换答案，检验正确性</p>
<h4 id="方法6逻辑推理检验法"><a href="#方法6逻辑推理检验法" class="headerlink" title="方法6逻辑推理检验法"></a>方法6逻辑推理检验法<a href="#方法6逻辑推理检验法" class="header-anchor">#</a></h4><h4 id="方法7整体检验法"><a href="#方法7整体检验法" class="headerlink" title="方法7整体检验法"></a>方法7整体检验法<a href="#方法7整体检验法" class="header-anchor">#</a></h4><h4 id="方法8数学结合检验法"><a href="#方法8数学结合检验法" class="headerlink" title="方法8数学结合检验法"></a>方法8数学结合检验法<a href="#方法8数学结合检验法" class="header-anchor">#</a></h4><h4 id="方法9一题多解检验法"><a href="#方法9一题多解检验法" class="headerlink" title="方法9一题多解检验法"></a>方法9一题多解检验法<a href="#方法9一题多解检验法" class="header-anchor">#</a></h4><h4 id="反复10草稿运算步骤核查法"><a href="#反复10草稿运算步骤核查法" class="headerlink" title="反复10草稿运算步骤核查法"></a>反复10草稿运算步骤核查法<a href="#反复10草稿运算步骤核查法" class="header-anchor">#</a></h4><h2 id="写数学日记"><a href="#写数学日记" class="headerlink" title="写数学日记"></a>写数学日记<a href="#写数学日记" class="header-anchor">#</a></h2><h3 id="日记内容"><a href="#日记内容" class="headerlink" title="日记内容"></a>日记内容<a href="#日记内容" class="header-anchor">#</a></h3><p>事件日记：学习中自己感兴趣的活动、故事、事件、主题知识，受到了什么启发，得到了哪些锻炼，自己有什么感受</p>
<p>引导日记：课堂中老师的引导过程、例题推导过程，自己内心有什么感受</p>
<p>练习日记：习题、考试后的心得，哪些做得好，哪些做得不好，改正的步骤，自己五官有什么感受</p>
<h3 id="日记要求"><a href="#日记要求" class="headerlink" title="日记要求"></a>日记要求<a href="#日记要求" class="header-anchor">#</a></h3><p>简练的描述自己的感受</p>
<p>简练的描述主题知识和内容，详细的部分放在笔记里</p>
<p>将感受和主题知识联系起来</p>
<h1 id="如何学政治"><a href="#如何学政治" class="headerlink" title="如何学政治"></a>如何学政治<a href="#如何学政治" class="header-anchor">#</a></h1><p>##定义</p>
<p>描述了学习政治学科的方法</p>
<h2 id="方法"><a href="#方法-5" class="headerlink" title="方法"></a>方法<a href="#方法" class="header-anchor">#</a></h2><p><strong>画知识体系图：</strong>以单元标题-章节标题-框标题-小标题-自然段为<strong>主</strong>题，画思维导图，建立每个知识点的联系。</p>
<p>谁是知识体系的基础：自然段是知识体系的基础，只有理解自然段才能建立<strong>主题知识体系</strong>。</p>
<p><strong>能够提问，层层发问：</strong>政治内容，每句话都有前因后果。每个自然段，不断问“是什么”，“为什么”，“怎么办”。</p>
<p>层层发文的目的：让一个段落诞生几句话，一个段落扩展成几个段落，最终建立主题之间的联系，形成知识体系。</p>
<p><strong>无法发问，使用推理：</strong>无法通过提问找寻主题关系的，只能通过归纳、演绎，抽象得推导出主题之间的关系。</p>
<p><strong>带着提问，问题列表</strong>：手写提问列表，加深阅读的印象，减少阅读的思考负担。</p>
<p>##知识体系</p>
<p>主题-提问-推理-主题建立联系-根据联系绘制思维导图</p>
<p>##配图</p>
<p>暂无：流程图、概念图、思维导图、学科专业配图等</p>
<h1 id="如何做题"><a href="#如何做题" class="headerlink" title="如何做题"></a>如何做题<a href="#如何做题" class="header-anchor">#</a></h1><h2 id="定义"><a href="#定义-5" class="headerlink" title="定义"></a>定义<a href="#定义" class="header-anchor">#</a></h2><p>描述了做题的基本流程，前后步骤。</p>
<h2 id="方法"><a href="#方法-6" class="headerlink" title="方法"></a>方法<a href="#方法" class="header-anchor">#</a></h2><p><strong>范围选择：</strong>课后题、例题、错题、考试真题</p>
<p><strong>先后顺序：</strong>书中主题内容看懂，再做题。</p>
<p><strong>时间原则：</strong>做题时要限时，题目时间分配合理，阻塞的题目立刻跳过</p>
<p>**开始原则:**做题任务计时开始，就立刻做，不拖延</p>
<p><strong>收尾原则：</strong>题目做完后，只有反思总结，才能得到收益</p>
<ul>
<li>反思错误：错误原因、没有思路原因、做不出来原因</li>
<li>反思题意：条件、问题、结论，三者联系</li>
<li>反思方法：将题目解题思路融入解题的积累中</li>
<li>反思变化：条件、问题、结论，三者变化后练习</li>
</ul>
<h1 id="如何提高解题速度"><a href="#如何提高解题速度？" class="headerlink" title="如何提高解题速度？"></a>如何提高解题速度？<a href="#如何提高解题速度" class="header-anchor">#</a></h1><p>只有<strong>熟悉主题</strong>（概念、定义、公式、定力），才能做好简单的题目。</p>
<p>只有<strong>做好基本题</strong>，才能做好复杂题。</p>
<p>只有<strong>熟悉主题之间的联系</strong>，才能做好综合题。</p>
<p>只有<strong>掌握基本的解题步骤、解题方法</strong>，才能做好对应的题型。</p>
<p>只有<strong>事后做好归纳总结</strong>（题型归类、基本步骤、解题方法、隐含条件、隐含结论），才能积累考题题型，做到不重不漏。</p>
<p>只有<strong>学会数学工具（画图等10几个数学工具）</strong>，才能翻译出题目的考点。</p>
<p>只有<strong>记住上述内容</strong>，才能提高解题速度。</p>
<h1 id="总结"><a href="#总结-1" class="headerlink" title="总结"></a>总结<a href="#总结" class="header-anchor">#</a></h1><p>本书读完，最大的收获是预习、听课、学政治、学数学、如何做题五个方面。</p>
<p>听课给我的启发是：在预习的基础上，对课堂所讲知识结构心中有数，能轻易的跟上、超过老师的讲课节奏，在充分预习的基础上，可以利用课堂时间背诵重点、难点、核心点，利用听课时间、老师的思路引导知识记忆，可以充分提高学习效率。</p>
<p>尤其是学数学，提倡的<label style="color:green"><strong>数学日记</strong></label>让我很意外，也很开心，事事都可以写日记，日记不同于笔记，更加自由，口语化，能更融入个人的情感，激发具象思维，提升学习兴趣。利于孩童学习，也利于成人读书。</p>
<p>学习数学一节，如何做题的思路也启发了我，提醒我做题应当分为审题、解题、总结三步骤。审题和总结是大多数容易忽视的，不可轻敌，解题中的两个方法联想隐藏条件法和溯源推导过程找间接条件法对我也启发很大，提示我们做题要正向条件-结论思考，也要反向结论-推导过程-条件思考，有时隐藏条件就在推导过程中，而非题目本身给出的直接条件。</p>
<link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>家庭教育</category>
        <category>学习方法</category>
      </categories>
      <tags>
        <tag>学习方法</tag>
      </tags>
  </entry>
  <entry>
    <title>程序员吃的是青春饭吗？</title>
    <url>/blog//2021/02/Is%20coder%20need%20more%20younger%EF%BC%9F/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="程序员吃的是青春饭吗"><a href="#程序员吃的是青春饭吗？" class="headerlink" title="程序员吃的是青春饭吗？"></a>程序员吃的是青春饭吗？<a href="#程序员吃的是青春饭吗" class="header-anchor">#</a></h1><p>昨天在知乎上看到一个提问<a href="https://www.zhihu.com/question/444102247">“程序员为什么是吃青春饭，而不是像医生律师一样越老越值钱？”</a></p>
<p>翻了一百多个回答，大多答主都是顺着题主的逻辑假定答的</p>
<p>即许多人都是心中假设此前提成立：“程序员是吃青春饭”、“律师医生越老越值钱”</p>
<p>基于“程序员确实吃青春饭”很容易可以得到以下这些“由果倒因”“贩卖焦虑”的观点：</p>
<ol>
<li>医生可以独立出售个人价值，程序员不行</li>
<li>医生知识更新慢，程序员知识更新快</li>
<li>医生是非劳动密集，程序员是劳动密集</li>
<li>医生卖的是个人服务，程序员卖的是coding能力</li>
<li>医生服务的是人，程序员服务的是计算机</li>
</ol>
<p>可如果题主或答主们的前提假定是错的呢？</p>
<p>如果存在“程序员越老越值钱”的事实呢？<a id="more"></a></p>
<h1 id="医生可以独立出售个人价值程序员不行"><a href="#医生可以独立出售个人价值，程序员不行" class="headerlink" title="医生可以独立出售个人价值，程序员不行"></a>医生可以独立出售个人价值，程序员不行<a href="#医生可以独立出售个人价值程序员不行" class="header-anchor">#</a></h1><p>全科医生可以开个人门诊，君只见全科医生一个人坐诊门诊人流大，票子多，不见即使是最牛的全科大夫，也得让病人老老实实去医院拍CT、做血检做常规的检验流程，末了拿着化验报告再来他这看；这一流程下来，全科医生卖的是个人服务吗？难道不是基于医院各科室流程体系下工作的“工人”罢了。</p>
<p>程序员无法独立出售个人价值？君不见诸如猪八戒、程序员客栈此类外包网站是如何兴起的？个人综合能力强的，此类人有承担软件开发全流程的能力，一个人挑大梁完成”立项-项需-设计-开发-测试-交付”；能力有偏科较弱的，提供“项需-设计-开发-测试-交付”的能力也足以；能力再弱点提供“设计-开发-测试”总可以吧；再不济“开发xx模块”对大多数程序员来说也是很容易达到的。</p>
<p>能否独立出售个人价值，取决于个人提供的价值有多全面，与行业、年龄无关。</p>
<p>医生再强，也无法做到治病救人的全流程：</p>
<ol>
<li>初诊：问诊病史-专科体格检查-辅助检查（化验、B超、电子镜）-初步诊断-治疗方案-处方和治疗单</li>
<li>复诊：基于检查调整判断，修正治疗方案</li>
</ol>
<p>程序员中综合能力强者，是可以做到一个人全挑系统开发生命周期的：</p>
<p>立项-项需-设计-开发-测试-交付</p>
<h1 id="医生更新知识慢程序员知识更新快"><a href="#医生更新知识慢，程序员知识更新快" class="headerlink" title="医生更新知识慢，程序员知识更新快"></a>医生更新知识慢，程序员知识更新快<a href="#医生更新知识慢程序员知识更新快" class="header-anchor">#</a></h1><p>这里有一层潜台词是：年龄越大，越接受不了知识的频繁更新，越适应不了新知识新技术的摄取</p>
<p>社会确实存在“上了一定年纪，学不动了，自然被行业抛弃淘汰”的事实。</p>
<p>网上诸多社区也能看到很多40+找工作力不从心的程序员同行。</p>
<p>细心观察这一类人的特点：40+年龄，喜欢谈管理，不喜谈coding和架构顶层设计，接受不了技术换代，不愿意投入时间补充新技术，没有精力和心劲追赶新知识新潮流，换言之，这一类人身体老（out）了，思想也老（out）了，身心皆老自然被行业淘汰了。</p>
<p>如果观察公司身边其他人呢，积极一些现象是：有这么一类年长者，40+年龄，能熟练编写项需，搭建顶层设计，各种新技术选型信手拈来，最潮流的coding技巧耍的有模又有样，末了交付验收bug少，还能跟产品谈需求变更，教导年轻测试人员编写安全测试用例和系统测试用例。这种人身上散发着朝气，充满了光芒，推动着团队前进，身体元气满满，心灵积极向上，所带团队凝聚力强，扔在就业市场上，这一类人行业竞争力自然强。</p>
<p>是因为年长导致就业困难吗？不是。</p>
<p>究其本质，是思想衰老不愿意投入精力学习，编码能力已经退化至菜鸟新手级别，此时这类人已经算不上程序员了，无法适应行业要求，就业自然困难；这是诸位选择的结果，温水煮青蛙式的慢性淘汰，消极应对行业需求变更，求仁得仁罢了。</p>
<p>以上是我对这个问题的一点看法。希望能鼓励到犹豫不决的人，坚定一个行业走下去的心。</p>
<link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>杂谈</category>
        <category>日记</category>
      </categories>
      <tags>
        <tag>程序人生，杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>AndroidHandler百问百答</title>
    <url>/blog//2020/08/handler%20TOP%20100%20Questions/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="android百问百答-那些年被问过的handler原理"><a href="#Android百问百答-《那些年被问过的Handler原理》" class="headerlink" title="Android百问百答-《那些年被问过的Handler原理》"></a>Android百问百答-《那些年被问过的Handler原理》<a href="#android百问百答-那些年被问过的handler原理" class="header-anchor">#</a></h1><p>文章迁移自<a href="https://blog.csdn.net/chivalrousman/article/details/108014580">我的csdn博客</a></p>
<p>关于Handler，安卓面试最热门的知识点之一。本篇文章将围绕3点展开：</p>
<p>可以提问哪些Questions？</p>
<p>面试官会怎样follow up？</p>
<p>以及怎样寻找答案。</p>
<h2 id="handler常见提问"><a href="#Handler常见提问" class="headerlink" title="Handler常见提问"></a>Handler常见提问<a href="#handler常见提问" class="header-anchor">#</a></h2><ol>
<li>哪些场景使用到了Handler？用Handler做什么业务？</li>
<li>用Handler遇到什么问题？怎么解决这些问题的？</li>
<li>说一说Handler原理？</li>
<li>能自己实现一个Handler吗？</li>
<li>说一说Handler延时原理？</li>
<li>Handler延时有哪些缺陷？造成这些缺陷的原因？</li>
<li>你知道Handler#handleMessage原理吗？</li>
<li>Handler的post与sendMessage有哪些区别？</li>
<li>子线程能使用Handler吗？</li>
<li>子线程能创建Handler吗？</li>
<li>了解过HandlerThread吗？</li>
<li>了解过IdleHandler吗？</li>
</ol>
<h2 id="handler常见follow-up"><a href="#Handler常见Follow-Up" class="headerlink" title="Handler常见Follow Up"></a>Handler常见Follow Up<a href="#handler常见follow-up" class="header-anchor">#</a></h2><ol>
<li>你刚才提到了Message，消息屏障听过吗？有几种Message？</li>
<li>Message有什么用？存储了哪些信息？以什么数据结构存储？</li>
<li>APP内最多能有几个Handler？</li>
<li>App内最多能有多少Message？</li>
<li>App内最多能有几个Looper？</li>
<li>App内最多能有几个MessageQueue？</li>
<li>Message如何知道发给哪一个MessageQueue？发给哪个Handler？</li>
<li>MessageQueue如何存储消息，以什么结构存储？</li>
<li>你提到了Looper，请问子线程如何获取Looper？</li>
<li>你提到了Looper，说一说Looper的消息队列模型？</li>
<li>主线程Looper为什么不会阻塞？为什么不会ANR？</li>
<li>子线程跟主线程如何通过Handler通信？</li>
<li>子线程创建Handler这么麻烦，有什么替代方法吗？</li>
<li>主线程Looper什么时候启动的？</li>
<li>对Handler做过哪些优化？</li>
</ol>
<h2 id="handler源码分析"><a href="#Handler源码分析" class="headerlink" title="Handler源码分析"></a>Handler源码分析<a href="#handler源码分析" class="header-anchor">#</a></h2><h3 id="handler构造函数原理"><a href="#Handler-构造函数原理" class="headerlink" title="Handler#构造函数原理"></a>Handler#构造函数原理<a href="#handler构造函数原理" class="header-anchor">#</a></h3><p>Handler有7个构造函数</p>
<pre><code>Handler()
Handler(Handler.Callback callback)
Handler(Looper looper)
Handler(Looper looper, Handler.Callback callback)
Handler(boolean async)
Handler(Callback callback, boolean async)
Handler(Looper looper, Callback callback, boolean async)
</code></pre>
<p>先从其中一个构造函数看起：<br><img src="https://img-blog.csdnimg.cn/20200814220917812.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoaXZhbHJvdXNtYW4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>提到了MessageQueue、Looper，Message,CallBack暂且记下。</p>
<p>我们根据经验及面试题，关注Handler几个关键API</p>
<ul>
<li>obtainMessage</li>
<li>post</li>
<li>sendMessage</li>
<li>postDelayed</li>
<li>sendMessageDelayed</li>
</ul>
<p>接着我们关注这些API的底层实现，一个一个分析吧！</p>
<h3 id="handlerobtainmessage-原理"><a href="#Handler-obtainMessage-原理" class="headerlink" title="Handler#obtainMessage 原理"></a>Handler#obtainMessage 原理<a href="#handlerobtainmessage-原理" class="header-anchor">#</a></h3><p>Handler#obtainMessage 调用了Message#obtain()</p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-T7alw6p4-1597413794308)(C:\Users\lenovo\AppData\Local\Temp\1597329263919.png)]</p>
<p>可以看到obtain函数从Message链表中获取message，这是一种内存复用，节省了频繁创建内存，如果Message链表为空，则创建一个Message。如果你对Message是个链表有疑问，那么请继续看下面的内容吧！</p>
<h3 id="message源码分析"><a href="#Message源码分析" class="headerlink" title="Message源码分析"></a>Message源码分析<a href="#message源码分析" class="header-anchor">#</a></h3><p>Message有如下公有属性，供程序员调用：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> what;<span class="comment">//消息标示，</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> arg1; <span class="comment">//简单int类型数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> arg2;<span class="comment">//简单int类型数据</span></span><br><span class="line"><span class="keyword">public</span> Object obj;<span class="comment">//简单Object类型数据</span></span><br><span class="line"><span class="keyword">public</span> Messenger replyTo;<span class="comment">//跨进程信使</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> sendingUid = -<span class="number">1</span>;<span class="comment">//Messenger消息标示</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure></div>
<p>Message有如下私有属性,用途如下：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*package*/</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLAG_IN_USE = <span class="number">1</span> &lt;&lt; <span class="number">0</span>;<span class="comment">//正在使用中</span></span><br><span class="line"><span class="comment">/*package*/</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLAG_ASYNCHRONOUS = <span class="number">1</span> &lt;&lt; <span class="number">1</span>;<span class="comment">//消息同步标识</span></span><br><span class="line"><span class="comment">/*package*/</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLAGS_TO_CLEAR_ON_COPY_FROM = FLAG_IN_USE;<span class="comment">//</span></span><br><span class="line"><span class="comment">/*package*/</span> <span class="keyword">int</span> flags;<span class="comment">//消息执行标识</span></span><br><span class="line"><span class="comment">/*package*/</span> <span class="keyword">long</span> when;<span class="comment">//执行时间</span></span><br><span class="line"><span class="comment">/*package*/</span> Bundle data;<span class="comment">//装载的数据</span></span><br><span class="line"><span class="comment">/*package*/</span> Handler target;<span class="comment">//目标载体</span></span><br><span class="line"><span class="comment">/*package*/</span> Runnable callback;<span class="comment">//任务线程</span></span><br><span class="line"><span class="comment">/*package*/</span> Message next;<span class="comment">//消息链表，下一个消息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object sPoolSync = <span class="keyword">new</span> Object();<span class="comment">//锁对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Message sPool;<span class="comment">//消息池</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> sPoolSize = <span class="number">0</span>;<span class="comment">//消息池大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_POOL_SIZE = <span class="number">50</span>;<span class="comment">//消息池最大消息数常量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> gCheckRecycle = <span class="keyword">true</span>;<span class="comment">//循环检查</span></span><br></pre></td></tr></table></figure></div>
<p>Message的源码，我们可以得出如下结论，Message是一种链表结构，每个Message持有以下信息：</p>
<ol>
<li>用于传递的数据，如what、arg1、arg2、obj</li>
<li>用于执行当前Message的Handler</li>
<li>用于执行当前Message的回调接口CallBack、子线程Runnable</li>
<li>当前Message的属性，如延时时间、执行标识、Bundle数据，下一个Message引用。这种结构构成了链表。</li>
</ol>
<h3 id="handlerpost的原理"><a href="#Handler-post的原理" class="headerlink" title="Handler#post的原理"></a>Handler#post的原理<a href="#handlerpost的原理" class="header-anchor">#</a></h3><p>post函数入口接收一个子线程Runnable对象</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span>  sendMessageDelayed(getPostMessage(r), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>getPostMessage()做了如下工作：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Message <span class="title">getPostMessage</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">    Message m = Message.obtain();</span><br><span class="line">    m.callback = r;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>sendMessageDelayed做了如下工作：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageDelayed</span><span class="params">(Message msg, <span class="keyword">long</span> delayMillis)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        delayMillis = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>sendMessageAtTime做了如下工作：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">    MessageQueue queue = mQueue;</span><br><span class="line">    <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        RuntimeException e = <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="keyword">this</span> + <span class="string">&quot; sendMessageAtTime() called with no mQueue&quot;</span>);</span><br><span class="line">        Log.w(<span class="string">&quot;Looper&quot;</span>, e.getMessage(), e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>最终走下了MessageQueue#enqueueMessage</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">    msg.target = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">        msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>这一步总结如下</p>
<ol>
<li>getPostMessage将Message与Handler绑定</li>
<li>通过SystemClock.uptimeMillis() + delayMillis计算延时时间，delayMillis默认为0</li>
<li>将Message与计算得出的时间值，传递给MessageQueue#enqueueMessage，交由MessageQueue处理Message。</li>
</ol>
<h3 id="handlersendmessage原理"><a href="#Handler-sendMessage原理" class="headerlink" title="Handler#sendMessage原理"></a>Handler#sendMessage原理<a href="#handlersendmessage原理" class="header-anchor">#</a></h3><p>入口接收Message对象</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessage</span><span class="params">(Message msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sendMessageDelayed(msg, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>后续执行过程与post相同，最终都将Message交由MessageQueue#enqueueMessage处理。</p>
<h3 id="handlerpostdelayed原理"><a href="#Handler-postDelayed原理" class="headerlink" title="Handler#postDelayed原理"></a>Handler#postDelayed原理<a href="#handlerpostdelayed原理" class="header-anchor">#</a></h3><p>与post相比，postDelayed函数入口除了接收Runnable子线程对象，还接收一个时间戳，用于延时时间的计算。其他过程与post相同。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">postDelayed</span><span class="params">(Runnable r, <span class="keyword">long</span> delayMillis)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sendMessageDelayed(getPostMessage(r), delayMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="handlersendmessagedelayed原理"><a href="#Handler-sendMessageDelayed原理" class="headerlink" title="Handler#sendMessageDelayed原理"></a>Handler#sendMessageDelayed原理<a href="#handlersendmessagedelayed原理" class="header-anchor">#</a></h3><p>与sendMessage类似，多了一个时间戳，用于计算延时时间。其他过程与sendMessage、相同。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageDelayed</span><span class="params">(Message msg, <span class="keyword">long</span> delayMillis)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        delayMillis = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>看完源码，我们得出几个结论：</p>
<ol>
<li>无论是Handler#post或者是Handler#sendMessage，Messag都会交由MessageQueue#enqueueMessage执行</li>
<li>MessageQueue#enqueueMessage接收两个参数Message和long型的时间戳</li>
<li>时间戳计算方式是SystemClock.uptimeMillis() + delayMillis</li>
<li>post与sendMessage的区别是入参参数不一样，post接收Runnable子线程，将子线程绑定到Message上；sendMessage持有的是主线程</li>
</ol>
<p>那么我们心中很自然会产生疑问，MessageQueue#enqueueMessage是如何执行的？</p>
<h2 id="messagequeue源码分析"><a href="#MessageQueue源码分析" class="headerlink" title="MessageQueue源码分析"></a>MessageQueue源码分析<a href="#messagequeue源码分析" class="header-anchor">#</a></h2><p>源码分析的思路是构造函数和enqueueMessage</p>
<h3 id="messagequeue构造函数原理"><a href="#MessageQueue-构造函数原理" class="headerlink" title="MessageQueue#构造函数原理"></a>MessageQueue#构造函数原理<a href="#messagequeue构造函数原理" class="header-anchor">#</a></h3><p>首先来看看构造函数</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line">MessageQueue(<span class="keyword">boolean</span> quitAllowed) &#123;</span><br><span class="line">    mQuitAllowed = quitAllowed;</span><br><span class="line">    mPtr = nativeInit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>构造函数之上定义了很多native方法</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">nativeInit</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeDestroy</span><span class="params">(<span class="keyword">long</span> ptr)</span></span>;<span class="comment">// 阻塞</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeWake</span><span class="params">(<span class="keyword">long</span> ptr)</span></span>; <span class="comment">// 唤醒</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">nativeIsPolling</span><span class="params">(<span class="keyword">long</span> ptr)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeSetFileDescriptorEvents</span><span class="params">(<span class="keyword">long</span> ptr, <span class="keyword">int</span> fd, <span class="keyword">int</span> events)</span></span>;</span><br></pre></td></tr></table></figure></div>
<p>native之上定义了几类数据结构，Message、ArrayList、SparseArray、数组</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line">Message mMessages; <span class="comment">// 头结点</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;IdleHandler&gt; mIdleHandlers = <span class="keyword">new</span> ArrayList&lt;IdleHandler&gt;();</span><br><span class="line">   <span class="keyword">private</span> SparseArray&lt;FileDescriptorRecord&gt; mFileDescriptorRecords;</span><br><span class="line">   <span class="keyword">private</span> IdleHandler[] mPendingIdleHandlers;</span><br></pre></td></tr></table></figure></div>
<p>接着我们来看看enqueueMessage是如何处理Message的吧</p>
<h3 id="messagequeueenqueuemessage原理"><a href="#MessageQueue-enqueueMessage原理" class="headerlink" title="MessageQueue#enqueueMessage原理"></a>MessageQueue#enqueueMessage原理<a href="#messagequeueenqueuemessage原理" class="header-anchor">#</a></h3><p><img src="https://img-blog.csdnimg.cn/20200814221037199.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoaXZhbHJvdXNtYW4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li>图中 1处会判断如果 Message 中的 target 没有被设置，则直接抛出异常；</li>
<li>图中2和 3 处会按照 Message 的时间 when 来有序得插入 MessageQueue 中，可以看出 MessageQueue 实际上是一个链表维护的有序队列，只不过是按照 Message 的执行时间来排序。</li>
</ul>
<p>看到这里，思路似乎终止了，我们跟随Handler、MessQueue的脚步，只看到了Message被插入到MessageQueue的私有队列中。那我们产生的Message什么时候会背消费呢？</p>
<p>视角再次回到一开始的地方——Handler的构造函数原理，在那一节我们提到了Handler构造函数初始化Looper.myLooper()，mLooper.mQueue，接下来我们看看Looper吧！</p>
<h2 id="looper源码分析"><a href="#Looper源码分析" class="headerlink" title="Looper源码分析"></a>Looper源码分析<a href="#looper源码分析" class="header-anchor">#</a></h2><p>查看源码可知，Looper是final类型的，禁止被外部继承修改。</p>
<h3 id="looper子线程用例"><a href="#Looper-子线程用例" class="headerlink" title="Looper#子线程用例"></a>Looper#子线程用例<a href="#looper子线程用例" class="header-anchor">#</a></h3><p>首先在Looper类的注释上，我们看到了如下信息，提示我们在子线程中用个Looper.prepare()+Looper.looper()的方式使用Handler<br><img src="https://img-blog.csdnimg.cn/2020081422110294.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoaXZhbHJvdXNtYW4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>为什么需要用这种方式开启Looper呢？</p>
<p>答案是在任何线程要开启Loop，都要用Looper.prepare()+Looper.looper()的方式。以APP主进程为例，APP进程启动入口的main方法，也是通过这种方式开启loop的。与子线程细微不同的是，主线程开启looper用的是prepareMainLooper。</p>
<p><strong>ActivityThread #main方法</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200814221126574.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoaXZhbHJvdXNtYW4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>带着以下疑问，我们去追看源码：Looper构造函数做了什么？prepare做了什么？loop做了什么？</p>
<h3 id="looper构造函数原理"><a href="#Looper-构造函数原理" class="headerlink" title="Looper#构造函数原理"></a>Looper#构造函数原理<a href="#looper构造函数原理" class="header-anchor">#</a></h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);</span><br><span class="line">    mThread = Thread.currentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>Looper构造函数做了两件事情，初始化消息队列MessageQueue对象，记录当前线程信息。</p>
<h3 id="loopermylooper原理"><a href="#Looper-myLooper-原理" class="headerlink" title="Looper#myLooper()原理"></a>Looper#myLooper()原理<a href="#loopermylooper原理" class="header-anchor">#</a></h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the Looper object associated with the current thread.  Returns</span></span><br><span class="line"><span class="comment"> * null if the calling thread is not associated with a Looper.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> <span class="function">Looper <span class="title">myLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sThreadLocal.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>可以看到myLooper是从threadLocal中取出Looper对象。在Looper类中定义了如下变量sThreadLocal、mQueue、sMainLooper、mThread</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sThreadLocal.get() will return null unless you&#x27;ve called prepare().</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;Looper&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Looper sMainLooper;  <span class="comment">// guarded by Looper.class</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> MessageQueue mQueue;</span><br><span class="line"><span class="keyword">final</span> Thread mThread;</span><br></pre></td></tr></table></figure></div>
<h3 id="looperprepare原理"><a href="#Looper-prepare原理" class="headerlink" title="Looper#prepare原理"></a>Looper#prepare原理<a href="#looperprepare原理" class="header-anchor">#</a></h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Only one Looper may be created per thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>prepare就是 new 出一个 Looper。核心之处在于将 new 出的 Looper 设置到了线程本地变量 sThreadLocal 中。也就是说创建的 Looper 与当前线程发生了绑定。</p>
<p>Looper#prepareMainLooper原理</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepareMainLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    prepare(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (Looper.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sMainLooper != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;The main Looper has already been prepared.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sMainLooper = myLooper();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>prepareMainLooper只有在APP进程启动的时候有用，并不推荐开发者调用这个函数。</p>
<h3 id="looperloop原理"><a href="#Looper-loop原理" class="headerlink" title="Looper#loop原理"></a>Looper#loop原理<a href="#looperloop原理" class="header-anchor">#</a></h3><p><img src="https://img-blog.csdnimg.cn/20200814221152760.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoaXZhbHJvdXNtYW4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>图1 取出Looper对象</p>
<p>图2 校验当前线程是否持有Looper，是否启动而来Looper.prepare</p>
<p>图3 从Looper中取出对应的MessageQueue，主线程Looper就取出主线程的MessageQueue，子线程就取出子线程MessageQueue</p>
<p>图4 从MessageQueue中取出Message</p>
<p>图5 Message#target属性，即handler，调用Message绑定好的handler#dispatchMessage，处理消息。</p>
<p>也就是说，Message最终交由与Message绑定的Handler处理。Looper只是负责无限循环+从MessageQueue中读取。</p>
<h3 id="handlerdispatchmessage"><a href="#Handler-dispatchMessage" class="headerlink" title="Handler#dispatchMessage"></a>Handler#dispatchMessage<a href="#handlerdispatchmessage" class="header-anchor">#</a></h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">  * Handle system messages here.</span><br><span class="line">  *&#x2F;</span><br><span class="line"> public void dispatchMessage(Message msg) &#123;</span><br><span class="line">     if (msg.callback !&#x3D; null) &#123;</span><br><span class="line">         handleCallback(msg);&#x2F;&#x2F; 1</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">         if (mCallback !&#x3D; null) &#123;</span><br><span class="line">             if (mCallback.handleMessage(msg)) &#123;&#x2F;&#x2F; 2</span><br><span class="line">                 return;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         handleMessage(msg);&#x2F;&#x2F; 3</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></div>
<p>可以看到有3处可以处理Message</p>
<p>图 1触发了Message#Runnable的run方法，要知道callback就是个Runnable子线程</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleCallback</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">    message.callback.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>图2 触发了 Handler#Callback接口，Callback是Handler构造函数初始化的时候传递进来的。参考Handler#构造函数原理</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callback</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg A &#123;<span class="doctag">@link</span> android.os.Message Message&#125; object</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> True if no further handling is desired</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>图3 触发了Handler的handleMessage方法，这是个空实现，一般由开发者复写实现。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Subclasses must implement this to receive messages.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在Looper这一节，我们暂停脚步总结一下：</p>
<ol>
<li><p>主线程和子线程都可以使用Handler，Handler使用方式都是要Looper.prepare+Lopper.loop,</p>
</li>
<li><p>子线程Handler用法</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LooperThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> Handler mHandler;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   Looper.prepare();</span><br><span class="line"></span><br><span class="line">   mHandler = <span class="keyword">new</span> Handler() &#123;</span><br><span class="line">	   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">		   <span class="comment">// process incoming messages here</span></span><br><span class="line">	   &#125;</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   Looper.loop();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">new</span> LooperThread().start();</span><br></pre></td></tr></table></figure></div>


</li>
</ol>
<p>回答这些面试题吧</p>
<h2 id="面试题解析"><a href="#面试题解析" class="headerlink" title="面试题解析"></a>面试题解析<a href="#面试题解析" class="header-anchor">#</a></h2><h3 id="哪些场景使用到了handler用handler做什么业务"><a href="#哪些场景使用到了Handler？用Handler做什么业务？" class="headerlink" title="哪些场景使用到了Handler？用Handler做什么业务？"></a>哪些场景使用到了Handler？用Handler做什么业务？<a href="#哪些场景使用到了handler用handler做什么业务" class="header-anchor">#</a></h3><h4 id="最简单的消息发送"><a href="#最简单的消息发送" class="headerlink" title="最简单的消息发送"></a>最简单的消息发送<a href="#最简单的消息发送" class="header-anchor">#</a></h4><p>主线程使用Handler， 主线程里或子线程里发送消息，或延迟发送消息的方式更新UI如，启动应用时Splash页面的延迟2，3秒后，跳转到主页面</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WHAT_UPDATE_ICON = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Handler handler = <span class="keyword">new</span> Handler() &#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">               <span class="keyword">case</span> WHAT_UPDATE_ICON:</span><br><span class="line">                   Log.e(Tag, <span class="string">&quot;receive message:&quot;</span> + msg.obj);</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"> &#125;;</span><br><span class="line">   </span><br><span class="line">   Message msg = handler.obtainMessage(WHAT_UPDATE_ICON);</span><br><span class="line">   msg.obj = <span class="string">&quot;update the imageview&quot;</span>;</span><br><span class="line">   handler.sendMessage(msg);</span><br></pre></td></tr></table></figure></div>
<p>使用消息的时候，尽量使用 obtainMessage 的方式来获取Message，避免多次创建Message对象，消耗内存，效率低下。</p>
<p>记住：消息不一定是更新UI的消息，可以再handlerMessage中做很多事情！</p>
<h4 id="结合handlerthread处理耗时任务"><a href="#结合HandlerThread处理耗时任务" class="headerlink" title="结合HandlerThread处理耗时任务"></a>结合HandlerThread处理耗时任务<a href="#结合handlerthread处理耗时任务" class="header-anchor">#</a></h4><p>结合HandlerThread，串行的处理单个耗时任务，如单任务下载</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DownloadOneByOne</span> <span class="keyword">extends</span> <span class="title">HandlerThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DownloadOneByOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(DownloadOneByOne.class.getSimpleName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLooperPrepared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onLooperPrepared();</span><br><span class="line">        <span class="comment">// 初始化下载组件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> HandlerThread mHandlerThread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Handler downloadHandler = <span class="keyword">new</span> Handler()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">        String url = (String) msg.obj;</span><br><span class="line">        <span class="comment">// 使用下载组件开始下载</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化Handler</span></span><br><span class="line">    mHandlerThread = <span class="keyword">new</span> DownloadOneByOne();</span><br><span class="line">    mHandlerThread.start();</span><br><span class="line">    </span><br><span class="line">    downloadHandler = <span class="keyword">new</span> Handler(mHandlerThread.getLooper());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendDownloadTask</span><span class="params">(String downloadUrl)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 发送下载任务</span></span><br><span class="line">    Message msg = downloadHandler.obtainMessage(WHAT_DOWNLOAD_TASK);</span><br><span class="line">    msg.obj = downloadUrl;</span><br><span class="line">    downloadHandler.sendMessage(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="倒计时view的简易实现"><a href="#倒计时View的简易实现" class="headerlink" title="倒计时View的简易实现"></a>倒计时View的简易实现<a href="#倒计时view的简易实现" class="header-anchor">#</a></h4><p>通过Handler我们还可以快速简易，并且不占用太多性能的实现一个简易的倒计时View。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownView</span> <span class="keyword">extends</span> <span class="title">AppCompatTextView</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 总时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> seconds;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前分钟</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> minutes;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前秒数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> second = <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SECONDS_PER_MINUTE = <span class="number">60</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MILLS_PER_SECOND = <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MILLS_PER_MINUTE = SECONDS_PER_MINUTE * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WHAT_DONE = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WHAT_TICK = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> marginEnd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringBuilder content = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CountDownView</span><span class="params">(Context context, <span class="meta">@Nullable</span> AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">        DeviceProfile deviceProfile = Launcher.getLauncher(getContext()).getDeviceProfile();</span><br><span class="line">        <span class="keyword">int</span> size = (<span class="keyword">int</span>) (MeasureSpec.getSize(widthMeasureSpec) / deviceProfile.inv.numColumns);</span><br><span class="line">        marginEnd = marginEnd == <span class="number">0</span> ? (size - deviceProfile.iconSizePx) / <span class="number">2</span> : marginEnd;</span><br><span class="line"></span><br><span class="line">        setMarginEnd(marginEnd);</span><br><span class="line">        <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setMarginEnd</span><span class="params">(<span class="keyword">int</span> marginEnd)</span> </span>&#123;</span><br><span class="line">        LinearLayout.LayoutParams layoutParams = (LinearLayout.LayoutParams) getLayoutParams();</span><br><span class="line">        layoutParams.setMarginEnd(marginEnd);</span><br><span class="line">        layoutParams.resolveLayoutDirection(layoutParams.getLayoutDirection());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDetachedFromWindow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDetachedFromWindow();</span><br><span class="line">        <span class="keyword">if</span> (handler.hasMessages(WHAT_TICK)) &#123;</span><br><span class="line">            handler.removeMessages(WHAT_TICK);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Handler handler = <span class="keyword">new</span> Handler() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                <span class="keyword">case</span> WHAT_DONE:</span><br><span class="line">                    setVisibility(View.GONE);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    setText(content.toString());</span><br><span class="line">                    handler.post(runnable);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***</span></span><br><span class="line"><span class="comment">     * 设置倒计时</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> millis</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCountDownMills</span><span class="params">(<span class="keyword">long</span> millis)</span> </span>&#123;</span><br><span class="line">        seconds = (<span class="keyword">long</span>) Math.floor(millis / MILLS_PER_SECOND);</span><br><span class="line">        minutes = (<span class="keyword">long</span>) Math.floor(millis / MILLS_PER_MINUTE) - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// start after one second</span></span><br><span class="line">        handler.postDelayed(runnable, MILLS_PER_SECOND);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (seconds &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                handler.sendEmptyMessage(WHAT_DONE);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            seconds--;</span><br><span class="line">            <span class="keyword">if</span> (second &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                second = SECONDS_PER_MINUTE;</span><br><span class="line">                minutes = (<span class="keyword">long</span>) Math.floor(seconds / SECONDS_PER_MINUTE);</span><br><span class="line">            &#125;</span><br><span class="line">            second--;</span><br><span class="line">            content.delete(<span class="number">0</span>, content.length());</span><br><span class="line"></span><br><span class="line">            appendZeroWhenLower10(minutes);</span><br><span class="line">            content.append(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">            appendZeroWhenLower10(second);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (handler.hasMessages(WHAT_TICK)) &#123;</span><br><span class="line">                handler.removeMessages(WHAT_TICK);</span><br><span class="line">            &#125;</span><br><span class="line">            handler.sendEmptyMessageDelayed(WHAT_TICK, MILLS_PER_SECOND);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> StringBuilder <span class="title">appendZeroWhenLower10</span><span class="params">(<span class="keyword">long</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value &lt; <span class="number">10</span>) &#123;</span><br><span class="line">            content.append(<span class="string">&quot;0&quot;</span>).append(value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            content.append(value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="结合intentservice的使用"><a href="#结合IntentService的使用" class="headerlink" title="结合IntentService的使用"></a>结合IntentService的使用<a href="#结合intentservice的使用" class="header-anchor">#</a></h4><p>使用IntentService处理耗时的任务相对比较简单，我们来个有难度的，结合AlarmManager的调度，息屏唤醒IntentService定时处理任务的案例来讲</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ACTION_WAKE_UP = <span class="string">&quot;com.doze.cpu.wakeup&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerAlarm</span><span class="params">(Context context, <span class="keyword">int</span> wakeType)</span> </span>&#123;</span><br><span class="line">    type = wakeType;</span><br><span class="line">    <span class="keyword">if</span> (alarmManager == <span class="keyword">null</span>)</span><br><span class="line">        alarmManager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (operation != <span class="keyword">null</span>) alarmManager.cancel(operation);</span><br><span class="line"></span><br><span class="line">    schedule(context);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">schedule</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">    intent.setAction(ACTION_WAKE_UP);</span><br><span class="line">    operation = PendingIntent.getBroadcast(context, <span class="number">0</span>, intent, PendingIntent.FLAG_UPDATE_CURRENT);</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            AlarmUtils.setRTCWakeup(alarmManager, AlarmUtils.DEFAULT_TRIGGER_AT_MILLIS, operation);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            AlarmUtils.setElapsedWakeup(alarmManager, AlarmUtils.DEFAULT_TRIGGER_AT_MILLIS, operation);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>定时5分钟发送一个Action为com.doze.cpu.wakeup的广播，我们的广播需要继承 WakefulBroadcastReceiver， 在onReceive里，调用startWakefulService方法，会创建一个1分钟的WakeLock，唤醒cpu处理我们的任务，我们的任务IntentService处理最好不过了，处理完就销毁，不会有多余的占用</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WakeCPUReceiver</span> <span class="keyword">extends</span> <span class="title">WakefulBroadcastReceiver</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Intent wakefulIntent = <span class="keyword">new</span> Intent(context, WorkService.class);</span><br><span class="line">        startWakefulService(context, wakefulIntent);</span><br><span class="line">        schedule(context);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>
<p>startWakefulService的源码</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ComponentName <span class="title">startWakefulService</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mActiveWakeLocks) &#123;</span><br><span class="line">            <span class="keyword">int</span> id = mNextId;</span><br><span class="line">            mNextId++;</span><br><span class="line">            <span class="keyword">if</span> (mNextId &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                mNextId = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            intent.putExtra(EXTRA_WAKE_LOCK_ID, id);</span><br><span class="line">            ComponentName comp = context.startService(intent);</span><br><span class="line">            <span class="keyword">if</span> (comp == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            PowerManager pm = (PowerManager)context.getSystemService(Context.POWER_SERVICE);</span><br><span class="line">            PowerManager.WakeLock wl = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,</span><br><span class="line">                    <span class="string">&quot;wake:&quot;</span> + comp.flattenToShortString());</span><br><span class="line">            wl.setReferenceCounted(<span class="keyword">false</span>);</span><br><span class="line">            wl.acquire(<span class="number">60</span>*<span class="number">1000</span>);</span><br><span class="line">            mActiveWakeLocks.put(id, wl);</span><br><span class="line">            <span class="keyword">return</span> comp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>
<p>在IntentService里，我们在onHandleIntent处理我们的任务后，再调用WakefulBroadcastReceiver的静态方法completeWakefulIntent，释放WakeLock，减少电量的消耗</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkService</span> <span class="keyword">extends</span> <span class="title">IntentService</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onHandleIntent</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        Log.e(WakeCPUReceiver.TAG, <span class="string">&quot;WorkService is working&quot;</span>);</span><br><span class="line">        <span class="comment">// TODO 处理我们的任务</span></span><br><span class="line">        WakeCPUReceiver.completeWakefulIntent(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>completeWakefulIntent源码</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">completeWakefulIntent</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> id = intent.getIntExtra(EXTRA_WAKE_LOCK_ID, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (id == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (mActiveWakeLocks) &#123;</span><br><span class="line">            PowerManager.WakeLock wl = mActiveWakeLocks.get(id);</span><br><span class="line">            <span class="keyword">if</span> (wl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                wl.release();</span><br><span class="line">                mActiveWakeLocks.remove(id);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// We return true whether or not we actually found the wake lock</span></span><br><span class="line">            <span class="comment">// the return code is defined to indicate whether the Intent contained</span></span><br><span class="line">            <span class="comment">// an identifier for a wake lock that it was supposed to match.</span></span><br><span class="line">            <span class="comment">// We just log a warning here if there is no wake lock found, which could</span></span><br><span class="line">            <span class="comment">// happen for example if this function is called twice on the same</span></span><br><span class="line">            <span class="comment">// intent or the process is killed and restarted before processing the intent.</span></span><br><span class="line">            Log.w(<span class="string">&quot;WakefulBroadcastReceiver&quot;</span>, <span class="string">&quot;No active wake lock id #&quot;</span> + id);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="idlehandler-用于ui性能优化"><a href="#IdleHandler-用于UI性能优化" class="headerlink" title="IdleHandler 用于UI性能优化"></a>IdleHandler 用于UI性能优化<a href="#idlehandler-用于ui性能优化" class="header-anchor">#</a></h4><p>先计算任务放在Activity绘制结束完成之后，节省了90Ms计算时间。参考面试题你了解过IdleHandler 吗？<br><img src="https://img-blog.csdnimg.cn/20200814221240437.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoaXZhbHJvdXNtYW4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="handlerthread用于单线程消息通知器"><a href="#HandlerThread用于单线程消息通知器" class="headerlink" title="HandlerThread用于单线程消息通知器"></a><strong>HandlerThread</strong>用于单线程消息通知器<a href="#handlerthread用于单线程消息通知器" class="header-anchor">#</a></h4><p>在用户操作某些界面元素的时候，如收藏、点赞、转发，有一个小的问题，就是如果有一个操作生成10个快速连续的增删改查操作，那么我们的UI就会收到10次回调，而这种场景下我们其实只需要最后一次回调就够了，中间操作其实不用刷新UI的。如何合并这些频繁操作，只在最后一次操作结束时候响应UI更新呢。</p>
<p>答：HandlerThread+反射MessageQueue+idelHandler<br><img src="https://img-blog.csdnimg.cn/20200814221259759.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoaXZhbHJvdXNtYW4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="用handler遇到什么问题怎么解决这些问题的"><a href="#用Handler遇到什么问题？怎么解决这些问题的？" class="headerlink" title="用Handler遇到什么问题？怎么解决这些问题的？"></a>用Handler遇到什么问题？怎么解决这些问题的？<a href="#用handler遇到什么问题怎么解决这些问题的" class="header-anchor">#</a></h3><h4 id="问题handler延时不准确经常到了时间不响应业务"><a href="#问题：Handler延时不准确，经常到了时间不响应业务" class="headerlink" title="问题：Handler延时不准确，经常到了时间不响应业务"></a>问题：Handler延时不准确，经常到了时间不响应业务<a href="#问题handler延时不准确经常到了时间不响应业务" class="header-anchor">#</a></h4><p>解决：<strong>SystemClock.uptimeMillis()**表示系统</strong>开机到当前的时间总数**，单位是毫秒，但是，当系统进入深度睡眠（CPU休眠、屏幕休眠、设备等待外部输入）时间就会停止，但是不会受到时钟缩放、空闲或者其他节能机制的影响。</p>
<p>使用其他延时方式</p>
<ol>
<li>用concurrent包的TimeUnit类延时sleep()方法延时</li>
<li>Timer+TimeTask</li>
<li>AlarmManager  </li>
<li>ScheduledExecutorService</li>
</ol>
<h4 id="问题子线程创建handler失败"><a href="#问题：子线程创建Handler失败" class="headerlink" title="问题：子线程创建Handler失败"></a>问题：子线程创建Handler失败<a href="#问题子线程创建handler失败" class="header-anchor">#</a></h4><p>解决：参考Looper#子线程用例部分</p>
<h4 id="问题非静态类导致的内存泄漏"><a href="#问题：非静态类导致的内存泄漏" class="headerlink" title="问题：非静态类导致的内存泄漏"></a>问题：非静态类导致的内存泄漏<a href="#问题非静态类导致的内存泄漏" class="header-anchor">#</a></h4><p>解决：static+WeakReference</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span></span>&#123;</span><br><span class="line">     WeakReference&lt;MainActivity&gt; mActivity;</span><br><span class="line">     MyHandler(MainActivity activity)&#123;</span><br><span class="line">         mActivity = <span class="keyword">new</span> WeakReference&lt;MainActivity&gt;(activity);</span><br><span class="line">     &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> cuttent = msg.what;</span><br><span class="line"></span><br><span class="line">        MainActivity activity = mActivity.get();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(activity.currentlayout!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            Animation set2 = <span class="keyword">new</span> TranslateAnimation(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,-<span class="number">100</span>);</span><br><span class="line">            set2.setDuration(<span class="number">500</span>);</span><br><span class="line">            activity.currentlayout.setAnimation(set2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        activity.linearLayout.removeAllViews();</span><br><span class="line"></span><br><span class="line">        activity.currentlayout = activity.initView(cuttent);</span><br><span class="line"></span><br><span class="line">        Animation set1 = <span class="keyword">new</span> TranslateAnimation(<span class="number">0</span>,<span class="number">0</span>,<span class="number">100</span>,<span class="number">0</span>);</span><br><span class="line">        set1.setDuration(<span class="number">500</span>);</span><br><span class="line">        activity.currentlayout.setAnimation(set1);</span><br><span class="line"></span><br><span class="line">        activity.linearLayout.addView(activity.currentlayout);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="说一说handler原理"><a href="#说一说Handler原理？" class="headerlink" title="说一说Handler原理？"></a>说一说Handler原理？<a href="#说一说handler原理" class="header-anchor">#</a></h3><p>原理的定义是：某个类的提供哪些功能，这些功能是如何实现的？</p>
<p>我认为回答这个问题包含三步：Handler是什么，关键API是什么，关键对象是什么？</p>
<h4 id="第一步回答handler是什么有哪些场景"><a href="#第一步：回答Handler是什么，有哪些场景。" class="headerlink" title="第一步：回答Handler是什么，有哪些场景。"></a>第一步：回答Handler是什么，有哪些场景。<a href="#第一步回答handler是什么有哪些场景" class="header-anchor">#</a></h4><p>答：Handler是Android消息通信组件，用于线程间通信，收发消息，更新UI等参考面试题目1。</p>
<h4 id="第二步handler的关键api是什么用途是什么如何实现的"><a href="#第二步：Handler的关键API是什么，用途是什么，如何实现的。" class="headerlink" title="第二步：Handler的关键API是什么，用途是什么，如何实现的。"></a>第二步：Handler的关键API是什么，用途是什么，如何实现的。<a href="#第二步handler的关键api是什么用途是什么如何实现的" class="header-anchor">#</a></h4><p>答：关键API有：</p>
<p>构造函数：用于绑定MessageQueue、Looper、Message、Runnable、CallBack等</p>
<p>obtainMessage：用于复用Message</p>
<p>post、sendMessage：不同的执行Message方式，前者是接收Runnable参数，后者是当前线程</p>
<p>sendMessageAtTime：消息延时的实现入口，调用MessageQueue#enqueueMessage</p>
<h4 id="第三步handler的关键对象是什么提供哪些功能这些功能如何实现的"><a href="#第三步：Handler的关键对象是什么，提供哪些功能，这些功能如何实现的。" class="headerlink" title="第三步：Handler的关键对象是什么，提供哪些功能，这些功能如何实现的。"></a>第三步：Handler的关键对象是什么，提供哪些功能，这些功能如何实现的。<a href="#第三步handler的关键对象是什么提供哪些功能这些功能如何实现的" class="header-anchor">#</a></h4><p>答：关键对象有：</p>
<p>Message</p>
<p>Message是一种链表结构的子节点，作为载体可以存储的信息有：公开信息arg1、arg2、handler、Message，私有信息when、Runnable。Message有2种Flag，使用中、同步中，三种消息类型，如普通消息、异步消息、消息屏障。</p>
<p>MessageQueue</p>
<p>MessageQueue提供一种链表数据结构，包括头结点信息，插入节点的方式是按照 Message 的时间 when 顺序，时间小的先插入 。</p>
<p>Looper</p>
<p>开启无限循环，不断从 MessageQueue 中取出 Message，然后处理 Message 中指定的任务。典型的Looper是主线程Looper，在 ActivityThread 的 main 方法中，除了调用 Looper.prepareMainLooper 初始化 Looper 对象之外，还调用了 Looper.loop 方法开启无限循环，Looper 的主要功能就是在这个循环中完成的。</p>
<p>Looper提供了一些native方法用于唤醒阻塞状态如nativePollOnce</p>
<p>Looper不断loop的结果，就是调用msg.target.handleMessage,即执行开发者定义好的Handler#handleMessage方法体中的业务。</p>
<h3 id="能自己实现一个handler吗"><a href="#能自己实现一个Handler吗？" class="headerlink" title="能自己实现一个Handler吗？"></a>能自己实现一个Handler吗？<a href="#能自己实现一个handler吗" class="header-anchor">#</a></h3><p>根据Handler的类图，我们可以抽象出Handler消息组件的基本架构。<br><img src="https://img-blog.csdnimg.cn/20200814221418179.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoaXZhbHJvdXNtYW4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="简版handler"><a href="#简版Handler" class="headerlink" title="简版Handler"></a>简版Handler<a href="#简版handler" class="header-anchor">#</a></h4><p>概要设计：</p>
<p>首先我们仿照Android的Handler定义了：阻塞队列、处理消息的回调、分发和发送消息的方法<br>其次然后在创建Handler时，我们获取了当前线程的Looper和MessageQueue</p>
<p>最后，当我们发送消息的时候，将消息添加进之前得到的MessageQueue</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MyMessageQueue queue;<span class="comment">// 用于进行线程间通信的阻塞队列</span></span><br><span class="line">    <span class="keyword">private</span> CallBack callBack; <span class="comment">// 处理消息的回调</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyHandler</span><span class="params">(CallBack callBack)</span> </span>&#123;</span><br><span class="line">        MyLooper looper = MyLooper.myLooper();</span><br><span class="line">        <span class="keyword">if</span> (looper == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;在新开的线程中。创建MyHandler对象需要先调用MyLooper.prepare()方法。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        queue = looper.queue;</span><br><span class="line">        <span class="keyword">this</span>.callBack = callBack;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消息接收的回调</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CallBack</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(MyMessage msg)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(MyMessage msg)</span> </span>&#123;</span><br><span class="line">        msg.target = <span class="keyword">this</span>;</span><br><span class="line">        queue.enqueueMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//派发消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(MyMessage msg)</span> </span>&#123;</span><br><span class="line">        callBack.handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="简版looper"><a href="#简版Looper" class="headerlink" title="简版Looper"></a>简版Looper<a href="#简版looper" class="header-anchor">#</a></h4><ol>
<li>在Looper中，我们用一个ThreadLocal存储当前Looper的相关数据</li>
<li>定义了一个消息队列，用来管理消息</li>
<li>在prepare()时，用ThreadLocal存储Looper的数据；在myLooper时，读取ThreadLocal存储的Looper数据</li>
<li>在loop()时,用一个死循环来不断的接受和分发消息</li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLooper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;MyLooper&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> MyLooper myLooper;</span><br><span class="line">    <span class="keyword">public</span> MyMessageQueue queue;<span class="comment">//一个线程对应一个阻塞队列</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MyLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queue = <span class="keyword">new</span> MyMessageQueue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取当前线程相对应的Looper对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MyLooper <span class="title">myLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> threadLocal.get();<span class="comment">//当未调用prepare()方法时。ThreadLocal.get()方法返回的为null;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为本线程准备对应的MyLooper对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (threadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException( <span class="string">&quot;Only one MyLooper may be created per thread&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        threadLocal.set(<span class="keyword">new</span> MyLooper());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里启动消息循环</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            myLooper = myLooper();</span><br><span class="line">            MyMessageQueue mQueue = myLooper.queue;</span><br><span class="line">            senior.thread_concurrent.handler.MyMessage msg = mQueue.next();<span class="comment">// take()方法是个阻塞方法。线程运行到此会阻塞住。以准备接收发过来的消息</span></span><br><span class="line">            msg.target.dispatchMessage(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="简版messagequeue"><a href="#简版MessageQueue" class="headerlink" title="简版MessageQueue"></a>简版MessageQueue<a href="#简版messagequeue" class="header-anchor">#</a></h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMessageQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;MyMessage&gt; queue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> quit = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyMessageQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</span><br><span class="line">        queue.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入队</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MyMessage msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;消息必须有一个消息处理者&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            queue.put(msg);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出队</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyMessage <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MyMessage msg = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (quit) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            msg = queue.take();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//销毁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">quit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        quit = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="简版message"><a href="#简版Message" class="headerlink" title="简版Message"></a>简版Message<a href="#简版message" class="header-anchor">#</a></h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMessage</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> msg1;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> msg2;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> what;</span><br><span class="line">    <span class="keyword">public</span> Object obj;</span><br><span class="line">    <span class="keyword">public</span> MyHandler target;</span><br><span class="line">    <span class="keyword">public</span> Runnable runnable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="写一个网络请求的测试用例"><a href="#写一个网络请求的测试用例" class="headerlink" title="写一个网络请求的测试用例"></a>写一个网络请求的测试用例<a href="#写一个网络请求的测试用例" class="header-anchor">#</a></h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> senior.thread_concurrent.handler.MyHandler mainHandler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> TestClient().test();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化主线程Looper</span></span><br><span class="line">        MyLooper.prepare();</span><br><span class="line">        mainHandler = <span class="keyword">new</span> senior.thread_concurrent.handler.MyHandler(<span class="keyword">new</span> senior.thread_concurrent.handler.MyHandler.CallBack() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(senior.thread_concurrent.handler.MyMessage msg)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 刷新界面</span></span><br><span class="line">                String obj = (String) msg.obj;</span><br><span class="line">                LogUtil.print(<span class="string">&quot;刷新界面:&quot;</span> + obj);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//发起网络请求</span></span><br><span class="line">        LogUtil.print(<span class="string">&quot;在主线程发起一个网络请求&quot;</span>);</span><br><span class="line">        NetThread netThread = <span class="keyword">new</span> NetThread(<span class="string">&quot;http://baidu.com&quot;</span>);</span><br><span class="line">        netThread.start();</span><br><span class="line">        LogUtil.print(<span class="string">&quot;在主线程继续其它操作&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开始消息循环</span></span><br><span class="line">        MyLooper.loop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//网络线程类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">NetThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String url;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">NetThread</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.url = url;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            String body = getWebData(url);</span><br><span class="line">            senior.thread_concurrent.handler.MyMessage msg = <span class="keyword">new</span> senior.thread_concurrent.handler.MyMessage();</span><br><span class="line">            msg.obj = body;</span><br><span class="line">            mainHandler.sendMessage(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行网络请求</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getWebData</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">        LogUtil.print(<span class="string">&quot;执行请求网络:&quot;</span> + url);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        String body = <span class="string">&quot;这是&quot;</span> + url + <span class="string">&quot;的响应值&quot;</span>;</span><br><span class="line">        LogUtil.print(<span class="string">&quot;请求网络成功:&quot;</span> + body);</span><br><span class="line">        <span class="keyword">return</span> body;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="说一说handler延时原理"><a href="#说一说Handler延时原理？" class="headerlink" title="说一说Handler延时原理？"></a>说一说Handler延时原理？<a href="#说一说handler延时原理" class="header-anchor">#</a></h3><p>首先Handler无论是post还是sendMessage方式处理Message过程中，都会产生一个时间戳，计算方式是SystemClock.uptimeMillis() + delayMillis，这个时间戳会赋值给Message.when，影响Message在MessageQueue链表中的位置。时间戳值越大，越晚执行。</p>
<p>Handler延时存在时间不准的问题，问题产生原因以及解决办法以及在<u>面试题2问题：Handler延时不准确，经常到了时间不响应业务</u>提到。</p>
<h3 id="handler延时有哪些缺陷造成这些缺陷的原因"><a href="#Handler延时有哪些缺陷？造成这些缺陷的原因？" class="headerlink" title="Handler延时有哪些缺陷？造成这些缺陷的原因？"></a>Handler延时有哪些缺陷？造成这些缺陷的原因？<a href="#handler延时有哪些缺陷造成这些缺陷的原因" class="header-anchor">#</a></h3><p>参考<u>面试题2问题：Handler延时不准确，经常到了时间不响应业务</u></p>
<p>Handler的post与sendMessage有哪些区别？</p>
<p>post需要指定Runnable参数，将传入的Runnable绑定至Handler默认的Message，很多值都为默认值，换言之post方法只是为了执行Runnable子线程的任务。</p>
<p>sendMessage需要传入开发者自定义的Message参数，将Message中的信息载体传递下去，sendMessage方法是为了传递消息。</p>
<p>两者最终都会将Message传递下去，区别是Message中的数据信息赋值数量的不同。</p>
<h3 id="子线程能使用handler吗"><a href="#子线程能使用Handler吗？" class="headerlink" title="子线程能使用Handler吗？"></a>子线程能使用Handler吗？<a href="#子线程能使用handler吗" class="header-anchor">#</a></h3><p>能，可以使用handler对象以及对应的方法。区别是Handler的创建位置，如果Handler在主线程创建，那么只能在主线程中处理消息。如果在子线程创建Handler，那么才能在子线程处理消息。</p>
<h3 id="子线程能创建handler吗"><a href="#子线程能创建Handler吗？" class="headerlink" title="子线程能创建Handler吗？"></a>子线程能创建Handler吗？<a href="#子线程能创建handler吗" class="header-anchor">#</a></h3><p>能，前提是需要Looper.prepare+Looper.loop</p>
<p>Looper.prepare是将当前线程添加到sThreadLocal中，Looper.loop是开启无限循环，不断执行Message</p>
<h3 id="子线程创建handler这么麻烦有什么替代方法吗了解过handlerthread吗"><a href="#子线程创建Handler这么麻烦，有什么替代方法吗？了解过HandlerThread吗？" class="headerlink" title="子线程创建Handler这么麻烦，有什么替代方法吗？了解过HandlerThread吗？"></a>子线程创建Handler这么麻烦，有什么替代方法吗？了解过HandlerThread吗？<a href="#子线程创建handler这么麻烦有什么替代方法吗了解过handlerthread吗" class="header-anchor">#</a></h3><p>HandlerThread的run方法中替我们做了Looper.prepare+Looper.loop</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line">HandlerThread handlerThread = <span class="keyword">new</span> HandlerThread(<span class="string">&quot;handler-thread&quot;</span>);</span><br><span class="line">handlerThread.start(); <span class="comment">// 必须在Handler创建前调用，因为线程start后才会创建Looper</span></span><br><span class="line"></span><br><span class="line">Handler threadHandler = <span class="keyword">new</span> Handler(handlerThread.getLooper()) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">        <span class="comment">// 处理消息，因为这个方法是在子线程调用，所以可以在这执行耗时任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<h3 id="了解过idlehandler吗"><a href="#了解过IdleHandler吗？" class="headerlink" title="了解过IdleHandler吗？"></a>了解过IdleHandler吗？<a href="#了解过idlehandler吗" class="header-anchor">#</a></h3><p>IdleHandler 用途：</p>
<ol>
<li>IdleHandler 是 Handler 提供的一种在消息队列空闲时，执行任务的时机；</li>
<li>当 MessageQueue 当前没有立即需要处理的消息时，会执行 IdleHandler；</li>
<li>Activity界面绘制结束的回调时机</li>
</ol>
<p>IdleHandler 缺点：</p>
<ol>
<li>但它执行的时机依赖消息队列的情况，那么如果 MessageQueue 一直有待执行的消息时，IdleHandler 就一直得不到执行，也就是它的执行时机是不可控的，不适合执行一些对时机要求比较高的任务。</li>
</ol>
<p>IdleHandler场景</p>
<p>如果我们想在界面绘制出来后做点什么，那么在onResume里面是不合适的，它先于measure等流程了<strong>， **有人可能会说在onResume里面post一个runnable可以吗？还是不行，因为那样就会变成这个样子</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200814221532843.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoaXZhbHJvdXNtYW4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>所以你的行为一样会在绘制之前执行，这个时候我们的主角IdleHandler就发挥作用了，我们前面说了，它是在looper里面message暂时执行完毕了就会回调，顾名思义嘛，Idle就是队列为空的意思，那么我们的onResume和measure, layout, draw都是一个个message的话，这个IdleHandler就提供了一个它们都执行完毕的回调了，大概就是这样<br><img src="https://img-blog.csdnimg.cn/20200814221511481.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoaXZhbHJvdXNtYW4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>也就是说IdleHandler可以再界面绘制的消息回调之后执行。<br><img src="https://img-blog.csdnimg.cn/20200814221456646.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoaXZhbHJvdXNtYW4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>优化前：</p>
<p>这个是我们地图的公交详情页面， 进入之后产品要求左边的页卡需要展示，可以看到左边的页卡是一个非常复杂的布局，那么进入之后的效果可以明显看到头部的展示信息是先显示空白再100毫秒左右之后才展示出来的，原因就是这个页卡的内容比较复杂，用数据向它填充的时候花了较长时间，代码如下：<br><img src="https://img-blog.csdnimg.cn/2020081422161443.png#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9mLndldGVzdC5xcS5jb20vZ3FvcC8xMDAwMC8yMDAwMC9MYWJJbWFnZV8xNjY0ODA1Yjc3YTAxZDE5MGUwY2Y2MGY2YjkxMGI1MS5naWY"></p>
<p>可以看到这个detailView就是这个侧滑的页卡了，填充里面的数据花了90ms，如果这个时间是用在了界面view绘制之前的话，就会出现以上的效果了，view先是白的，再出现，这样就体验不好了。</p>
<p>优化后：如果我们把它放到IdleHandler里面呢？</p>
<p>结果非常明显：顶部的页卡先展示出来了，这样体验是不是会更好一些呢。虽然只有短短90ms，不过我们做app也应该关注这种细节优化的，是吧~ 这个做法也提供了一种思路，android本身提供的activity框架和fragment框架并没有提供绘制完成的回调，如果我们自己实现一个框架，就可以使用这个IdleHandler来实现一个onRenderFinished这种回调了。</p>
<p>代码如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20200814221558397.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoaXZhbHJvdXNtYW4=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9mLndldGVzdC5xcS5jb20vZ3FvcC8xMDAwMC8yMDAwMC9MYWJJbWFnZV83MTliYjQ0YjE3NTZkOTE4OGJkOGExMzQyNTE1NWIzYS5naWY"><br>特别参考</p>
<p><a href="https://wetest.qq.com/lab/view/352.html">https://wetest.qq.com/lab/view/352.html</a></p>
<p><a href="https://blog.csdn.net/u013718120/article/details/51945490">https://blog.csdn.net/u013718120/article/details/51945490</a></p>
<link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>Android</category>
        <category>面试</category>
        <category>应用层</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Handler</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么要花3年时间面试一个人？</title>
    <url>/blog//2019/01/why-dose-it-take-three-years-to-interview-a-guy%EF%BC%9F/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="为什么要花3年时间面试一个人"><a href="#为什么要花3年时间面试一个人？" class="headerlink" title="为什么要花3年时间面试一个人？"></a>为什么要花3年时间面试一个人？<a href="#为什么要花3年时间面试一个人" class="header-anchor">#</a></h1><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景<a href="#背景" class="header-anchor">#</a></h1><p>2018年笔者陪同公司部门老大负责技术面试，3个月时间，从收到简历到电话面试、现场面试，再算上Boss直聘打招呼数，总共有不下1000次。招聘过程可谓呕心沥血，效果却差强人意。</p>
<p>曾作为求职者，我面试拿offer总是能满载而归；如今作为一名招聘（临时）者，找到一个合适的候选者难如登天？</p>
<p>在网上看求职攻略、招聘经验帖子时，我总在想一个问题，是什么因素阻碍了企业找到靠谱的候选者？</p>
<p>直到我看了这篇《怎样花两年时间去面试一个人 》。文章里提到了一个理论——“用两年面试一个候选者”<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[《怎样花两年时间去面试一个人 》](http://mindhacks.cn/2011/11/04/how-to-interview-a-person-for-two-years/)">[3]</span></a></sup>，起初我不太理解为什么要花这么久时间，最终换位站在求职者的角度，总算读明白了。</p>
<p>当我作为求职者的时候，我会基于先前（求职）经验，摆上Blog、Github主页链接，附上自己的读书清单，这些行为无形中是向招聘者展示我过去1-3年时间做了什么真实产出，有哪些深刻收获。</p>
<p>而当我作为招聘（临时）角色，我一没有招聘经验，二无法有效率的识别该候选者是否匹配公司的需求——归结到最后，是因为我缺乏作为技术招聘者的基本能力，导致了我招聘面试过程中束手束脚。</p>
<h1 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状<a href="#现状" class="header-anchor">#</a></h1><p><strong>那么该如何作为一名合格的技术招聘者呢？</strong></p>
<p>面试官和求职者看似是互相对立，见招拆招的关系，实际上也有一层未来同事身份。所以作为一名技术面试官，我们要在充分理解企业需求的前提下，对候选者进行收集、过滤、筛选、面试、决策等一系列行为。</p>
<p><strong>问他又来了，如何理解企业岗位需求呢？</strong></p>
<p>作为员工，直接跟技术部门领导、人力资源部门领导沟通，很容易得到一些标准的需求指标：胜任、稳定、可靠、专业能力过硬等等。</p>
<p>等等，题目不是“为什么要花3年时间面试一个人”么，为什么要浪费篇幅讨论成为一个合格的技术招聘专家呢？</p>
<p>因为用3年时间面试一个人是“果”，这里面的“因”是默认你已经是一个合格的技术招聘专家了。只有当我们成为一名成熟的技术招聘人员，我们才愿意花费大量时间去收集、筛选、过滤一名真正对企业有价值的候选者。</p>
<p>假设我们从HR那里，从用人部门这里拿到了岗位说明，工作内容说明等，基于稳定性，能力等指标，我们要开始招聘了。那么第一个问题是，从哪里找到合适的候选者？</p>
<p>在下文“软件高工们的招人妙诀”中，有很多创业公司CEO心酸的招聘经历，想必每一个技术招聘者都会面临这种困境：</p>
<ul>
<li>收不到合适的简历，Boos、拉钩、智联，要不就是简历太多筛选麻烦，要不就是简历不合格浪费时间，要不就是根本收不到简历——这种情况比较少，很多事招聘者自己的问题，主要原因在前两种——大海捞针难；</li>
<li>有合适的简历，但人不愿意来：1.公司给的预算太少，给不了候选者满意薪水，跟市场薪水比没有竞争力；2.公司品牌、产品竞争力不吸引人，浪费大牛时间</li>
</ul>
<p><strong>读完这些高工们的招人妙诀，我总结了一版通用的招聘流程：</strong></p>
<ol>
<li>编写岗位说明写明：除了明确的技术能力，还需要在说明底部要求候选者需要提供blog、github、stackoverflow主页链接（强烈推荐）；读书笔记（推荐）；工作笔记（一般）。</li>
<li>能在简历上提供链接的，好了我们可以点进去看这个人最近3年在做什么，github提交记录，看了哪些书，写了哪些总结，解决了多少issues等等，这是一个人真实的产出，无法造假的东西。</li>
<li>只要链接里的内容不算太差，都可以约一个电话面试简单聊聊，这种人进入二面技术面的几率大一些。</li>
<li>进入二面，再围绕计算机基础（操作系统、设计模式、算法与数据结构、数据库、编程语言）、项目经验、BugFree、系统设计等多项能力综合考察。结合步骤2简历提供的要素，在每项能力、每个要素上打分，最终得到一个综合评价分。</li>
<li>根据分数，将候选者划分为：强烈推荐-优秀-良好-一般-不推荐5个等级，跟结合用人部门、人力部门的评分，再谈是否发放offer以及薪水package等等。</li>
</ol>
<h1 id="冲突和挑战"><a href="#冲突和挑战" class="headerlink" title="冲突和挑战"></a>冲突和挑战<a href="#冲突和挑战" class="header-anchor">#</a></h1><p>作为招聘人员，必须面对的挑战是，根本无法通过公开渠收集简历，找到真正牛且适合公司的候选者；因为<a href="http://www.joelonsoftware.com/articles/FindingGreatDevelopers.html">真正的牛人也许一辈子就投大概4次简历</a>；而市场上的“人才”大多不是什么人才，招到这些人轻则浪费时间，重则把公司搞挂（笔者上一家年利润过亿的公司就是如此）。</p>
<p>看了网上许多帖子，结合自己的招聘经历来看，招聘过程会面临以下挑战：</p>
<ul>
<li>简历履历造假，包括学历、公司经验、岗位内容等；</li>
<li>技能造假，只会写if-else，就敢写精通某某语言；只听过GCRoot技术名词，就勇于展示自己熟悉JVM；</li>
<li>IT教育机构给学员做的面试包装培训，派老师参加面试套公司的笔试题和面试题，让学员背题，面试题话术整得比部分面试官还专业；</li>
</ul>
<p>…</p>
<blockquote>
<p>笔者并无疑讽刺、贬低IT培训机构出身的学员，只是将此类人将其当做一种招聘挑战</p>
</blockquote>
<p>在种种困难之下，招聘者想找到一个合适的候选者难上加难。因此成为合格的技术招聘专家迫在眉睫。</p>
<p>为了寻求一种高效的招聘方法，我读了网上很多招聘求职帖子，刘未鹏老师《怎样花两年时间去面试一个人 》给我的启发最大。启发有两部分，文章观点总结、技术招聘方案</p>
<p>我将其文章及该文章中参考索引的文章内容总结如下：</p>
<ul>
<li>找工作的首要原则是什么？答：弄清楚雇主的需求到底是什么</li>
<li>从哪里发现雇主的需求？答：公司主页上的推荐书单，招聘网站，公开渠道广受好评的技术书单如《编程之美》、《成为xx技术专家之道》的书籍。</li>
<li>公司如何对候选者进行一场长达3年的面试？答：提供Github链接、博客地址、StackOverflow地址、甚至是Leetcode个人主页、牛客网个人主页</li>
<li>个人主页链接有哪些不可替代的优点？答：清晰、明确、完全可度量；不用担心伪造，有push review历史，交流记录，足够体现了求职者的可信、负责任程度</li>
<li>公司为什么一定要列求职者书单计划？答：“书单计划”能很大程度上起到<strong>强鉴别器</strong>的作用，看了就是看了，必然能学到东西，没看就是没看。<strong>知道和不知道，区别是本质的</strong>。</li>
<li>怎样识别人才？答：实战能力，协作沟通能力，学习能力，学习热情，稳定性测试，香蕉测试，专业测试<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[社会招聘，怎样测试稳定性]( https://mp.weixin.qq.com/s/ZyEWV1g_UzXODkViyFdNlw)     
">[1]</span></a></sup></li>
</ul>
<h1 id="软件高工们招人的妙诀"><a href="#软件高工们招人的妙诀" class="headerlink" title="软件高工们招人的妙诀"></a>软件高工们招人的妙诀<a href="#软件高工们招人的妙诀" class="header-anchor">#</a></h1><p><strong>邹欣</strong>：“你的工作就是最好的面试”</p>
<p><a href="http://www.weibo.com/grapef"><strong>熊力</strong></a>：<a href="http://www.weibo.com/1709648133/xoEQmBmDg">“我当年毕业的时候总结了一个公式：第一份工作的月薪=大学四年买过的技术书籍价格的总和。”</a></p>
<p><strong>周源<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[创业公司怎么招人](https://www.zhihu.com/question/19551593)？
">[2]</span></a></sup>：</strong></p>
<blockquote>
<p>其实从 08 年到现在，我一直想这事能不能有点窍门，或者是实用的方法，结论是几乎没有。我用过的大家都用的方法：</p>
<ul>
<li>在水木上发贴子（有点效果） </li>
<li>在蓝色理想上发贴子（无效） </li>
<li>在技术邮件组里发贴子（无效） </li>
<li>买 51job/智联 最便宜的服务（有点效果） </li>
<li>给所有可以想到的人打电话，请他们推荐（无效） </li>
<li>给所有和你讨论过创业，喝过点小酒的人打电话（无效） </li>
<li>约前同事私下谈（有效） </li>
</ul>
<p>我用过的大家可能没有用的方法：     </p>
<ul>
<li>上 twitter，看 XXX 的 follower，一个一个看，看他们的 twitter，博客，Google Reader 分享，想办法搞到邮件，联系，半夜电话骚扰。 </li>
<li>上豆瓣，前端后端挑几本重量级的书，去找想看，看过，正在看这本书的人，一个一个看，看他们的活动，博客，Google Reader 分享，想办法搞到邮件，联系，半夜电话骚扰。 </li>
<li>找同事，问他们都看什么技术博客，想办法搞到邮件，联系，半夜电话骚扰。 </li>
</ul>
</blockquote>
<p><strong>刘未鹏</strong></p>
<blockquote>
<p>1.要求读过的书写读书报告。</p>
<p>2.<strong>Social Coding</strong>。</p>
<p>真实的项目，真实的流程，真实的人名，一切代码review, check-in, test, build, document, 甚至讨论，计划，brianstorming，流程，一切的一切，都是项目历史的一部分，都可以像棋局那样复盘。有经验的面试者只要稍稍扫两眼一个人的GitHub历史，挑出几个check-in历史看一看，便完全能够迅速判断这个人是否满足他的要求。不再需要费劲心机地去想题目，去观察，去揣测，去花费大量的时间的同时还只能采样到几个极为有限的点。</p>
<p>不像象牙塔里面大作业，这里有源代码管理系统，自动化build，有check-in，有review，有分工，有合作，最重要的是——这是一个<a href="http://wenku.baidu.com/view/ce92d9eef8c75fbfc77db28a.html">集市</a>，一个超出象牙塔的集市，牛人相互吸引，<strong>你可以在互联网上找到和自己拥有共同兴趣的一帮人，真正做起一点事情，而不是交差，不需要受限于几十个人的一个小班级。</strong><a href="http://www.amazon.com/Here-Comes-Everybody-Organizing-Organizations/dp/1594201536"><strong>Here Comes Everybody</strong></a>。</p>
<p>3.我们姑且把这个计划叫做“书单计划”，容易看到“书单计划”具备以下几个卓越的优点：</p>
<ol>
<li>清晰、明确。完全可度量。 </li>
<li>防伪：读没读过，随便一问便知。而正因为应聘者也知道这事不像实习经验可以忽悠，所以也不敢乱往简历上捅词。 </li>
<li>不在乎是否“泄题”：书单完全公开的，无所谓，本来就是要你去读的。想背题？背书吧。真能背下来说明认真看了。 </li>
<li>管你用心不用心读，只要读了，读完了，就有区别。真正的好书，你想不被吸引都难。据我观察很多人就是不知道该去读什么书。 </li>
<li>不存在“怎么做”的障碍：所有人都知道怎么读书——一页一页读。 </li>
<li>不需要招聘者投入精力：书单在此，就这么简单，您看着办。 </li>
<li>评估的负担很大程度转移到了应聘者的身上：是不是认真看完了，有没有心得体会，您自己掂量。没看完别来找我们。 </li>
</ol>
</blockquote>
<h1 id="大厂推荐的书单"><a href="#大厂推荐的书单" class="headerlink" title="大厂推荐的书单"></a>大厂推荐的书单<a href="#大厂推荐的书单" class="header-anchor">#</a></h1><h2 id="华为专家级工程师认证考试java推荐书单"><a href="#华为专家级工程师认证考试（Java）推荐书单：" class="headerlink" title="华为专家级工程师认证考试（Java）推荐书单："></a><strong>华为专家级工程师认证考试（Java）推荐书单：</strong><a href="#华为专家级工程师认证考试java推荐书单" class="header-anchor">#</a></h2><blockquote>
<p>部分资料为华为企业内部文档，外部无法检索</p>
</blockquote>
<ol>
<li>《软件架构设计》-温煜，掌握需求分析基本原理、过程、方法等内容，掌握UML、设计模式、架构方法</li>
<li>《大话设计模式》-程杰</li>
<li>《重构：改善既有代码的设计》，对于代码坏味道识别、分析、理解，基本重构原则，多种重构方法</li>
<li>《Efficetive java》</li>
<li>《Java2 核心技术》</li>
<li>《Java语言通用编程规范》</li>
<li>《Java语言安全编程规范》</li>
<li>《Java安全编码标准》</li>
<li>《Java问题调试与定位》，IDE的调试功能、调试工具全景图、熟练掌握应用</li>
<li>《有效的单元测试》</li>
<li>《单元测试之道》</li>
<li>《API接口测试》</li>
<li>《Gradle编译》</li>
<li>《Jeckeins+Gerrit+Git》</li>
</ol>
<h2 id="阿里云推荐必读书单"><a href="#阿里云推荐必读书单" class="headerlink" title="阿里云推荐必读书单"></a><strong>阿里云推荐必读书单</strong><a href="#阿里云推荐必读书单" class="header-anchor">#</a></h2><p>阿里云藏经阁也列举了求职者必看书单，可以移步至<a href="https://developer.aliyun.com/ebook/ranking?spm=a2c6h.20345107.J_8234604580.7.214717dbl72mBE">阿里云藏经阁</a></p>
<h1 id="软件高工推荐的书单"><a href="#软件高工推荐的书单" class="headerlink" title="软件高工推荐的书单"></a>软件高工推荐的书单<a href="#软件高工推荐的书单" class="header-anchor">#</a></h1><h2 id="洪强宁豆瓣技术总监"><a href="#洪强宁（豆瓣技术总监）" class="headerlink" title="洪强宁（豆瓣技术总监）"></a><a href="http://www.douban.com/people/hongqn/"><strong>洪强宁</strong></a><strong>（豆瓣技术总监）</strong><a href="#洪强宁豆瓣技术总监" class="header-anchor">#</a></h2><p>StackOverflow上有一个<a href="http://stackoverflow.com/questions/1711/what-is-the-single-most-influential-book-every-programmer-should-read">程序员必读书单</a>帖子，这里仅列出top10，更多参考<a href="http://book.douban.com/doulist/995723/">这里</a>。</p>
<ol>
<li>Code Complete 2 </li>
<li>The Mythical Man-Month （《人月神话》） </li>
<li>Code: The Hidden Language of Computer Hardware and Software （《编码的奥秘》） </li>
<li>TAOCP （不解释） </li>
<li>The Pragmatic Programmer （《程序员修炼之道》） </li>
<li>Design Patterns （《设计模式》） </li>
<li>The Structure and Interpretation of Computer Programs （《计算机程序的构造和解释》） </li>
<li>Refactoring （《重构》） </li>
<li>The C Programming Language </li>
<li>Introduction to Algorithms （《算法导论》） </li>
</ol>
<h2 id="冯大辉丁香园cto贝塔咖啡创始人"><a href="#冯大辉（丁香园CTO，贝塔咖啡创始人）" class="headerlink" title="冯大辉（丁香园CTO，贝塔咖啡创始人）"></a><a href="http://www.dbanotes.net/"><strong>冯大辉</strong></a><strong>（丁香园CTO，贝塔咖啡创始人）</strong><a href="#冯大辉丁香园cto贝塔咖啡创始人" class="header-anchor">#</a></h2><ol>
<li>软件随想录 </li>
<li>黑客与画家 </li>
<li>重来 </li>
<li>UNIX编程艺术 </li>
<li>编程人生 </li>
</ol>
<h2 id="云风中国游戏编程先行者前网易游戏部门资深程序员简悦创始人"><a href="#云风（中国游戏编程先行者，前网易游戏部门资深程序员，简悦创始人）" class="headerlink" title="云风（中国游戏编程先行者，前网易游戏部门资深程序员，简悦创始人）"></a><a href="http://blog.codingnow.com/"><strong>云风</strong></a><strong>（中国游戏编程先行者，前网易游戏部门资深程序员，简悦创始人）</strong><a href="#云风中国游戏编程先行者前网易游戏部门资深程序员简悦创始人" class="header-anchor">#</a></h2><p>如果面试，我会挑以下的我自己读过的书，让人选择他也读过的部分，再了解他对这些书的理解。这些书其实本质上就是两类，对所面对的东西（程序语言也好，操作系统也好，底层设施也好）本身的理解程度。以及另一类：对设计思想和原则的理解：</p>
<ol>
<li>C++编程思想 </li>
<li>Effective C++ </li>
<li>深度探索C++对象模型 </li>
<li>C++语言的设计和演化 </li>
<li>C专家编程 </li>
<li>C陷阱与缺陷 </li>
<li>C语言接口与实现 </li>
<li>Lua程序设计 </li>
<li>Linkers and Loaders </li>
<li>COM本质论 </li>
<li>Windows核心编程 </li>
<li>深入解析Windows操作系统 </li>
<li>程序员修炼之道 </li>
<li>代码大全 </li>
<li>UNIX编程艺术 </li>
<li>设计模式 </li>
<li>代码优化：有效使用内存 </li>
<li>深入理解计算机系统 </li>
<li>深入理解LINUX内核 </li>
<li>TCP/IP 详解 </li>
</ol>
<h2 id="刘未鹏认为面试微软前必须要读的十本书"><a href="#刘未鹏认为面试微软前必须要读的十本书" class="headerlink" title="刘未鹏认为面试微软前必须要读的十本书"></a><strong>刘未鹏认为面试微软前必须要读的十本书</strong><a href="#刘未鹏认为面试微软前必须要读的十本书" class="header-anchor">#</a></h2><ol>
<li>Code: The Hidden Language of Computer Hardware and Software （《编码的奥秘》） </li>
<li>Computer System: A Programmer’s Perspective （《深入理解计算机系统》） / Windows via C/C++ （《Windows核心编程》 / 《程序员的自我修养》 </li>
<li>Code Complete 2（《代码大全》）/ The Pragmatic Programmer （《程序员修炼之道》，我也把这本书称为《代码小全》） </li>
<li>Programming Pearls （《编程珠玑》） / Algorithms / Algorithm Design / 《编程之美》 </li>
<li>The C Programming Language </li>
<li>The C++ Programming Language / Programming: Principles and Practice Using C++ / Accelerated C++ </li>
<li>The Structure and Interpretation of Computer Programs （《计算机程序的构造和解释》） </li>
<li>Clean Code / Implementation Patterns </li>
<li>Design Patterns （《设计模式》） / Agile Software Development, Principles, Patterns, and Practices </li>
<li>Refactoring （《重构》） </li>
</ol>
<h2 id="邹欣msra创新工程中心首席研发经理"><a href="#邹欣（MSRA创新工程中心首席研发经理）" class="headerlink" title="邹欣（MSRA创新工程中心首席研发经理）"></a><a href="http://weibo.com/sdxinz"><strong>邹欣</strong></a><strong>（MSRA创新工程中心首席研发经理）</strong><a href="#邹欣msra创新工程中心首席研发经理" class="header-anchor">#</a></h2><p>关于创新的书籍(<a href="http://book.douban.com/doulist/1253169/">http://book.douban.com/doulist/1253169/</a>):</p>
<ol>
<li>The Myths of Innovation </li>
<li>The Innovator’s Dilemma </li>
<li>The Innovator’s Solution </li>
<li>Crossing the Chasm </li>
<li>Inside Intuit </li>
<li>盛田昭夫 </li>
<li>杰克·韦尔奇自传 </li>
<li>梦断代码 </li>
<li>Innovation </li>
<li>浪潮之巅 </li>
</ol>
<h2 id="张峥微软亚洲研究院副院长"><a href="#张峥（微软亚洲研究院副院长）" class="headerlink" title="张峥（微软亚洲研究院副院长）"></a><a href="http://www.weibo.com/bambooman"><strong>张峥</strong></a><strong>（微软亚洲研究院副院长）</strong><a href="#张峥微软亚洲研究院副院长" class="header-anchor">#</a></h2><ol>
<li>Algorithms (by Sanjoy Dasgupta, Christos Papadimitriou and Umesh Vazirani) </li>
<li>Data Structure and Algorithms </li>
<li>The C Programming Language </li>
<li>The Design of the UNIX Operating System </li>
<li>Compilers （龙书） </li>
<li>Computer Architecture: A Quantitative Approach </li>
<li>Flow </li>
<li>Outliers (why hard work and luck are both important) </li>
</ol>
<h2 id="郑昀窝窝团研发副总裁"><a href="#郑昀（窝窝团研发副总裁）" class="headerlink" title="郑昀（窝窝团研发副总裁）"></a><a href="http://weibo.com/yunzheng"><strong>郑昀</strong></a><strong>（窝窝团研发副总裁）</strong><a href="#郑昀窝窝团研发副总裁" class="header-anchor">#</a></h2><ol>
<li>工程师入门：<ol>
<li>Code Complete 2 </li>
<li>程序员修炼之道 </li>
<li>深入理解计算机系统 </li>
</ol>
</li>
<li>工程师升级：<ol>
<li>设计模式 </li>
<li>重构——改善既有代码的设计 </li>
</ol>
</li>
<li>工程师转型：<ol>
<li>快速软件开发——有效控制与完成进度计划 </li>
<li>人月神话 </li>
<li>IT项目管理那些事儿 </li>
<li>软件随想录 </li>
<li>最后期限 </li>
<li>走出软件作坊 </li>
<li>你的灯亮着吗?——发现问题的真正所在 </li>
</ol>
</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考<a href="#参考" class="header-anchor">#</a></h1><p><a href="http://gigix.thoughtworkers.org/2011/6/8/show-me-your-blog">ThoughtWorks给我看你的博客</a></p>
<p><a href="https://code.dblock.org/2011/07/14/github-is-your-new-resume.html">Github is Your New Resume</a></p>
<p><a href="http://mindhacks.cn/2009/02/15/why-you-should-start-blogging-now/">[BetterExplained]为什么你应该（从现在开始就）写博客</a> </p>
<p><a href="https://blog.csdn.net/oiio/article/details/6913156">为什么写技术博客对新人如此重要？</a></p>
<p><a href="http://www.amazon.com/Smart-Gets-Things-Done-Technical/dp/1590598385/">《Smart and Gets Things Done》</a></p>
<p>插件：<a href>Gtihub插件</a>-历史记录自动生成简历；StackOverflow历史记录生成简历</p>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://mp.weixin.qq.com/s/ZyEWV1g_UzXODkViyFdNlw">社会招聘，怎样测试稳定性</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.zhihu.com/question/19551593">创业公司怎么招人</a>？<a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="http://mindhacks.cn/2011/11/04/how-to-interview-a-person-for-two-years/">《怎样花两年时间去面试一个人 》</a><a href="#fnref:3" rev="footnote"> ↩</a></span></li></ol></div></div><link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>杂谈</category>
        <category>日记</category>
      </categories>
      <tags>
        <tag>程序人生，杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>详解五大排序算法</title>
    <url>/blog//2016/06/five-sort-algorithm/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>摘自本人16年的博客<a href="https://blog.csdn.net/chivalrousman/article/details/51585639">《详解五大排序算法》</a></p>
<h1 id="为什么要学习排序"><a href="#为什么要学习排序" class="headerlink" title="为什么要学习排序"></a>为什么要学习排序<a href="#为什么要学习排序" class="header-anchor">#</a></h1><hr>
<font size="4">
一旦建立一个重要的数据库后，就可能根据某些需求对数据进行不同方式的排序：
<font size="4">
比如闹钟功能，按时间远近排序出 闹钟列表，联系人列表按字母A-Z排序，城市列表按省市县的类别排序等等。
<font size="4">
排序非常重要而且非常耗时，幸好 人们已经总结出一系列的排序供我们学习，使用。
<font size="4">

<h1 id="如何排序"><a href="#如何排序？" class="headerlink" title="如何排序？"></a>如何排序？<a href="#如何排序" class="header-anchor">#</a></h1><font size="4">
NBA总决赛正在如火如荼的进行，老詹也正朝着他的第5个总亚军前进着。假设骑士队队员在运动场上排列成一队，如图所示，所有队员已经站好，准备热身，现在需要按身高从低到高 为队员们排队（最矮的站在左边），给他们照一张集体照，应该怎么排队呢？
<font size="4">
在排序这件事情上，人与计算机程序相比有以下优势：我可以同时看到所有的队员，并且可以立刻找出最高的一个，毫不费力得测量和比较每一个人的身高。而且队员们不一定要固守特定的空间，他们可以相互推推攘攘就腾出了位置，还能互相前后站立，经过一些具体的调整，毫不费力地给队员们排好队

<img src="http://cdn.yangchaofan.cn/篮球队友排序.png">



<font size="4">
 计算机程序员却不能像人这样通览所有的数据，它只能根据计算机的“比较”操作，在同一时间内对两个队员进行比较，算法 将"比较"的行为视为一个反复出现的问题，在人类看来是非常简单的事情，但程序算法 却只能一步一步得解决具体问题 和遵循一些简单的规则。

<blockquote>
<p>算法的本质就是拆分问题，按照最简单的规则，把问题拆分为一步一步交给计算机执行。</p>
</blockquote>
 <font size="4">
看上去这么简单，对吗：

<ol>
<li>比较两个数据项</li>
<li>交换两个数据项，或复制其中一项</li>
</ol>
<font size="4"> 
重复这两步循环执行，直到全部有序为止。
<font size="4">
不要轻视算法，因每种算法具体实现的细节有所不同。

<h1 id="bubble-冒泡排序"><a href="#BUBBLE-冒泡排序" class="headerlink" title="BUBBLE 冒泡排序"></a>BUBBLE 冒泡排序<a href="#bubble-冒泡排序" class="header-anchor">#</a></h1><hr>
<font size="4">
冒泡排序算法运行起来非常慢，但概念上它是排序算法中最简单的，适合刚开始研究算法技术时的入门。
<font>
<font size="4">
首先由一组无序的数字：

<p><img src="https://img-blog.csdnimg.cn/img_convert/34084b5a3c00d034c35592096e6d745b.png" alt="这里写图片描述"><br><font size="4"><br>我录制了一段冒泡排序的执行过程（需要1-2秒的缓冲）：</font></p>
<img src="http://cdn.yangchaofan.cn/BUBBLESORTGIF.gif">

<font size="4">
耐心观看完后，我们可以总结出冒泡排序的规则：

<ol>
<li>比较两个数字</li>
<li>如果左边的数字大，则交换两个数字的位置</li>
<li>向右移动一个位置，比较下两个数字<font size="4">
沿着这个顺序比较下去，一直比较到最右端，虽然没有把所有的数字排好序，但是，数字中最大的那一个已经排放在最右边了，这个是一轮比较下来 可以确定的结果。
<font size="4">
下一轮，我们继续从最左边开始。
<font size="4">
这也是这个算法被称为冒泡排序的原因：因为在算法执行的时候，最大的数据项 总是 "冒泡"到数组的顶端【数组的排列规则，从左到右0-N】。

</font></font></font></li>
</ol>
<font size="4">
效果这么棒，如何开始我们的第一行代码呢？
<font size="4">
首先封装一个BUBLE数组对象

<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayBub</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">long</span>[] a;<span class="comment">//定义一个数组</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> nElems;<span class="comment">//数据的个数</span></span><br><span class="line"><span class="comment">//-------------------------------------</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ArrayBub</span><span class="params">(<span class="keyword">int</span> max)</span></span>&#123;   <span class="comment">//构造函数</span></span><br><span class="line">		a =<span class="keyword">new</span> <span class="keyword">long</span>[max];   <span class="comment">//创建数组 </span></span><br><span class="line">		nElems=<span class="number">0</span>;   <span class="comment">//还没有添加数据</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//-------------------------------------</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">long</span> value)</span></span>&#123;   <span class="comment">//向数组中添加元素</span></span><br><span class="line">	a[nElems] = value;  <span class="comment">//插入数据</span></span><br><span class="line">	nElems++;  <span class="comment">//数据个数+1</span></span><br><span class="line">	&#125; </span><br><span class="line"><span class="comment">//-------------------------------------</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span> ; j&lt;nElems ; j++)&#123;   <span class="comment">//遍历数组中每一个元素</span></span><br><span class="line">			System.out.print(a[j]+<span class="string">&quot; &quot;</span>);   <span class="comment">//展示</span></span><br><span class="line">			System.out.println(<span class="string">&quot;&quot;</span>);  </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//-------------------------------------</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> out ,in;</span><br><span class="line">		<span class="keyword">for</span>(out=nElems-<span class="number">1</span>;out&gt;<span class="number">1</span>;out--)&#123;  <span class="comment">//外循环  每一轮都是从左到右 向后进行的</span></span><br><span class="line">			<span class="keyword">for</span>(in=<span class="number">0</span>;in&lt;out;in++)&#123;   <span class="comment">//内循环  每一次循环，都是把小的那一个数据放在前面</span></span><br><span class="line">				<span class="keyword">if</span>(a[in] &gt;a[in+<span class="number">1</span>] )&#123;</span><br><span class="line">					swap(in,in+<span class="number">1</span>);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;<span class="comment">//end bubblesort()</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//-------------------------------------</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> one,<span class="keyword">int</span>  two)</span></span>&#123;</span><br><span class="line">		<span class="keyword">long</span> temp =a[one]</span><br><span class="line">		a[one] = a[two];</span><br><span class="line">		a[two] = temp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<font size="4">
接着测试我们的代码：

<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BubbleSortAPP</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args)</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> maxSize=<span class="number">100</span>;              <span class="comment">//数组的长度</span></span><br><span class="line">	ArrayBub arr;                 <span class="comment">//声明我们封装的Bub数组对象</span></span><br><span class="line">	arr=<span class="keyword">new</span> ArrayBub(maxSize);    <span class="comment">//初始化数组</span></span><br><span class="line"></span><br><span class="line">	arr.insert(<span class="number">77</span>);               <span class="comment">//插入10个数据</span></span><br><span class="line">	arr.insert(<span class="number">22</span>);</span><br><span class="line">	arr.insert(<span class="number">44</span>);</span><br><span class="line">	arr.insert(<span class="number">66</span>);</span><br><span class="line">	arr.insert(<span class="number">88</span>);</span><br><span class="line">	arr.insert(<span class="number">11</span>);</span><br><span class="line">	arr.insert(<span class="number">33</span>);</span><br><span class="line">	arr.insert(<span class="number">77</span>);</span><br><span class="line">	arr.insert(<span class="number">77</span>);</span><br><span class="line">	arr.insert(<span class="number">77</span>);</span><br><span class="line"></span><br><span class="line">	arr.display();                 <span class="comment">//展示数据</span></span><br><span class="line"></span><br><span class="line">	arr.bubbleSort();              <span class="comment">//对数组中的数据 执行排序操作</span></span><br><span class="line"></span><br><span class="line">	arr.display();                 <span class="comment">//展示排序后的数据</span></span><br><span class="line"> 	&#125;  <span class="comment">//end main()</span></span><br><span class="line">&#125;<span class="comment">//end class BubbleSortAPP</span></span><br></pre></td></tr></table></figure></div>

<p>核心代码 bubbleSort（）方法只有四行（大括号可以缩进）：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(out=nElems-<span class="number">1</span>;out&gt;<span class="number">1</span>;out--)&#123;  <span class="comment">//外循环  每一轮都是从左到右 向后进行的</span></span><br><span class="line">			<span class="keyword">for</span>(in=<span class="number">0</span>;in&lt;out;in++)&#123;   <span class="comment">//内循环  每一次循环，都是把小的那一个数据放在前面</span></span><br><span class="line">				<span class="keyword">if</span>(a[in] &gt;a[in+<span class="number">1</span>] )&#123;  <span class="comment">//比较大小</span></span><br><span class="line">					swap(in,in+<span class="number">1</span>);   <span class="comment">//交换</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;<span class="comment">//end bub</span></span><br></pre></td></tr></table></figure></div>
<font size="4">
这个算法的思路是要将最小的数据项放在数组的最开始（数组下标为0），并将最大的数据项放在ishuzu的最后（数组下标为nElems-1），外层循环的计数器out，从数组最后开始，即out=nElems-1，每经过一次循环out减1，下标大于out的数据项都已经排好序了，变量out在没完成一次内部循环（计数器为in）后就左移一位，因此算法就不再处理那些已经排好序的数据了。
<font size="4">
内循环计数器in从数组的最开始算起，in=0，没弯沉过一次内部循环循环体加1，当它等于out时 结束一次循环，在内存for循环中，数组下标为 in 和in+1的两个数据项比较，如果下标为 in 的数据项大于下标为in+1的数据项，则交换两个数据项。

<h2 id="不变性"><a href="#不变性" class="headerlink" title="不变性"></a><strong>不变性</strong><a href="#不变性" class="header-anchor">#</a></h2><font size="4">
在许多算法中，有些条件在算法执行时，是不变的，这些条件称为不变性。认识不变性对理解算法是游泳的，在一定的情况下对调试也有用，可以反复得检查不变性是否为真，如果不是得话 就标记出错。
<font size="4">
在上述的bubbleSort.java中，不变性是指 out 右边的所有数据项为有序，在算法的整个运行过程中，这个条件始终为真。（在第一轮排序开始前，尚未排序，而out开始时在数据项的最右边，它已经是最右了，没有数据项在out的右边）

<h2 id="冒泡排序的效率"><a href="#冒泡排序的效率" class="headerlink" title="冒泡排序的效率"></a><strong>冒泡排序的效率</strong><a href="#冒泡排序的效率" class="header-anchor">#</a></h2><font size="4">
通过 考察10个数据项，第一轮比较了9次第二轮比较了8次，以此类推 9+8+7+6+5+4+3+2+1=45
<font size="4">
小学隔壁家的孩子，高斯同学就已经归纳出这种序列的求和公式：N*(N-1)/2 ;
<font size="4">
再运用大学高等数学的  "等价无穷小"定理，在N无限大的情况下， 2和 -1可以忽略不计，从而推导出算法作了N²次比较，而交换次数是小于比较次数的，而且如果数据是随机的，那么大概有一半数据需要交换，交换的次数也是N²，所以我们认为冒泡排序的运行需要O(N²)时间级别，从我录制的gfit原理图来看，冒泡排序的速度是很慢的，
<font size="4">
无论何时，只要看到循环嵌套在另一个循环里，就可以怀疑这个算法的运行时间为O(N²)级，

<h1 id="select-选择排序"><a href="#SELECT-选择排序" class="headerlink" title="SELECT 选择排序"></a><strong>SELECT 选择排序</strong><a href="#select-选择排序" class="header-anchor">#</a></h1><hr>
<font size="4">
选择排序改进了冒泡排序，将必要的交换次数从O(N²)减少到O(N)。看上去非常棒了，不幸的时候比较次数仍保持为 O(N²)，不要遗憾，选择排序仍然为大量的排序做出了一个非常重要的改进：
<font size="4">
因为izhexie大量的记录 需要在内存中移动，这就使得交换的时间和比较的时间相比，交换的时间更为重要（一般来说，在Java语言中不是这种情况，Java中只是改变了引用位置，而内存中世纪对象的位置并没有发生改变）

<h2 id="理解一下选择排序的原理"><a href="#理解一下选择排序的原理" class="headerlink" title="理解一下选择排序的原理"></a><strong>理解一下选择排序的原理</strong><a href="#理解一下选择排序的原理" class="header-anchor">#</a></h2><font size="4">
一组数据，

<img src="http://cdn.yangchaofan.cn/SelectSort数据.png">

<font size="4">
选择排序的原理，

<p><img src="https://img-blog.csdnimg.cn/img_convert/332e33b9488fa8f2711638bc3c015833.gif" alt="这里写图片描述"></p>
<h2 id="使用选择排序算法对老詹的队友们排序"><a href="#使用选择排序算法对老詹的队友们排序，" class="headerlink" title="** 使用选择排序算法对老詹的队友们排序，**"></a>** 使用选择排序算法对老詹的队友们排序，**<a href="#使用选择排序算法对老詹的队友们排序" class="header-anchor">#</a></h2><font size="4">
在选择排序中，不再比较两个相邻的队员，因此，需要记录下某个指定队员的高；可以用记事本记下队员的身高，同时还需要准备好一条紫红色的毛巾（不是搞基）。
<font size="4">
进行选择排序 就是把所有的队员扫描一遍，从中选择出最矮的一个队员，最矮的这个队员和站在队列最左端的队员交换位置，即占到0号位置，现在最左端的队员是有序的了，不再需要交换位置。注意，在这个算法中有序的队员都排在队列的最左边（数组中较小的下标值），而冒泡排序则是优先排列在队列的右边。
<font size="4">
排序从最左边开始，记录本上写下最左端球员的身高，并且在他的脖子上挂上红色毛巾，于是开始用下一个球员的身高和记录本上记录的值比较，如果下一个球员更矮，则在本子上划掉第一个球员的身高，记录第二个队员的身高，同时把红色毛巾从第一个球员的脖子上拿下来，挂在第二个队员的脖子上，继续沿着队列走下去，
<font size="4">
一轮下来，毛巾就会落在最矮的队员面前，接着，唯一拥有红毛巾的队员和队列最左边的队员交换位置，现在已经对一个队员排好序了，这期间做了N-1次比较，淡只进行了一次交换。
<font size="4">
嗯，老詹对你的建议很满意。

<h2 id="选择排序的代码实现"><a href="#选择排序的代码实现" class="headerlink" title="选择排序的代码实现"></a><strong>选择排序的代码实现</strong><a href="#选择排序的代码实现" class="header-anchor">#</a></h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArraySelect</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">long</span>[] a;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> nElems;</span><br><span class="line"><span class="comment">//--------------------------------</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ArraySelect</span><span class="params">(<span class="keyword">int</span> max)</span></span>&#123;</span><br><span class="line">	a = <span class="keyword">new</span> <span class="keyword">long</span>[max];</span><br><span class="line">	nElems = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//--------------------------------</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">long</span> value)</span></span>&#123;</span><br><span class="line">	a[nElems] = value;</span><br><span class="line">	nElems++;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//----------------------------------</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;nElems; j++)</span><br><span class="line">	 System.out.print(a[j]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">	 System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//----------------------------------</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> out,in,min;</span><br><span class="line">		<span class="keyword">for</span>(out=<span class="number">0</span>;out&lt;nElems-<span class="number">1</span>;out++)&#123;  <span class="comment">//外循环</span></span><br><span class="line">			min=out;   <span class="comment">//用红毛巾记录最小值</span></span><br><span class="line">			<span class="keyword">for</span>(in=out+<span class="number">1</span>;in&lt;nElems;in++)&#123;  <span class="comment">//最小值</span></span><br><span class="line">				<span class="keyword">if</span>(a[in]&lt;a[min])&#123;   <span class="comment">//如果是最小值</span></span><br><span class="line">					min=in;   <span class="comment">//就把红毛巾递给最下的</span></span><br><span class="line">					swap(out,min);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="comment">//end for(out)</span></span><br><span class="line">	&#125;<span class="comment">//end selectionSort</span></span><br><span class="line"><span class="comment">//-----------------------------------</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> one,<span class="keyword">int</span> two)</span></span>&#123;</span><br><span class="line">		<span class="keyword">long</span> temp=a[one];</span><br><span class="line">		a[one] = a[two];</span><br><span class="line">		a[two] = temp;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//------------------------------------</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<font size="4">
接着测试我们的选择排序吧：

<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SelectSortApp</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> maxSize = <span class="number">100</span>;</span><br><span class="line">	ArraySel arr;</span><br><span class="line">	arr = <span class="keyword">new</span> ArraySel(maxSize)</span><br><span class="line">	</span><br><span class="line">	arr.insert(<span class="number">88</span>);</span><br><span class="line">	arr.insert(<span class="number">81</span>);</span><br><span class="line">	arr.insert(<span class="number">33</span>);</span><br><span class="line">	arr.insert(<span class="number">87</span>);</span><br><span class="line">	arr.insert(<span class="number">38</span>);</span><br><span class="line">	arr.insert(<span class="number">22</span>);</span><br><span class="line">	arr.insert(<span class="number">11</span>);</span><br><span class="line">	arr.insert(<span class="number">44</span>);</span><br><span class="line">	arr.insert(<span class="number">77</span>);</span><br><span class="line">	arr.insert(<span class="number">99</span>);</span><br><span class="line"></span><br><span class="line">	arr.display();</span><br><span class="line"></span><br><span class="line">	arr.selectionSort();</span><br><span class="line">	</span><br><span class="line">	arr.display();</span><br><span class="line">	</span><br><span class="line">  &#125;<span class="comment">//end main()</span></span><br><span class="line"></span><br><span class="line">&#125;<span class="comment">//end class</span></span><br></pre></td></tr></table></figure></div>
<h2 id="不变性"><a href="#不变性-1" class="headerlink" title="不变性"></a><strong>不变性</strong><a href="#不变性" class="header-anchor">#</a></h2><font size="4">
在此例程序中，下标小于或等于out的位置 数据项总是有序的。

<h2 id="选择排序的效率"><a href="#选择排序的效率" class="headerlink" title="选择排序的效率"></a><strong>选择排序的效率</strong><a href="#选择排序的效率" class="header-anchor">#</a></h2><font size="4">
此例当中，对于10个数据项，需要45次比较，而10个数据项只需要10次交换，扩大数量级，对于100个数据项，需要4950次比较，但只有100次交换，运用高等数学“等价无穷小”定理，N值越大，比较次数是主要的，所以结论是选择排序和冒泡排序一样 都是O(N²)的效率，但选择排序无疑更快，因为它交换的次数更少。
<font size="4">
所以，不要小瞧选择排序。

<h1 id="insert-插入排序"><a href="#INSERT-插入排序" class="headerlink" title="INSERT 插入排序"></a><strong>INSERT 插入排序</strong><a href="#insert-插入排序" class="header-anchor">#</a></h1><hr>
<p>在大多数情况下，插入排序比冒泡排序，选择排序要好的多。虽然插入排序仍然需要O(N²)的时间，但是在一般的情况下，它要比冒泡排序快一倍，比选择排序快一点，尽管它比冒泡排序算法和选择排序算法都更麻烦一些，但它也并不复杂，它经常被用在教复杂的排序算法的最后阶段，例如<font color="red"><strong>快速排序</strong>。</font></p>
<h2 id="插入排序原理"><a href="#插入排序原理" class="headerlink" title="插入排序原理"></a><strong>插入排序原理</strong><a href="#插入排序原理" class="header-anchor">#</a></h2><font size="4">
一段数据： 

<img src="http://cdn.yangchaofan.cn/InsertSort.png">


<font size="4">
我录制了一段原理展示：

<img src="http://cdn.yangchaofan.cn/InsertSort录制.gif">

<h2 id="用插入排序提醒老詹吧"><a href="#用插入排序提醒老詹吧" class="headerlink" title="用插入排序提醒老詹吧"></a><strong>用插入排序提醒老詹吧</strong><a href="#用插入排序提醒老詹吧" class="header-anchor">#</a></h2><font size="4">
插入排序之前，队员随机站好。从排序过程的中间开始，可以更好地理解插入排序，这时队列已经排好了一半。

<p><strong>局部有序</strong><br><font size="4"><br>此时，队友中间有一个作为标记的队员，还是用紫红色毛巾作标记吧，这个作为标记的队员的左边的所有队员已经是局部有序了。这意味着这一部分人之间是按顺序排列的：每个人比他左边的人都搞，然而这些队员在队列中最终的位置还没有确定，因为，当没有被排过序的队员要插入到他们中间的时候，他们的位置还要变动。<br><font size="4"><br>注意，局部有序在冒泡排序和选择排序中是不会出现的。在这两个算法中，一组数据项在某个时刻是完全有序的：在插入排序中，一组数据仅仅是局部有序的。</font></font></p>
<p><strong>被标记的队员</strong><br><font size="4"><br>作为标记的队员，称为“被标记的队员”，他和他右边所有的队员都是未排序的<br><font size="4"><br>如图：<br><img src="https://img-blog.csdnimg.cn/img_convert/c28c979878bafa9ce594aeae1ee99b1e.png" alt="这里写图片描述"> </font></font></p>
<font size="4">
下面价格要做的是在<font color="red">局部的<font> <font color="blue">有序组中<font><font color="red">适当的位置 <font color="black"> 插入被标记的队员，然而要做到这一点，需要把部分已排序的队员右移腾出空间，为了提供移动所需的空间，就先让被标记的队员出列（在程序中，这个出列的行为，是该数据项被存储在一个临时变量中）
<font size="4">
现在移动已经排过序的队员来腾出空间，将局部有序中最高的队员移动到原来被标记队员所在位置，次高的队员移动到原来最高的队员所在位置，以此类推。
<font size="4">
局部有序的部分里多了一个队员，而未排序的部分少了一个队员，作为标记的球员，向右移动一个位置，所以他仍然放在未排序部分的最左边的队员勉强，重复这个过程，直到所有未排序的队员都被插入到局部有序队列中的合适位置。

<h2 id="插入排序的核心代码"><a href="#插入排序的核心代码：" class="headerlink" title="插入排序的核心代码："></a><strong>插入排序的核心代码：</strong><a href="#插入排序的核心代码" class="header-anchor">#</a></h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(）&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">int</span> in,out;</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">for</span>(out=left+<span class="number">1</span>;out&lt;nElems;out++)</span></span>&#123; <span class="comment">//外循环是分界线</span></span><br><span class="line">		<span class="keyword">long</span> temp=a[out];   <span class="comment">//删除被标记的数据</span></span><br><span class="line">		in = out ;   <span class="comment">//srat shifts at  out</span></span><br><span class="line">		<span class="keyword">while</span>(in&gt;<span class="number">0</span>&amp;&amp;a[in-<span class="number">1</span>]&gt;=temp)&#123;  <span class="comment">//until one is smaller</span></span><br><span class="line">			a[in] = a[in-<span class="number">1</span>];  <span class="comment">//shift item right，</span></span><br><span class="line">			--in;   <span class="comment">//go left one position</span></span><br><span class="line">		&#125;</span><br><span class="line">		a[in] =temp;   <span class="comment">//insert marked item</span></span><br><span class="line">	&#125;<span class="comment">// end for</span></span><br><span class="line">&#125;<span class="comment">//end insertionSort()</span></span><br></pre></td></tr></table></figure></div>
<blockquote>
<p>插入排序的完整代码改日补上</p>
</blockquote>
<font size="4">
在外层的for循环中，out变量从1开始，向右移动，它标记了未排序部分的最左端的数据，而在内层的while循环中，in变量从out变量开始，向左移动，直到temp变量小于  in  所指的数组数据项，或者它已经不能再往左移动，while 循环的每一轮循环都向右移动了一个已排序的数据项。


<h2 id="插入排序中的不变性"><a href="#插入排序中的不变性" class="headerlink" title="插入排序中的不变性"></a><strong>插入排序中的不变性</strong><a href="#插入排序中的不变性" class="header-anchor">#</a></h2><font size="4">
在每轮结束时，在标记的位置项插入后，比outer变量下标号小的数据项都是有序的

<p>##<strong>插入排序的效率（有趣）</strong><br><font size="4"><br>这个算法需要多少次比较和复制呢？在第一轮排序中，它最多比较一次，在第二轮最多比较两次，以此类推<br><font size="4"><br>1+2+3+…+N-1=N*（N-1）/2 次比较；<br><font size="4"><br>复制的次数，大致等于比较的次数，然而，一次复制与一次交换的时间耗费不同，相对于 随机顺序的数据这个算法比冒泡排序快一倍，比选择排序略快，<br><font size="4"><br>在任意情况下，插入排序的时间复杂度也为O(N²)。<br><font size="4"><br><font color="red"><strong>有趣的是</strong><br><font color="black"><font size="4"><br>对于已经有序或者基本有序的数据来说，插入排序要好得多，当数据有序的时候，while循环的条件总是false吗所以它成为了外层循环中的一个简单语句，执行N-1此，算法运行只需要O（N）的时间。这对一个基本有序的文件进行排序是一个简单而有效的方法。</font></font></font></font></font></font></font></font></p>
<font size="4">
然而，对于逆序排列的数据，每次比较和移动都会执行，在这种情况下，插入排序 并不比冒泡排序快。

<h1 id="merge-归并排序"><a href="#MERGE-归并排序" class="headerlink" title="MERGE 归并排序"></a><strong>MERGE 归并排序</strong><a href="#merge-归并排序" class="header-anchor">#</a></h1><hr>
<h2 id="直接上手归并排序no"><a href="#直接上手归并排序？NO！" class="headerlink" title="直接上手归并排序？NO！"></a><strong>直接上手归并排序？NO！</strong><a href="#直接上手归并排序no" class="header-anchor">#</a></h2><font size="4">
我们首先得了解递归的知识： 
<font size="3">
1. [限于篇幅和时间，点击这里了解递归](http://blog.csdn.net/speedme/article/details/21654357)
2. 以后会自己写一篇递归相关的博文，敬请关注

<p>##<strong>感受归并排序</strong><br><font size="4">一组随机数据： </font></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/5539e0ee1b91fd3a11950560580605ef.png" alt="这里写图片描述"></p>
<p><font size="4">归并排序流程： </font></p>
<img src="http://cdn.yangchaofan.cn/MerageSort归并排序.gif">





<p>##<strong>详解归并排序</strong><br><font size="5"><br> <strong>1. 归并排序有那么厉害吗？</strong><font size="4"><br> 冒泡排序，插入排序和选择排序要用O(N²)，而归并排序只要O(N<em>log<br> N)<br> 如果数据项N=10000，那么N²就是100000000，而N</em>logN只是40000，如果为这么多数据排序，<br> 选择归并排序的话需要40秒，<br> 选择插入排序？需要将近28个小时！</font></font></p>
<p><font size="5"><strong>2. 归并排序优点</strong> </font></p>
<p> <font size="4">容易实现，比快排容易理解</font></p>
<p><font size="5"><strong>3. 归并排序的缺点</strong></font></p>
<p><font size="4">它需要在存储器中有另一个大小等于被排序的数据项 长度的数组，如果初始数组几乎占满整个存储器，那么归并排序不会执行，但是如果有足够的内存，归并排序是一个很好的选择。</font></p>
<p>##<strong>归并有两个有序数组</strong></p>
<p><font size="4">归并算法的中心  是归并两个 已经有序的数组，归并两个有序数组 A和B，就生成了第三个数组C，数组C包含数组A和B的所有数据项，并且使他们有序的排列在数组C中，</font></p>
<blockquote>
<p>学习的步骤： 首先理解归并的过程，再去理解它是如何在排序中使用的。</p>
</blockquote>
<p><font size="4">假设有两个有序数组，不要求有相同的大小，假设数组A有4个数据，B有6个数据，它们被归并到数组C中，C初始化的时候就拥有10个存储空间</font></p>
<p><font size="4">如图：</font></p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="http://cdn.yangchaofan.cn/%E5%BD%92%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84.png" width="60%" alt>
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">
      图- 归并数组合并前后
      </div>
</center>

<p><font size="4">在这个图中，带圈的数组显示了把数组A和B中的数据项转移到数组C中的顺序</font></p>
<p><font size="4"> 接着下图表示了必要的比较，由此来决定复制那个数据项到表C中，再每一次比较之后，较小的数据项被复制到数组A中<br><img src="https://img-blog.csdnimg.cn/img_convert/da174bf1c68d4d66dd84a970921de15f.png" alt="这里写图片描述"></font></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/9b4baaaa180c954752cdf1164eef266b.png" alt="这里写图片描述"></p>
<p><font size="4"> 由于数组B在第八步以后是空的，所以不需要再去比较了，只要把数组A中所有剩余的数据项复制到数组C即可。</font></p>
<p><font size="4"> 我们直接上代码 解释一下归并的代码：</font></p>
<blockquote>
<p>注意，这只是理解归并排序的序曲，并不是归并的程序</p>
</blockquote>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">MergeApp</span></span>&#123;</span><br><span class="line"><span class="comment">//-------------------------------------</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] arrayA = &#123;<span class="number">23</span>,<span class="number">47</span>,<span class="number">81</span>,<span class="number">95</span>&#125;;</span><br><span class="line">		<span class="keyword">int</span>[] arrayB = &#123;<span class="number">7</span>,<span class="number">14</span>,<span class="number">39</span>,<span class="number">55</span>,<span class="number">62</span>,<span class="number">74</span>&#125;;</span><br><span class="line">		<span class="keyword">int</span>[] arrayC = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">		merge(arrayA,<span class="number">4</span>,arrayB,<span class="number">6</span>,arrayC);</span><br><span class="line">	display(arrayC,<span class="number">10</span>);</span><br><span class="line">	&#125;<span class="comment">// end main()</span></span><br><span class="line"><span class="comment">//---------------------------------------</span></span><br><span class="line">									<span class="comment">//归并A和B 的数据 到C中								</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arrayA,<span class="keyword">int</span> sizeA,</span></span></span><br><span class="line"><span class="function"><span class="params">							<span class="keyword">int</span>[] arrayB,<span class="keyword">int</span> sizeB, </span></span></span><br><span class="line"><span class="function"><span class="params">							<span class="keyword">int</span>[] arrayC)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> aDex=<span class="number">0</span>,bDex=<span class="number">0</span>,cDex=<span class="number">0</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span>(aDex &lt;sizeA &amp;&amp; bDex&lt;sizeB)&#123;   <span class="comment">//非空数组</span></span><br><span class="line">				<span class="keyword">if</span>(arrayA[aDex] &lt;arrayB[bDex])&#123;</span><br><span class="line">					arrayc[cDex++]=arrayA[aDex++];</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					arrayC[cDex++]=arrayB[bDex++];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	    </span><br><span class="line">	    <span class="keyword">while</span>(aDex&lt;sizeA)&#123;   <span class="comment">//数组B如果为空</span></span><br><span class="line">		  arrayC[cDex++]=arrayA[aDex++]  <span class="comment">//但数组A不为空</span></span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">while</span>(bDex&lt;sizeB)&#123; <span class="comment">//数组A如果为空</span></span><br><span class="line">			arrayC[cDex++]=arrayB[bDex++]   <span class="comment">//数组B不为空</span></span><br><span class="line">		&#125;</span><br><span class="line">&#125;<span class="comment">//end merage</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span>[] theArray,<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;size;j++)&#123;</span><br><span class="line">		System.out.print(theArray[j]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">	System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;<span class="comment">//end class </span></span><br></pre></td></tr></table></figure></div>
<p><font size="4"> 在main（）中创建数组 arrayA，arrayB，和数组arrayC；然后调用merge()方法把数组A,B归并到数组C中。</font></p>
<p><font size="4"> merge()方法有三个while循环，第一个whie循环是沿着数组arrayA和arrayB走，比较它们的循环，并且复制它们中较小的数据项到arrayC。</font></p>
<p><font size="4"> 第二个和第三while循环处理的是类似的情况，即，当两个数组arrayB，arrayA中任意一个为空，就把剩下的一个数组归并到arrayC中。</font></p>
<h2 id="通过归并进行排序"><a href="#通过归并进行排序" class="headerlink" title="通过归并进行排序"></a><strong>通过归并进行排序</strong><a href="#通过归并进行排序" class="header-anchor">#</a></h2><p><font size="4">归并排序的思想是把一个数组分成两半，排序每一半，然后用merge()方法把数组的两半归并成一个有序的数组。</font></p>
<p><font size="4">那么问题来了，如何为每一部分排序呢？答案是递归：把每一半都分成两个四分之一，对每个四分之一部分排序，然后把 它们归并成一个有序的一半。</font></p>
<p><font size="4">类似的，每一对八分之一 归并成一个有序的四分之一部分，每一对十六分之一部分归并成一个有序的八分之一部分，依次类推，反复地分割数组，直到得到的字数组只含有一个数据项。这就是归并的<font color="red">基本条件：假设只有一个数据项的数组是有序的。<br><font color="black"><br><font size="4">前面已经看到，递归方法在每次调用自身方法的时候，通常某个参数的大小会减小，而且方法每次返回时，参数值又恢复到以前，在mergeSort()方法中，每一次这个方法调用自身的时候 都会被分成两部份，而且，每一次返回时都会把两个较小的数组合并成一个更大数组。</font></font></font></font></p>
<p><font size="4">当mergeSort(）发现两个只有一个数据项的数组时，它就返回，把这两个数据项归并到一个有两个数据项的有序数组中，每个生成的一对两个数据项的数组又被合并成一个有4个数据项的有序数组，这个过程一直持续下去，数组越来越大直到整个数组有序，当初始的数组大小 是二的乘方的时候，最容易看明白：</font></p>
<blockquote>
<p>【归并越来越大的数组】 </p>
</blockquote>
<img src="http://cdn.yangchaofan.cn/归并越来越大的数组.png">



<p><font size="4">首先一定确保自己理解前面所讲的“归并”的概念。</font></p>
<p><font size="4">从上往下看，整幅图就非常直白了，</font></p>
<p><font size="4">当数组的小不是2的乘方，也容易理解 图： </font></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/75935002f2983e0c65e99ddf43136948.png" alt="这里写图片描述"> </p>
<p><font size="4"><strong>那么所有的这些子数组都存放在存储器的什么地方？</strong></font></p>
<p><font size="4">在这个算法中，创建了一个和初始数组一样大小的工作空间数组，这些子数组存储在这个工作空间数组中，也就是之前说的“原始数组中的子数组被复制到工作空间数组对应的空间上”。在每一次归并之后，工作数组的内容 就被复制回原来的数组中。</font></p>
<h2 id="注意力集中"><a href="#注意力集中" class="headerlink" title="注意力集中"></a><strong>注意力集中</strong><a href="#注意力集中" class="header-anchor">#</a></h2><p><font size="4"> 马上就会看到完整的mergeSort程序，首先，关掉手机，关掉音乐，屏蔽一切打扰，把注意力集中到执行归并排序的方法。下面就是它的程序代码：</font></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recMergeSort</span><span class="params">(<span class="keyword">long</span>[] workSpace,<span class="keyword">int</span> lowerBound,</span></span></span><br><span class="line"><span class="function"><span class="params">										<span class="keyword">int</span> upperBound)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(lowerBound ==upperBound)  <span class="comment">//如果只排列一个元素，那么不用排序，直接返回</span></span><br><span class="line">		 <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> mid=(lowerBound+upperBound)<span class="comment">//找到最中间的元素，</span></span><br><span class="line"></span><br><span class="line">		recMergeSort(workSpace,lowerBound,mid); <span class="comment">//sort low half</span></span><br><span class="line"></span><br><span class="line">		recMergeSort(workSpace,mid+<span class="number">1</span>,upperBoud);   <span class="comment">//sort high half</span></span><br><span class="line">	</span><br><span class="line">		merge(workSpace,lowerBound,mid+<span class="number">1</span>,upperBound);<span class="comment">//对每一半进行归并</span></span><br><span class="line">	&#125;<span class="comment">//end else</span></span><br><span class="line">&#125;end recMergeSort</span><br></pre></td></tr></table></figure></div>
<p><font size="4"> 正如上面看到的一样，除了基本条件外，这个方法只有四条语句，一句是计算中间位置的，还有两个递归，调用recMergeSort（每一个对应数组的一半），最后一句是merge（），用它来归并两个有序的部分。当这个范围只包含一个数组数据项(lowerBound==upperBound)的时候符合基本条件，立即返回。</font></p>
<p><font size="4">在我们的mergeSort.java中，mergeSort实际上只用来创建数组workSpace[],然后调用递归的程序recMergeSort(）来执行排序，workSpace数组的创建不放在recMergeSort（）的原因？因为递归操作重复创建数组，效率太低。</font></p>
<p><font size="4"> 下面显示完整的归并排序：</font></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DArray</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">long</span>[] theArray;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> nElems;</span><br><span class="line">	<span class="comment">//-----------------------------</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">DArray</span><span class="params">(<span class="keyword">int</span> max)</span></span>&#123;   <span class="comment">//构造函数</span></span><br><span class="line">		theArray=<span class="keyword">new</span> <span class="keyword">long</span>[max];<span class="comment">//创建数组</span></span><br><span class="line">		nElems=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//-----------------------------</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">long</span> value)</span></span>&#123;   <span class="comment">//添加元素</span></span><br><span class="line">		theArray[nElems] =value;</span><br><span class="line">		nElems++;   <span class="comment">//数组下标+1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//------------------------------</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;nElems;j++)&#123;</span><br><span class="line">			System.out.print(theArray[j]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">			System.out.println(<span class="string">&quot; &quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//-------------------------------</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">()</span></span>&#123;  <span class="comment">//被main()回调</span></span><br><span class="line">		<span class="keyword">long</span>[] workSpace=<span class="keyword">new</span> <span class="keyword">long</span>[nElems];   <span class="comment">//创造一个数组作为工作空间</span></span><br><span class="line">		recMergeSort(workSpace,<span class="number">0</span>,nElems-<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//--------------------------------</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recMergeSort</span><span class="params">(<span class="keyword">long</span>[] workSpace,<span class="keyword">int</span> lowerBound,</span></span></span><br><span class="line"><span class="function"><span class="params">											<span class="keyword">int</span> upperBound)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(lowerBound==upperBound)</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			intmid=(lowerBound+upperBound)/<span class="number">2</span>;</span><br><span class="line">			</span><br><span class="line">			recMergeSort(workSpace,lowerBound,mid);</span><br><span class="line"></span><br><span class="line">			recMergeSort(workSpace,mid+1lupperBound);</span><br><span class="line"></span><br><span class="line">			merge(workSpace,lowerBound,mid+<span class="number">1</span>,upperBound);  <span class="comment">//归并</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//----------------------------------</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">long</span>[] workSpace,<span class="keyword">int</span> lowPtr</span></span></span><br><span class="line"><span class="function"><span class="params">						<span class="keyword">int</span> highPtr,<span class="keyword">int</span> upperBound)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> j=<span class="number">0</span>;   <span class="comment">//工作区下标</span></span><br><span class="line">		<span class="keyword">int</span> lowerBound=lowPtr;</span><br><span class="line">		<span class="keyword">int</span> mid=highPtr-<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> n=upperBound-lowerBound+<span class="number">1</span>;  <span class="comment">//# of items</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span>(lowPtr&lt;=mid&amp;&amp; highPtr&lt;=upperBound)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(theArray[lowPtr]&lt;theArray[highPtr])</span><br><span class="line">				workSpace[j++]=theArray[lowPtr++]</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				workSpace[j++]=theArray[highPtr++];</span><br><span class="line">		&#125;<span class="comment">//end while</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span>(lowPtr&lt;=mid)</span><br><span class="line">			workSpace[j++]=theArray[lowPtr++]</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span>(highPtr&lt;=upperBound)</span><br><span class="line">			workSpace[j++]=theArray[highPtr++];</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			theArray[lowerBound+j]=workSpace[j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="comment">//end merge();</span></span><br><span class="line">	<span class="comment">//------------------------------------------------</span></span><br><span class="line">	</span><br><span class="line">&#125;<span class="comment">//end class DArray</span></span><br></pre></td></tr></table></figure></div>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MergeSortApp</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> maxSize=<span class="number">100</span>;   <span class="comment">//定义数组的长度</span></span><br><span class="line">		DArray arr;        </span><br><span class="line">		arr=<span class="keyword">new</span> DArray(maxSize);  <span class="comment">//创建数组</span></span><br><span class="line">		</span><br><span class="line">		arr.insert(<span class="number">94</span>);</span><br><span class="line">		arr.insert(<span class="number">64</span>);</span><br><span class="line">		arr.insert(<span class="number">33</span>);</span><br><span class="line">		arr.insert(<span class="number">65</span>);</span><br><span class="line">		arr.insert(<span class="number">65</span>);</span><br><span class="line">		arr.insert(<span class="number">55</span>);</span><br><span class="line">		arr.insert(<span class="number">77</span>);</span><br><span class="line">		arr.insert(<span class="number">11</span>);</span><br><span class="line">		arr.insert(<span class="number">38</span>);</span><br><span class="line">		arr.insert(<span class="number">99</span>);</span><br><span class="line">		arr.insert(<span class="number">25</span>);</span><br><span class="line">		arr.insert(<span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">		arr.display();</span><br><span class="line"></span><br><span class="line">		arr.mergeSort();</span><br><span class="line"></span><br><span class="line">		arr.display();</span><br><span class="line">		</span><br><span class="line">	&#125;<span class="comment">//end main();</span></span><br><span class="line">	</span><br><span class="line">&#125;<span class="comment">//end class MergeSortApp</span></span><br></pre></td></tr></table></figure></div>
<p><font size="4">如果在recMergeSort()方法中添加一些额外输出语句，就可以观察排序过程中的执行过程。请自行书写。</font></p>
<h2 id="归并排序的效率"><a href="#归并排序的效率" class="headerlink" title="归并排序的效率"></a><strong>归并排序的效率</strong><a href="#归并排序的效率" class="header-anchor">#</a></h2><p><font size="4">    正如前面提到的那样归并排序的运行时间O(N*logN),</font></p>
<h1 id="quick-快速排序"><a href="#QUICK-快速排序" class="headerlink" title="QUICK 快速排序"></a><strong>QUICK 快速排序</strong><a href="#quick-快速排序" class="header-anchor">#</a></h1><hr>
<p><font size="4">毫无疑问，快速排序是最流行的排序算法，在大多数情况下，快速排序都是最快的，执行时间为O(N*logN)级</font></p>
<p>##<strong>先了解划分算法</strong></p>
<p><font size="4">划分是快速排序的根本机制，加上划分本身也是一个有用的操作，所以在讲解快速排序之前，我们先要了解划分算法。</font></p>
<p><font size="4">划分数据就是把数据分为两组，使所有关键字大于特定值的数据在一组，使所有关键字小于特定值的数据项在另一组。</font></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/646a00866fe7ca695c90ffb969f9f83c.png" alt="这里写图片描述"></p>
<p><font size="4">很容易想象数据的划分结果：比如将学生分成平均成绩高于3.5和低于3.5的两组，</font></p>
<blockquote>
<p>另外，在算法中，通常称这个特定的值为枢纽pivot；</p>
</blockquote>
<p><font size="4">划分是如何执行的呢？</font></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">划分过程的partition.java</span><br><span class="line"></span><br><span class="line">class ArrayPar&#123;</span><br><span class="line">	private long[] theArray;</span><br><span class="line">	private int nElems;</span><br><span class="line">	&#x2F;&#x2F;---------------------------</span><br><span class="line">	public ArrayPar(int max)&#123;</span><br><span class="line">		theArray&#x3D;new long[max];</span><br><span class="line">		nElems&#x3D;0;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;---------------------------</span><br><span class="line">	public void insert(long value)&#123;</span><br><span class="line">		theArray[nElems] &#x3D;value;</span><br><span class="line">		nElems++;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;----------------------------</span><br><span class="line">	public int size()&#123;</span><br><span class="line">		return nElems;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;----------------------------</span><br><span class="line">	public void display()&#123;</span><br><span class="line">		System.out.print(&quot;A&#x3D;&quot;);</span><br><span class="line">		for(int j&#x3D;0;j&lt;nElems;j++)</span><br><span class="line">			System.out.print(theArray[j]+&quot; &quot;);</span><br><span class="line">		System.out.println(&quot; &quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;----------------------------</span><br><span class="line">	public int partitionIt(int left,int right,long pivot)&#123;</span><br><span class="line">		int leftPtr&#x3D;left-1;</span><br><span class="line">		int rightPtr&#x3D;right+1;</span><br><span class="line">	</span><br><span class="line">		while(true)</span><br><span class="line">		&#123;</span><br><span class="line">			while(leftPtr&lt;right &amp;&amp; theArray[++leftPtr]&lt;pivot)&#x2F;&#x2F;找出更大一个</span><br><span class="line">				;&#x2F;&#x2F;no </span><br><span class="line">			while(rightPtr&gt;left &amp;&amp;theArray[--rightPtr]&gt;pivot)</span><br><span class="line">				;&#x2F;&#x2F;no</span><br><span class="line">			if(leftPtr&gt;&#x3D;rightPtr)  &#x2F;&#x2F;如果超过了规定的值，就跳出，执行划分</span><br><span class="line">				break;</span><br><span class="line">			else                   &#x2F;&#x2F;没有超过规定的值，交换元素下标</span><br><span class="line">				swap(leftPtr,rightPtr);		</span><br><span class="line">		&#125;&#x2F;&#x2F;end while</span><br><span class="line">		return leftPtr;</span><br><span class="line">	&#125;&#x2F;&#x2F;end partitionIt()</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;--------------------------------------------</span><br><span class="line">	public void swap(int dex1,int dex2)</span><br><span class="line">	&#123;</span><br><span class="line">		long temp;</span><br><span class="line">		temp&#x3D;theArray[dex1];</span><br><span class="line">		theArray[dex1]&#x3D;theArray[dex2];</span><br><span class="line">		theArray[dex2]&#x3D;temp;</span><br><span class="line">	&#125;&#x2F;&#x2F;end swap();</span><br><span class="line">&#125;&#x2F;&#x2F;end class</span><br></pre></td></tr></table></figure></div>
<p><font size="4">接着在main函数中执行</font></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">class PartitionApp</span><br><span class="line">&#123;</span><br><span class="line">	public static void main(String[] args)</span><br><span class="line">	&#123;</span><br><span class="line">		int maxSize &#x3D;16;</span><br><span class="line">		ArrayPar arr;</span><br><span class="line">		arr&#x3D;new ArrayPar(maxSize);</span><br><span class="line">		for(int j&#x3D;0;j&lt;maxSize;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			long n&#x3D;(int)(Math.random()*199);</span><br><span class="line">			arr.insert(n);</span><br><span class="line">		&#125;</span><br><span class="line">		arr.display();</span><br><span class="line">		</span><br><span class="line">		long pivot&#x3D;99;&#x2F;&#x2F;枢纽值，</span><br><span class="line"></span><br><span class="line">		System.out.println(&quot;Pivot is &quot;+pivot);</span><br><span class="line"></span><br><span class="line">		int size&#x3D;arr.size();</span><br><span class="line"></span><br><span class="line">		int partDex&#x3D;arr.partitionIt(0,size-1,pivot);</span><br><span class="line"></span><br><span class="line">		System.out.println(&quot;Partition is at index &quot;+partDex);</span><br><span class="line">		</span><br><span class="line">		arr.display();</span><br><span class="line">	&#125;&#x2F;&#x2F;end  app</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>##<strong>划分算法</strong></p>
<p><font size="4">划分算法由两个指针开始工作，分别为leftPtr和rightPtr，这里的指针只是代表数据项，而不是C++中说的指针。</font></p>
<p><font size="4">实际上，leftPtr初始化时是在第一个数据项的左边一位，rightPtr是在最后一个数据项的右边一位，这是因为zai它们工作之前，它们都要分别的加一和减一。</font></p>
<p><font size="5"><strong>1. 停止和交换</strong></font></p>
<p> <font size="4">当leftPtr遇到比枢纽小的数据项时，它继续右移，因为这个数据项的位置已经处在数组的正确的位置。</font></p>
<p><font size="4"> 但是，当遇到比枢纽大的数据项时，它就停下来。</font></p>
<p><font size="4">类似的，当rightPtr遇到大于枢纽的数据项，继续左移，当发现比枢纽小的数据项，它停下来。</font></p>
<p><font size="4">两个内层的while循环，一个用于leftPtr，一个用于rightPtr。</font></p>
<p><font size="4">只有当指针推出while循环的时候，它才停止移动，下面是一段代码，描述了一个不再适当位置的数据项，是如何被执行的：</font></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">while(theArray[++leftPtr]&lt;pivot)</span><br><span class="line">		;&#x2F;&#x2F;no</span><br><span class="line">while(theArray[++rightPtr]&gt;pivot)</span><br><span class="line">		;&#x2F;&#x2F;no</span><br><span class="line">swap(leftPtr,rightPtr);</span><br></pre></td></tr></table></figure></div>
<p><font size="4">第一个while循环发现比枢纽大的数据项时推出，第二个循环在发现比枢纽小的数据项时推出。当这两个循环都推出之后，leftPtr，和rightPtr，指针都指向两个错误位置的数据项，所以要交换位置。</font></p>
<p><font size="4">ok，似乎明白了点什么。</font></p>
<p><font size="4">当两个指针相遇的时候，整个数组划分完毕，breat跳出！</font></p>
<p><font size="5"><strong>2. 处理异常数据</strong></font></p>
<p><font size="4">为什么会发生异常？<br><font size="4">如果所有的数据都小于枢纽，leftPtr变量将会便利整个数组，徒劳地寻找大于数据的数据项，然后跑出数组的最右端，产生数组越界异常。类似的情况也会发生在rightPtr上。</font></font></p>
<p><font size="4">为了避免数组越界异常，<br><font size="4">要在第一个循环中加上leftPtr&lt;right ，第二个循环中加入 rightPtr&gt;left ；<br><font size="4">在快速排序中，可以看到更为巧妙的解决枢纽的选择，它可以去掉这种数组越界的检测，要使得程序运行速度更快，在内部循环中削减代码总是一个好方法。</font></font></font></p>
<p><font size="5"><strong>3.精巧的代码</strong></font></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">while(theArray[++leftPtr]&lt;pivot)</span><br><span class="line">		;&#x2F;&#x2F;no</span><br><span class="line">while(theArray[++rightPtr]&gt;pivot)</span><br><span class="line">		;&#x2F;&#x2F;no</span><br></pre></td></tr></table></figure></div>
<p><font size="4">while循环中的代码相当精巧，</font></p>
<p><font size="5"> <strong>3. 划分算法的效率</strong></font></p>
<p><font size="4">划分算法的运行时间为O(N)</font></p>
<p>##<strong>快速排序</strong></p>
<p><font size="5"> <strong>1. 基本的快速排序算法</strong></font></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">public void recQuickSort(int left,int right)</span><br><span class="line">&#123;</span><br><span class="line">	if(right-left&lt;&#x3D;0)  &#x2F;&#x2F;size&#x3D;&#x3D;1 不排序</span><br><span class="line">		return;</span><br><span class="line">	esle</span><br><span class="line">	&#123;</span><br><span class="line">		int partition&#x3D;partitionIt(left,right);</span><br><span class="line">		recQuickSort(left,partition-1); &#x2F;&#x2F;对枢纽的左边排序</span><br><span class="line">		recQuickSort(partition+1,right);  &#x2F;&#x2F;对枢纽的右边排序</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><font size="4">正如大家所看，有三个基本步骤：</font></p>
<p><font size="3">1. 把数组或者子数组划分成左边和右边<br>2. 调用自身对左边的一组排序<br>3. 调用自身对右边的一组排序。</font></p>
<p><font size="4">每一次划分，所有左边的子数组的数据项都小于右边字数组的数据项，只要对左边数组和右边数组分别排序，整个数组就是有序的了。</font></p>
<p><font size="5">如何对子数组进行排序呢？ 通过递归调用排序算法自身就可以。</font></p>
<p><font size="4">如果不是理想状态，数组包含两个或者更多的数据项，算法就需要调用partitionIt()方法对这个数组进行划分。方法返回枢纽的下标值，它指向右边较大的 子数组最左端的数据项，划分标记给 出两个子数组</font></p>
<p><font size="4">如图所示：</font></p>
<img src="http://cdn.yangchaofan.cn/递归快速排序基础.png">




<p> <font size="5">**2. 快速排序性能极差的情况：性能为O(N²) ** </font></p>
<p>  <font size="4">对100个逆序的数据排序，会发现数据极其缓慢，而且需要划分更多更大的数组，这是为什么？</font></p>
<p><font size="4">问题出在枢纽的选择上。理想状态下，应该选择数据项中的中值 作为枢纽，也就是说，应该有一半的数据项大于枢纽，一半的数据项小于枢纽，这会使数组被划分成两个大小相等子数组。可是如果没有选择好枢纽，那么快排的结果，就是划分为一大一小两个子数组进行排序，这样会降低算法的效率，因为较大的子数组要被划分更多次。</font></p>
<p><font size="4">极端情况是，逆序排列的数据，一个子数组只有一个数据项，另一个字数组含有N-1个数据项，而且对于N-1的分割，所有的子数组都是1 和X-1的结果，很明显，划分所带来的好处没有了，算法的效率降低到O（N²）</font></p>
<p><font size="4">快排以O(N²)运行的时候，除了慢还有另外一个潜在问题，当划分的次数增加，递归方法的调用也增加了，每一次调用都在申请工作栈，极端情况，可以能回内存溢出，导致程序挂掉。</font></p>
<p><font size="4">所以，选择一个恰当的枢纽值，是实现快速排序的重点。</font></p>
<p><font size="5"><strong>3. 三数取中法</strong></font></p>
<p><font size="4">人们已经设计出很多更好的枢纽选择方法，方法都是为了避免枢纽选择最大或者最小的值。</font></p>
<p><font size="4">有一种这种的方法，我翻译为“三数取中法”(median-of-three) 如图:</font></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/9fd1cfbe0ffc6051c49a493a3d74dc11.png" alt="这里写图片描述"><br><font size="4">三数取中法除了选择枢纽更为有效之外，还有一个额外的好处：可以在第二个内部while循环中取消rightPtr&gt;left的测试，略微提高了算法的执行速度。</font></p>
<p><font size="4">你心里一定很疑惑，这是怎样实现的呢？</font></p>
<p><font size="4">因为在选择的过程中使用三数取中的方法不仅选择了枢纽，而且还对三个数据进行了排序，当三个数据项已经排好序，并且已经选择中值数据项作为枢纽后，此时就可以保证数组最左端的数据项小于等于枢纽，最右端的数据项大于等于枢纽，</font></p>
<p>三数取中法的另一个好处就是，对左端，中间，以及右端的数据排序之后，划分过程就不再考虑这三个数据项了，划分可以从left+1和right-1开始，因为left和right已经被有效的划分了。</p>
<blockquote>
<p>不理解划分？ 请倒回去看划分算法部分</p>
</blockquote>
<p><font size="4">这样，三数取中的划分方法不但避免了 执行效率低至O(N²)的可能，而且也提高了划分算法内部循环的执行速度。</font></p>
<p>###<strong>完整的快速排序代码：</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayIns</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">long</span>[] theArray;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> nElems;</span><br><span class="line">	<span class="comment">//-------------------------------</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ArrayIns</span><span class="params">(<span class="keyword">int</span> max)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">	theArray=<span class="keyword">new</span> ArrayIns(max);</span><br><span class="line">	nElems=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//--------------------------------</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">long</span> value)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">	theArray[nElesm]=value;</span><br><span class="line">	nElems++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//--------------------------------</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		System.out.print(<span class="string">&quot;A=&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;nElems;j++)</span><br><span class="line">		&#123; </span><br><span class="line">			System.out.print(theArray[j]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">			System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//---------------------------------</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">()</span> <span class="comment">//被main函数调用</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		recQuickSort(<span class="number">0</span>,nElems-<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//---------------------------------</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recQuickSort</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> size=right-left+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(size&lt;=<span class="number">3</span>)</span><br><span class="line">			manulSort(left,right);  <span class="comment">//如果数据项个数小，正常排序</span></span><br><span class="line">		<span class="keyword">else</span>   <span class="comment">//数据项个数多，进行快速排序</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">long</span> median=mediaOf3(left,right);    <span class="comment">//三数取中</span></span><br><span class="line">			<span class="keyword">int</span> partition=partitionIt(left,right,median);</span><br><span class="line">			recQuickSort(left,partition-<span class="number">1</span>);   <span class="comment">//划分</span></span><br><span class="line">			recQuickSort(partion+<span class="number">1</span>,right);   <span class="comment">///划分</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="comment">//end recQuicSort()</span></span><br><span class="line">	<span class="comment">//---------------------------------------</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">medianOf3</span><span class="params">(<span class="keyword">int</span> left，<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> center=（left+right）/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(theArray[left]&gt;theArray[center])</span><br><span class="line">			swap(left,center);</span><br><span class="line">		<span class="keyword">if</span>(theArray[left]&gt;theArray[right])</span><br><span class="line">			swap(left,right);</span><br><span class="line">		<span class="keyword">if</span>(theArray[center]&gt;theArray[right])</span><br><span class="line">			swap(center,right);</span><br><span class="line">		</span><br><span class="line">		swap(center,right-<span class="number">1</span>);   <span class="comment">//把枢纽值放在右边</span></span><br><span class="line">		<span class="keyword">return</span> theArray(right-<span class="number">1</span>);   <span class="comment">//返回中值</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//----------------------------------------</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> dex1,<span class="keyword">int</span> dex2)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">long</span> temp;</span><br><span class="line">		temp=theArray[dex1];</span><br><span class="line">		theArray[dex1]=theArray[dex2];</span><br><span class="line">		theArray[dex2]=temp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//-----------------------------------------</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partitionIt</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">long</span> pivot)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> leftPtr=left;</span><br><span class="line">		<span class="keyword">int</span> rightPtr=right-<span class="number">1</span>; <span class="comment">//枢纽左边的值</span></span><br><span class="line">	</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span>(theArray[++leftPtr]&lt;pivot)</span><br><span class="line">				;<span class="comment">//no</span></span><br><span class="line">			<span class="keyword">while</span>(theArray[--rightPtr]&gt;pivot)</span><br><span class="line">				;<span class="comment">//no</span></span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(leftPtr&gt;=rightPtr)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				swap(leftPtr,rightPtr);</span><br><span class="line">		&#125;<span class="comment">//end while</span></span><br><span class="line">		swap(leftPtr,right-<span class="number">1</span>);  <span class="comment">//重新存储枢纽的值</span></span><br><span class="line">		<span class="keyword">return</span> leftPtr;</span><br><span class="line">	&#125;<span class="comment">//end partitionIt()</span></span><br><span class="line">	<span class="comment">//------------------------------------------</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">manualSort</span><span class="params">(inr left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> size=right-left+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(size&lt;=<span class="number">1</span>)  <span class="comment">//不用排序</span></span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">if</span>(size==<span class="number">2</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(theArray[left]&gt;theArray[right])</span><br><span class="line">					swap(left,right);	</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;<span class="keyword">else</span>   <span class="comment">//size==3</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(theArray[left]&gt;theArray[right-<span class="number">1</span>])</span><br><span class="line">					swap(left,right-<span class="number">1</span>);</span><br><span class="line">				<span class="keyword">if</span>(theArray[left]&gt;theArray[right])</span><br><span class="line">					swap(left,right);</span><br><span class="line">				<span class="keyword">if</span>(theArray[right-<span class="number">1</span>]&gt;theArray[right])</span><br><span class="line">					swap(right-<span class="number">1</span>,right);</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;<span class="comment">//end manualSort()</span></span><br><span class="line">&#125;<span class="comment">//end class</span></span><br></pre></td></tr></table></figure></div>
<p><font size="4">接着我们在main函数中执行</font></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QuickSortApp</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> maxSize=<span class="number">16</span>;</span><br><span class="line">		ArrayIns arr;</span><br><span class="line">		arr=<span class="keyword">new</span> ArrayIns(maxSize);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;maxSize;j++)</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">long</span> n=(<span class="keyword">int</span>)(Math.random()*<span class="number">99</span>);</span><br><span class="line">		arr.insert(n);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		arr.display();</span><br><span class="line">		arr.quickSort();</span><br><span class="line">		arr.display</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>##<strong>用插入排序取代三数取中法</strong><br><font size="4">如果使用三数取中法，则必须遵循快速排序中数据不能执行少于等于三个数据的规则，但这显然不是最好的划分方法。</font></p>
<p><font size="4">好在我们还有插入排序：</font></p>
<p><font size="4">处理小划分的另一个选择是使用插入排序，不用再去限制3，可以把界限定位10,20，或者任意数字。实验不同的枢纽点来提高执行效率。在这种算法下，最好的枢纽值取决于计算机，操作系统，编译器等，Knuth建议这种情况下的枢纽使用9。</font></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayIns</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">long</span>[] theArray;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> nElems;</span><br><span class="line">	<span class="comment">//-------------------------------</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ArrayIns</span><span class="params">(<span class="keyword">int</span> max)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">	theArray=<span class="keyword">new</span> ArrayIns(max);</span><br><span class="line">	nElems=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//--------------------------------</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">long</span> value)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">	theArray[nElesm]=value;</span><br><span class="line">	nElems++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//--------------------------------</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		System.out.print(<span class="string">&quot;A=&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;nElems;j++)</span><br><span class="line">		&#123; </span><br><span class="line">			System.out.print(theArray[j]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">			System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//---------------------------------</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">()</span> <span class="comment">//被main函数调用</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		recQuickSort(<span class="number">0</span>,nElems-<span class="number">1</span>);</span><br><span class="line">		<span class="comment">//insertion(0,nElems-1);</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//---------------------------------</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recQuickSort</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> size=right-left+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(size&lt;=<span class="number">10</span>)</span><br><span class="line">			insertionSort(left,right);</span><br><span class="line">		<span class="keyword">else</span>   <span class="comment">//数据项个数多，进行快速排序</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">long</span> median=mediaOf3(left,right);    <span class="comment">//三数取中</span></span><br><span class="line">			<span class="keyword">int</span> partition=partitionIt(left,right,median);</span><br><span class="line">			recQuickSort(left,partition-<span class="number">1</span>);   <span class="comment">//划分</span></span><br><span class="line">			recQuickSort(partion+<span class="number">1</span>,right);   <span class="comment">///划分</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="comment">//end recQuicSort()</span></span><br><span class="line">	<span class="comment">//---------------------------------------</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">medianOf3</span><span class="params">(<span class="keyword">int</span> left，<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> center=（left+right）/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(theArray[left]&gt;theArray[center])</span><br><span class="line">			swap(left,center);</span><br><span class="line">		<span class="keyword">if</span>(theArray[left]&gt;theArray[right])</span><br><span class="line">			swap(left,right);</span><br><span class="line">		<span class="keyword">if</span>(theArray[center]&gt;theArray[right])</span><br><span class="line">			swap(center,right);</span><br><span class="line">		</span><br><span class="line">		swap(center,right-<span class="number">1</span>);   <span class="comment">//把枢纽值放在右边</span></span><br><span class="line">		<span class="keyword">return</span> theArray(right-<span class="number">1</span>);   <span class="comment">//返回中值</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//----------------------------------------</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> dex1,<span class="keyword">int</span> dex2)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">long</span> temp;</span><br><span class="line">		temp=theArray[dex1];</span><br><span class="line">		theArray[dex1]=theArray[dex2];</span><br><span class="line">		theArray[dex2]=temp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//-----------------------------------------</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partitionIt</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">long</span> pivot)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> leftPtr=left;</span><br><span class="line">		<span class="keyword">int</span> rightPtr=right-<span class="number">1</span>; <span class="comment">//枢纽左边的值</span></span><br><span class="line">	</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span>(theArray[++leftPtr]&lt;pivot)</span><br><span class="line">				;<span class="comment">//no</span></span><br><span class="line">			<span class="keyword">while</span>(theArray[--rightPtr]&gt;pivot)</span><br><span class="line">				;<span class="comment">//no</span></span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(leftPtr&gt;=rightPtr)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				swap(leftPtr,rightPtr);</span><br><span class="line">		&#125;<span class="comment">//end while</span></span><br><span class="line">		swap(leftPtr,right-<span class="number">1</span>);  <span class="comment">//重新存储枢纽的值</span></span><br><span class="line">		<span class="keyword">return</span> leftPtr;</span><br><span class="line">	&#125;<span class="comment">//end partitionIt()</span></span><br><span class="line">	<span class="comment">//------------------------------------------</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(）&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">int</span> in,out;</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">for</span>(out=left+<span class="number">1</span>;out&lt;nElems;out++)</span></span>&#123; <span class="comment">//外循环是分界线</span></span><br><span class="line">			<span class="keyword">long</span> temp=theArray[out];   <span class="comment">//删除被标记的数据</span></span><br><span class="line">			in = out ;   <span class="comment">//srat shifts at  out</span></span><br><span class="line">			<span class="keyword">while</span>(in&gt;<span class="number">0</span>&amp;&amp;theArray[in-<span class="number">1</span>]&gt;=temp)</span><br><span class="line">			&#123;  <span class="comment">//until one is smaller</span></span><br><span class="line">			theArray[in] = a[in-<span class="number">1</span>];  <span class="comment">//shift item right，</span></span><br><span class="line">			--in;   <span class="comment">//go left one position</span></span><br><span class="line">			&#125;</span><br><span class="line">			theArray[in] =temp;   <span class="comment">//insert marked item</span></span><br><span class="line">		&#125;<span class="comment">// end for</span></span><br><span class="line">	&#125;<span class="comment">//end insertionSort()</span></span><br><span class="line">	</span><br><span class="line">&#125;<span class="comment">//end class</span></span><br></pre></td></tr></table></figure></div>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quick2SortApp</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> maxSize=<span class="number">16</span>;</span><br><span class="line">		ArrayIns arr;</span><br><span class="line">		arr=<span class="keyword">new</span> ArrayIns(maxSize);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;maxSize;j++)</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">long</span> n=(<span class="keyword">int</span>)(Math.random()*<span class="number">99</span>);</span><br><span class="line">		arr.insert(n);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		arr.display();</span><br><span class="line">		arr.quickSort();</span><br><span class="line">		arr.display</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><font size="4">这个特别的算法中，对小的子数组使用插入排序被证实为最快的方法，但不绝对比三数取中的枢纽法 快，总的来说没有明显的节省时间。</font></p>
<p><font size="4">很多专家还提倡使用：<br><font size="4">对数组整个使用快速排序，不考虑界限划分的排序。当快速排序结束时，数组基本有序，然后对整个数组进行插入排序，插入排序对基本有序的数组 执行效率高。</font></font></p>
<blockquote>
<p>代码有待勘察，改日补上</p>
</blockquote>
<h2 id="快速排序的效率"><a href="#快速排序的效率" class="headerlink" title="快速排序的效率"></a><strong>快速排序的效率</strong><a href="#快速排序的效率" class="header-anchor">#</a></h2><p>快速排序的时间复杂度为O（N*logN）</p>
<p>#<strong>参考并感谢</strong></p>
<ol>
<li><p>翻译 <a href="http://download.csdn.net/detail/chivalrousman/9541437"> java数据结构和算法（英文版）</a></p>
</li>
<li><p>参考  <a href="http://download.csdn.net/detail/chivalrousman/9541438">java数据结构和算法(  中文版  )</a></p>
</li>
<li><p><a href="http://blog.csdn.net/speedme/article/details/21654357">了解递归</a></p>
</li>
</ol>
<link rel="stylesheet" href="/css/bilicard.css" type="text/css"></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font>]]></content>
      <categories>
        <category>计算机科学</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>《详解 Android 通信》</title>
    <url>/blog//2016/06/android-communication/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>摘自本人16年的的博客<a href="https://blog.csdn.net/chivalrousman/article/details/51623122">《详解 Android 通信》</a></p>
<h1 id="什么是通信"><a href="#什么是通信？" class="headerlink" title="什么是通信？"></a>什么是通信？<a href="#什么是通信" class="header-anchor">#</a></h1><p><font size="4"> 通信 ，顾名思义，指的就是信息的传递或者交换</font></p>
<h1 id="看完本文能收获什么"><a href="#看完本文能收获什么？" class="headerlink" title="看完本文能收获什么？"></a>看完本文能收获什么？<a href="#看完本文能收获什么" class="header-anchor">#</a></h1><p><font size="3">按目录索引，你可以学习到<br>    1. 组件间的通信，Activity，fragment，Service， Provider，Receiver<br>    2. 进程间的通信，AIDL<br>    3. 线程间的通信，Handler，AnsycTask，IntentService<br>    4. 多个App间的通信<br>    5. 使用大型开源框架完成组件通信，EventBus，otto<br>    6. 网络通信基础篇：Google 课程–AnsycTask+HttpClient<br>    7. 网络通信提高篇：开源框架Ansyc-Httpclient，okttp，Retrofit</font></p>
<h1 id="建议阅读本文时遵循以下学习思路"><a href="#建议阅读本文时遵循以下学习思路" class="headerlink" title="建议阅读本文时遵循以下学习思路"></a>建议阅读本文时遵循以下学习思路<a href="#建议阅读本文时遵循以下学习思路" class="header-anchor">#</a></h1><p><font size="3">1. <strong>研究对象</strong>：Activity，fragment等组件</font></p>
<p><font size="3">2. <strong>信息存在形式</strong>：Intent，Bundle，静态变量，全局变量，还是点击事件，触摸事件的回调监听，或者文件形式（Sharepreference，SQLite，File , NetStream） ，本质就是<font color="red">信息源<br><font size="3" color="black"><br><font size="3">3. <strong>信息传递的形式</strong>：网路，回调监听，线程，Intent，全局Application  </font></font></font></font></p>
<p><font size="3">4. <strong>相同形式的思路</strong>，不会出现第二次，请读者举一反三</font></p>
<p><font size="3">5. <strong>最后强调研究对象是单一的</strong> </font></p>
<h1 id="activity通信"><a href="#Activity通信" class="headerlink" title="Activity通信"></a>Activity通信<a href="#activity通信" class="header-anchor">#</a></h1><p><strong><font size="6">Activity 和 Activity</font></strong></p>
<p><font size="4"><strong>1.  常规方式：Intent Bundle</strong></font></p>
<p><font size="4">通过Intent 启动另一个Activity时，有两种重载方式：</font></p>
<ul>
<li> startActivity(new Intent(),new Bundle());</li>
<li> startActivityForResult(new Intent(),FLAG,new Bundle());</li>
</ul>
<p><font size="4">从参数列表就可以总结出来，有Intent，和Bundle,可以传递8种基本数据类型和可序列化的数据类型，比如字符串和字节数组。提到可序列化，就引发 Intent和Bundle 的局限性了:</font></p>
<ul>
<li> Intent Bundle 无法传递“不可序列化”的数据，比如Bitmap，InputStream，解决办法有很多种，最简单的就是将“不可序列化”的对象，转换成字节数组，这里因为主要是讲解通信，所以不展开讲了。</li>
<li> Intent Bundle 能传递的数据大小在40K以内 。 </li>
</ul>
<p><font size="4">PS : 很多人不理解为什么把Intent和Bundle放在一起谈，因为Intent 底层存储信息的原理也是通过Bundle存储！</font></p>
<p><font size="4"><strong>2. 公有静态变量</strong> </font></p>
<p><font size="3"> 比如 public static String flag=“中国”；</font></p>
<p><font size="3">使用方式 比如 在其他Activity当中  FirstActivity.flag=“china”; 修改 静态变量的值  </font></p>
<p><font size="4"><strong>3. 基于物理形式：</strong></font></p>
<p><font size="3">比如 File，SQLite，Sharepreference 物理形式</font></p>
<p><font size="4"><strong>4. 全局变量：</strong></font></p>
<p><font size="3">比如Application：Application是与Activity，Service齐名的组件，非常强大，它的特点是全局组件共用，单例形式存在，在其他组件中，我们只需要Context.getApplication（）获得该对象的引用即可</font></p>
<p><strong><font size="6">Activity 和Fragment，Service，BrodcastReceiver</font></strong></p>
<p>,<font size="4">首先都遵循，如何启动它们，就如何传递信息的原则： </font></p>
<p><font size="5"><strong>1. Activity与Fragment</strong> </font></p>
<p><font size="4">1. 通过构造函数传递 2.获取Fragment的实例对象</font></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;CustFragment 是自定义的fragment，参数列表也可以自己定义咯，</span><br><span class="line"> getSupportFragmentManager().beginTransaction()</span><br><span class="line">			 .add(new CustFragment(自定义的的参数列表),new String(&quot;参数&quot;))</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;------------------method two-----------------------</span><br><span class="line">  getSupportFragmentManager().findFragmentById(R.id.headlines_fragment);</span><br><span class="line">  &#x2F;&#x2F;------------------method three----------------------</span><br><span class="line">   getSupportFragmentManager().findFragmentByTag(&quot;HeadLines&quot;);</span><br></pre></td></tr></table></figure></div>
<blockquote>
<p>聪明的读者可能会问Fragment如何与Activity通信类似的问题，这是个好问题，请注意我们的研究的原则是单一目标原则，在这节我研究的是Activity，你的疑惑在后面都会一一解答</p>
</blockquote>
<p><font size="5"><strong>2. Activity与Service</strong> </font></p>
<p><font size="4">Activity启动Service的两种方式：</font></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F;CustomService 是自定义Service，完成一些后台操作</span><br><span class="line"></span><br><span class="line">startService(new Intent(FirstActivity.this，CustomService.class));</span><br><span class="line"></span><br><span class="line">bindService(new Intent(FirstActivity.this，CustomService.class)), new ServiceConnection() &#123;</span><br><span class="line">          @Override</span><br><span class="line">          public void onServiceConnected(ComponentName name, IBinder service) &#123;</span><br><span class="line">		&#x2F;&#x2F;当前启动的service 一些数据就会回调回这里，我们在Activity中操作这些数据即可</span><br><span class="line">		get</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          @Override</span><br><span class="line">          public void onServiceDisconnected(ComponentName name) &#123;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;,flags);</span><br></pre></td></tr></table></figure></div>
<p><font size="4">从启动方式就可以看出，通过Bundle对象的形式存储，通过Intent传输，来完成Activity向Service传递数据的操作</font></p>
<p><font size="5"><strong>3. Activity与BroadcastReceiver</strong></font></p>
<p><font size="4">启动广播的形式也有两种: </font></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;method one ！！！-----------------------------------------------</span><br><span class="line">registerReceiver(new BroadcastReceiver() &#123;</span><br><span class="line">          @Override</span><br><span class="line">          public void onReceive(Context context, Intent intent) &#123;</span><br><span class="line">              </span><br><span class="line">          &#125;</span><br><span class="line">      &#125;,new IntentFilter(),&quot;&quot;,new Handler());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;method two ！！！-----------------------------------------------     </span><br><span class="line">registerReceiver(new BroadcastReceiver() &#123;</span><br><span class="line">          @Override</span><br><span class="line">          public void onReceive(Context context, Intent intent) &#123;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;,new IntentFilter());</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p><font size="4">关于method one 的第三个参数Handler很多人会很费解</font></p>
<p><font size="4">参照registerReceiver中源码关于该Handler参数的解释：</font></p>
<p><font size="4">Handler identifying the thread that will receive the Intent.  If null, the main thread of the process will be used.</font></p>
<blockquote>
<p><font size="4">定义了一个用于接收Intent的子线程，如果不填或者默认为null，那么就会在主线程中完成接收Intent的操作  </font></p>
</blockquote>
</blockquote>
<p><font size="5">很明显，Activity与BroadcastReceiver通信时，用的也是Intent传递，Bundle存储</font></p>
<p><font size="5"><strong>4. 通讯时的同步问题</strong></font></p>
<blockquote>
<p><font size="4">这里的同步通讯问题，为下文Fragment通讯作铺垫，不是这个问题不重要，不值得引起你注意，只是我想把问题放在它最应该出现的位置。</font></p>
</blockquote>
<p><font size="4">以上只是基础的传递数据的形式，大部分都是静态的，现在有一种需求，用户操作Activity，发出了某些指令，比如按下，滑动，触摸等操作，如何完成这些信息传递呢？这就要求同步了。</font></p>
<p><font size="4">同步传递消息也很简单，就是调用系统写好的回调接口</font></p>
<p><font size="4">首先我们要知道，用户 点击，触摸 这些行为 也属于 通信的范畴—点击和触摸属于 信息源；<br><font size="4">比如用户行为进行点击，那就实现 ：</font></font></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">new Button(mCotext).setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">       @Override</span><br><span class="line">       public void onClick(View v) &#123;</span><br><span class="line">           new ImageView(mCotext).invalidate();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure></div>
<p><font size="4">通过此招提示指定的ImageView：嘿！老兄，你该刷新了</font></p>
<p><font size="4">又或者 当用户 进行触摸操作，我们需要实现放大缩小平移指定的区域：</font></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">new RelativeLayout(mCotext).setOnTouchListener(new View.OnTouchListener() &#123;</span><br><span class="line">          @Override</span><br><span class="line">          public boolean onTouch(View v, MotionEvent event) &#123;</span><br><span class="line">              &#x2F;&#x2F;缩放</span><br><span class="line">              v.setScaleX(1f);</span><br><span class="line">              v.setScaleY(1f);</span><br><span class="line">              &#x2F;&#x2F;平移</span><br><span class="line">              v.setTranslationX(1f);</span><br><span class="line">              v.setTranslationY(1f); </span><br><span class="line">              v.setTranslationY(1f);</span><br><span class="line">              &#x2F;&#x2F;旋转</span><br><span class="line">              v.setRotation(2f);</span><br><span class="line">              v.setRotationX(2f);</span><br><span class="line">              v.setRotationY(2f);</span><br><span class="line"></span><br><span class="line">              v.invalidate();</span><br><span class="line">              return true;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure></div>
<p><font size="4">嘿，你看，当用户进行触摸操作，我们可以通过回调onTouchListenter来完成“触摸”这一操作</font></p>
<blockquote>
<p><font size="4">关于View重绘机制以及优化刷新UI的细节，不属于本文讨论范围。</font></p>
</blockquote>
<h1 id="fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment<a href="#fragment" class="header-anchor">#</a></h1><p><font size="5"><strong>1. Fragment 与Activity通信</strong></font></p>
<p><font size="4">通过实例对象传递</font></p>
<p><font size="4">同样的，在Fragment中         getActivity()可以获取到它相关联的 Activity实例，就可以轻松获取并且修改Activity的数据</font></p>
<p><font size="5"><strong>2. Fragment 与 多个Fragment通信</strong></font></p>
<p><font size="4">首先，两个Fragment之间不可能直接通信（非正规因素除外），Google官方提出的解决办法是 通过相关联的Activity来完成两个Fragment的通信</font></p>
<p><font size="4">只需要记住三步：</font></p>
<p><font size="4"><strong>1. <font size="4">定义一个接口：</font></strong></font></p>
<p> 在让Fragment关联Activity之前，可以在Fragment中定义一个接口，然后让宿主Activity来实现这个接口。接着，在Fragment中捕获这个接口，并且在onAttach()中 捕获Activity实例 </p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;只需关注接口是如何定义的，以及onAttack中的实现</span><br><span class="line">public class HeadlinesFragment extends ListFragment &#123;</span><br><span class="line">	&#x2F;&#x2F;定义的接口引用</span><br><span class="line">    OnHeadlineSelectedListener mCallback;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 自定义回调接口，宿主Activity必须要实现它</span><br><span class="line">    public interface OnHeadlineSelectedListener &#123;</span><br><span class="line">        public void onArticleSelected(int position);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onAttach(Activity activity) &#123;</span><br><span class="line">        super.onAttach(activity);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 在这里只是为了确保Activity实现了我们定义的接口，如果没有实现，则抛出异常</span><br><span class="line">        try &#123;</span><br><span class="line">            mCallback &#x3D; (OnHeadlineSelectedListener) activity;</span><br><span class="line">        &#125; catch (ClassCastException e) &#123;</span><br><span class="line">            throw new ClassCastException(activity.toString()</span><br><span class="line">                    + &quot; must implement OnHeadlineSelectedListener&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><font size="4">一旦Activity通过OnHeadlineSelectedListener 的实例mCallBack回调 onArticleSelected（），Fragment就可以传递信息 给Activity了</font></p>
<p><font size="4">例如 下面是 ListFragment的一个回调方法，当用户点击了list 中的item，这个Fragment就会通过回调接口向宿主Activity传递事件</font></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">   public void onListItemClick(ListView l, View v, int position, long id) &#123;</span><br><span class="line">       &#x2F;&#x2F; 向Activity传递事件信息</span><br><span class="line">       mCallback.onArticleSelected(position);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>
<p><font size="4"><strong>2. 在宿主Activity实现这个接口</strong></font></p>
<p><font size="4">怎么实现？很简单，参考下面代码：</font></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">public static class MainActivity extends Activity</span><br><span class="line">        implements HeadlinesFragment.OnHeadlineSelectedListener&#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    public void onArticleSelected(int position) &#123;</span><br><span class="line">        &#x2F;&#x2F; 用户从从 HeadlinesFragment选中了一个标题</span><br><span class="line">        &#x2F;&#x2F;响应用户的操作，做一些业务逻辑</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><font size="4"><strong>3. 向其他Fragment传递信息 （完成通信）</strong></font></p>
<p><font size="4">宿主Activity可以通过findFragmentById()向指定的Fragment传递信息，宿主Activity可以直接获取Fragment实例，回调Fragment的公有方法</font></p>
<p><font size="4">例如：</font></p>
<p><font size="4">宿主Activity 包含了一个Listfragment用来展示条目信息，当每个条目被点击的时候，我们希望ListFragment向另外一个DetailsFragment传递一个信息用来 展示不同的细节</font></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line"> public static class MainActivity extends Activity</span><br><span class="line">        implements HeadlinesFragment.OnHeadlineSelectedListener&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">     public void onArticleSelected(int position) &#123;</span><br><span class="line">        &#x2F;&#x2F; 用户在 HeadlinesFragment中选中了一个item </span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;在activity中添加新的fragment</span><br><span class="line">        ArticleFragment articleFrag &#x3D; (ArticleFragment)</span><br><span class="line">                getSupportFragmentManager().findFragmentById(R.id.article_fragment);</span><br><span class="line"></span><br><span class="line">        if (articleFrag !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; If article 对象 可以复用, 我们就不需要创建两遍了</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 回调articleFrag 更新</span><br><span class="line">            articleFrag.updateArticleView(position);</span><br><span class="line"></span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; 创建 Fragment 并为其添加一个参数，用来指定应显示的文章</span><br><span class="line">            ArticleFragment newFragment &#x3D; new ArticleFragment();</span><br><span class="line">            Bundle args &#x3D; new Bundle();</span><br><span class="line">            args.putInt(ArticleFragment.ARG_POSITION, position);</span><br><span class="line">            newFragment.setArguments(args);</span><br><span class="line"></span><br><span class="line">            FragmentTransaction transaction &#x3D; getSupportFragmentManager().beginTransaction();</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 将 fragment_container View 时中的内容替换为此 Fragment ，</span><br><span class="line">            &#x2F;&#x2F; 然后将该事务添加到返回堆栈，以便用户可以向后回滚</span><br><span class="line">            transaction.replace(R.id.fragment_container, newFragment);</span><br><span class="line">            int setTransition&#x3D;TRANSIT_FRAGMENT_OPEN;</span><br><span class="line">            transaction.setTransition(setTransition);</span><br><span class="line">            transaction.addToBackStack(null);</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F; 执行事务</span><br><span class="line">            transaction.commit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><font size="4">下面我写了一个实例来供大家理解：</font></p>
<p><font size="4">各个类的联系图：</font></p>
<img src="http://cdn.yangchaofan.cn/通信fragment.jpg">





<p><font size="4">效果如下：</font></p>
<img src="http://cdn.yangchaofan.cn/Fragment通信gif.gif">

<p><font size="4"><a href="http://download.csdn.net/detail/chivalrousman/9545616">Fragment通信demo实例</a></font></p>
<h1 id="service"><a href="#Service" class="headerlink" title="Service"></a>Service<a href="#service" class="header-anchor">#</a></h1><p><strong><font size="5"> Service 与Activity通信</font></strong> </p>
<p><font size="4">主要是如何获得Service实例的问题<br><font size="4">总结来说两步： </font></font></p>
<ol>
<li> 在Service定义内部类，继承Binder，封装Service作为内部类的属性，并且在onBind方法中返回内部类的实例对象</li>
<li> 在Activity中实现ServiceConnection ，获取到Binder对象，再通过Binder获取Service<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">public class LocalService extends Service &#123;</span><br><span class="line">    &#x2F;&#x2F; 传递给客户端的Binder</span><br><span class="line">    private final IBinder mBinder &#x3D; new LocalBinder();</span><br><span class="line">    &#x2F;&#x2F;构造Random对象</span><br><span class="line">    private final Random mGenerator &#x3D; new Random();</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 这个类提供给客户端  ，因为Service总是运行在同一个进程中的</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public class LocalBinder extends Binder &#123;</span><br><span class="line">        LocalService getService() &#123;</span><br><span class="line">            &#x2F;&#x2F; 当客户端回调的时候，返回LoacalService实例</span><br><span class="line">            return LocalService.this;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public IBinder onBind(Intent intent) &#123;</span><br><span class="line">        return mBinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**交给客户端回调的方法 *&#x2F;</span><br><span class="line">    public int getRandomNumber() &#123;</span><br><span class="line">      return mGenerator.nextInt(100);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">public class BindingActivity extends Activity &#123;</span><br><span class="line">    LocalService mService;</span><br><span class="line">    boolean mBound &#x3D; false;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.main);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onStart() &#123;</span><br><span class="line">        super.onStart();</span><br><span class="line">        &#x2F;&#x2F; 绑定 LocalService</span><br><span class="line">        Intent intent &#x3D; new Intent(this, LocalService.class);</span><br><span class="line">        bindService(intent, mConnection, Context.BIND_AUTO_CREATE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onStop() &#123;</span><br><span class="line">        super.onStop();</span><br><span class="line">        &#x2F;&#x2F; 解绑 service</span><br><span class="line">        if (mBound) &#123;</span><br><span class="line">            unbindService(mConnection);</span><br><span class="line">            mBound &#x3D; false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**button已经通过 android:onClick (attribute) 设置此方法响应用户click*&#x2F;</span><br><span class="line">    public void onButtonClick(View v) &#123;</span><br><span class="line">        if (mBound) &#123;</span><br><span class="line">            &#x2F;&#x2F; 回调 LocalService的方法.</span><br><span class="line">            &#x2F;&#x2F;因为在主线程中刷新UI，可能会造成线程阻塞，这里只是为了测试</span><br><span class="line">            int num &#x3D; mService.getRandomNumber();</span><br><span class="line">            Toast.makeText(this, &quot;number: &quot; + num, Toast.LENGTH_SHORT).show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**定义通过bindService 回调的Binder *&#x2F;</span><br><span class="line">    private ServiceConnection mConnection &#x3D; new ServiceConnection() &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onServiceConnected(ComponentName className,</span><br><span class="line">                IBinder service) &#123;</span><br><span class="line">           &#x2F;&#x2F;先通过Binder获得Service的内部类 LoacalBinder</span><br><span class="line">            LocalBinder binder &#x3D; (LocalBinder) service;</span><br><span class="line">             &#x2F;&#x2F; 现在可以获得service对象了</span><br><span class="line">            mService &#x3D; binder.getService();</span><br><span class="line">            mBound &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onServiceDisconnected(ComponentName arg0) &#123;</span><br><span class="line">            mBound &#x3D; false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<font size="4">除了这种回调的方式外</font></li>
</ol>
<p><font size="4">还有一种方式 是在Service中 发送广播，</font></p>
<p><font size="4">比如 在Service中 开启了一个子线程执行任务，就在子线程的run（）方法中去sendBroadcast(intent);<br><font color="red">数据用Intent封装，传递形式用广播<br><font color="black"></font></font></font></p>
<h1 id="aidl完成进程间通信"><a href="#AIDL完成进程间通信" class="headerlink" title="AIDL完成进程间通信"></a>AIDL完成进程间通信<a href="#aidl完成进程间通信" class="header-anchor">#</a></h1><font size="4">
关于进程和线程的细节改天详细说明，我们首先了解一下进程和线程的概念：

<blockquote>
<p>当某个应用组件启动且该应用没有运行其他任何组件时，Android 系统会使用单个执行线程为应用启动新的 Linux<br>进程。默认情况下，同一应用的所有组件在相同的进程和线程（称为“主”线程）中运行。<br>如果某个应用组件启动且该应用已存在进程（因为存在该应用的其他组件），则该组件会在此进程内启动并使用相同的执行线程。<br>但是，我们也可以安排应用中的其他组件在单独的进程中运行，并为任何进程创建额外的线程。</p>
<p>各类组件元素的清单文件条目—：activity，servicer，eceiver 和 provider均支持 android:process 属性，此属性可以指定该组件应在哪个进程运行。我们可以设置此属性，使每个组件均在各自的进程中运行，或者使一些组件共享一个进程，而其他组件则不共享。 此外，我们还可以设置 android:process，使不同应用的组件在相同的进程中运行</p>
</blockquote>
<p><font size="4">以及了解一下 进程间通信的概念 </font></p>
<blockquote>
<p>Android 利用远程过程调用 (RPC) 提供了一种进程间通信 (IPC) 机制，通过这种机制，由 Activity<br>或其他应用组件调用的方法将（在其他进程中）远程执行，而所有结果将返回给调用方。这就要求把方法调用及其数据分解至操作系统可以识别的程度，并将其从本地进程和地址空间传输至远程进程和地址空间，然后在远程进程中重新组装并执行该调用。<br>然后，返回值将沿相反方向传输回来。 Android 提供了执行这些 IPC 事务所需的全部代码，因此我们只需集中精力定义和实现 RPC<br>编程接口即可。</p>
<p>要执行 IPC，必须使用 bindService() 将应用绑定到服务上。</p>
</blockquote>
<p><font size="4">具体实现 可以 <a href="http://blog.csdn.net/u013478336/article/details/43818185">参考这个实例</a>  和文末给出的官方文档</font></p>
<h1 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信<a href="#线程间通信" class="header-anchor">#</a></h1><p><font size="4">Handler 和AsyncTask都是用来完成子线程和主线程即UI线程通信的</font></p>
<p><font size="4">都可以解决主线程 处理耗时操作，造成界面卡顿或者程序无响应ANR异常 这一类问题</font></p>
<p><font size="4">Handler  是 一种机制【Handler+Message+Looper】，所有的数据通过Message携带，，所有的执行顺序按照队列的形式执行，Looper用来轮询判断消息队列，Handler用来接收和发送Message</font></p>
<p><font size="4"> AsyncTask 是一个单独的类，设计之初的目的只是为了 异步方式完成耗时操作的，顺便可以通知主线程刷新Ui，AsyncTask的内部机制则是维护了一个线程池，提升性能。</font></p>
<p><font size="4"> 在这里提供另一种优雅的做法完成线程间的通信： </font></p>
<p><font size="4"> <strong>扩展 IntentService 类</strong> </font></p>
<p><font size="4"> 由于大多数启动服务都不必同时处理多个请求（实际上，这种多线程情况可能很危险），因此使用 IntentService 类实现服务值得一试。<br><font size="4">但如需同时处理多个启动请求，则更适合使用该基类Service。</font></font></p>
<p><font size="4"> IntentService 执行以下操作：</font></p>
<ul>
<li> <font size="4"> 创建默认的工作线程，用于在应用的主线程外执行传递给 onStartCommand() 的所有 Intent。</font></li>
<li> <font size="4">创建工作队列，用于将一个 Intent 逐一传递给 onHandleIntent() 实现，这样我们就永远不必担心多线程问题。</font></li>
<li> <font size="4">在处理完所有启动请求后停止服务，因此我们不必调用 stopSelf()。</font></li>
<li> <font size="4">提供 onBind() 的默认实现（返回 null）。</font></li>
<li><font size="4">提供 onStartCommand() 的默认实现，可将 Intent 依次发送到工作队列和 onHandleIntent() 实现。<br>综上所述，您只需实现 onHandleIntent() 来完成客户端提供的工作即可。（不过，我们还需要为服务提供小型构造函数。）</font></li>
</ul>
<p><font size="4"> 以下是 IntentService 的实现示例：</font></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">public class HelloIntentService extends IntentService &#123;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * 必须有构造函数 必须调用父 IntentService(String)带有name的构造函数来执行工作线程</span><br><span class="line">   *&#x2F;</span><br><span class="line">  public HelloIntentService() &#123;</span><br><span class="line">      super(&quot;HelloIntentService&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * IntentService 调用默认的工作线程启动服务</span><br><span class="line">   * 当此方法结束，, IntentService 服务结束</span><br><span class="line">   *&#x2F;</span><br><span class="line">  @Override</span><br><span class="line">  protected void onHandleIntent(Intent intent) &#123;</span><br><span class="line">      &#x2F;&#x2F; 通常在这里会执行一些操作，比如下载文件</span><br><span class="line">      &#x2F;&#x2F;在这里只是sleep 5 s</span><br><span class="line">      long endTime &#x3D; System.currentTimeMillis() + 5*1000;</span><br><span class="line">      while (System.currentTimeMillis() &lt; endTime) &#123;</span><br><span class="line">          synchronized (this) &#123;</span><br><span class="line">              try &#123;</span><br><span class="line">                  wait(endTime - System.currentTimeMillis());</span><br><span class="line">              &#125; catch (Exception e) &#123;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><font size="4">看吧，我们只需要一个构造函数和一个 onHandleIntent() 实现即可。</font></p>
<p><font size="4">对于Service 当然也有基础一点的做法，来完成多线程的操作，只不过代码量更多了：</font></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">public class HelloService extends Service &#123;</span><br><span class="line">  private Looper mServiceLooper;</span><br><span class="line">  private ServiceHandler mServiceHandler;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Handler 接收来自主线程的Message</span><br><span class="line">  private final class ServiceHandler extends Handler &#123;</span><br><span class="line">      public ServiceHandler(Looper looper) &#123;</span><br><span class="line">          super(looper);</span><br><span class="line">      &#125;</span><br><span class="line">      @Override</span><br><span class="line">      public void handleMessage(Message msg) &#123;</span><br><span class="line">         &#x2F;&#x2F;执行任务，比如下载什么的，这里只是 让线程sleep </span><br><span class="line">          long endTime &#x3D; System.currentTimeMillis() + 5*1000;</span><br><span class="line">          while (System.currentTimeMillis() &lt; endTime) &#123;</span><br><span class="line">              synchronized (this) &#123;</span><br><span class="line">                  try &#123;</span><br><span class="line">                      wait(endTime - System.currentTimeMillis());</span><br><span class="line">                  &#125; catch (Exception e) &#123;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          &#x2F;&#x2F; 手动停止服务，来处理下一个线程</span><br><span class="line">          stopSelf(msg.arg1);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void onCreate() &#123;</span><br><span class="line">    &#x2F;&#x2F;启动线程.  注意我们在主线程中创建了一些子线程, 这些线程都没有加锁同步. 这些现场都是后台线程，所以不会阻塞UI线程</span><br><span class="line">    HandlerThread thread &#x3D; new HandlerThread(&quot;ServiceStartArguments&quot;,</span><br><span class="line">            Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line">    thread.start();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Handler开始轮询遍历了</span><br><span class="line">    mServiceLooper &#x3D; thread.getLooper();</span><br><span class="line">    mServiceHandler &#x3D; new ServiceHandler(mServiceLooper);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public int onStartCommand(Intent intent, int flags, int startId) &#123;</span><br><span class="line">      Toast.makeText(this, &quot;service starting&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 每一次请求，都会通过handler发送Message</span><br><span class="line">      &#x2F;&#x2F; startID只是为了让我们知道正在进行的是哪一个线程，以便于我们停止服务</span><br><span class="line">      Message msg &#x3D; mServiceHandler.obtainMessage();</span><br><span class="line">      msg.arg1 &#x3D; startId;</span><br><span class="line">      mServiceHandler.sendMessage(msg);</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; If we get killed, after returning from here, restart</span><br><span class="line">      return START_STICKY;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public IBinder onBind(Intent intent) &#123;</span><br><span class="line">      &#x2F;&#x2F; 不提供 binding, 所以返回空</span><br><span class="line">      return null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void onDestroy() &#123;</span><br><span class="line">    Toast.makeText(this, &quot;service done&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h1 id="多个app间的通信"><a href="#多个App间的通信" class="headerlink" title="多个App间的通信"></a>多个App间的通信<a href="#多个app间的通信" class="header-anchor">#</a></h1><p><font size="4">首先我们要知道以下两点：</font></p>
<ol>
<li><p>Android 应用一般具有若干个Activity。每个Activity显示一个用户界面，用户可通过该界面执行特定任务（比如，查看地图或拍照）。要将用户从一个Activity转至另一Activity，应用必须使用 Intent 定义做某事的“意向”。 当我们使用诸如 startActivity() 的方法将 Intent 传递至系统时，系统会使用 Intent 识别和启动相应的应用组件。使用意向甚至可以让我们的应用开始另一个应用中包含的Activity。</p>
</li>
<li><p>Intent 可以为 显式 以便启动特定组件（特定的 Activity 实例）或隐式 以便启动处理意向操作（比如“拍摄照片”）的任何组件。</p>
</li>
</ol>
<p><font size="4"><strong>1.向另一个应用发送用户</strong><br>Android最重要的功能之一，是可以操作其他应用，比如在我们的应用中，需要使用地图显示公司地址，我们无序在地图应用程序中构建Activity，而是直接创建Intent查看 地址的请求，Android系统之后启动  可以在地图上显示 地址的应用。</font></p>
<p><font size="4"><strong>1) 构建隐式的意图</strong> </font></p>
<p><font size="3">隐式意图不用声明要启动的组件类名称，而是声明操作，比如查看，编辑，发送，或者获取某项。</font></p>
<p><font size="3"><font size="3">如果您我们的数据是Uri，可以这样构建Intent：</font></font></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;当我们的应用通过startActivity()调用此Intent时，电话应用会发起向指定电话号码呼叫</span><br><span class="line">Uri number &#x3D; Uri.parse(&quot;tel:5551234&quot;);</span><br><span class="line">Intent callIntent &#x3D; new Intent(Intent.ACTION_DIAL, number);</span><br></pre></td></tr></table></figure></div>
<p><font size="4">这里还有一些其他Intent的操作和Uri数据对:</font></p>
<ul>
<li><font size="3">查看地图：<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 基于地址的地图位置</span><br><span class="line">Uri location &#x3D; Uri.parse(&quot;geo:0,0?q&#x3D;1600+Amphitheatre+Parkway,+Mountain+View,+California&quot;);</span><br><span class="line">&#x2F;&#x2F; 基于经纬度的地图位置</span><br><span class="line">&#x2F;&#x2F; Uri location &#x3D; Uri.parse(&quot;geo:37.422219,-122.08364?z&#x3D;14&quot;); &#x2F;&#x2F; z param is zoom level</span><br><span class="line">Intent mapIntent &#x3D; new Intent(Intent.ACTION_VIEW, location);</span><br></pre></td></tr></table></figure></div></font></li>
<li><font size="3">查看网页：</font></li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">Uri webpage &#x3D; Uri.parse(&quot;http:&#x2F;&#x2F;www.android.com&quot;);</span><br><span class="line">Intent webIntent &#x3D; new Intent(Intent.ACTION_VIEW, webpage);</span><br></pre></td></tr></table></figure></div>
<p>有的同学会问了，我从哪里可以知道，Intent可以传递的 Uri的类型，或者其他数据类型呢？<br>答：可以查阅<a href="https://developer.android.com/reference/android/content/Intent.html#ACTION_VIEW">Google Intent的Api</a></p>
<p><font size="4"><strong>2) 确认是否存在 接收意向的应用</strong> </font></p>
<blockquote>
<p>注意：如果调用了意向，但设备上没有可用于处理意向的应用，我们的应用将崩溃。 </p>
</blockquote>
<p>要确认是否存在可响应意向的可用Activity，请调用 queryIntentActivities() 来获取能够处理ntent 的Activity列表。 如果返回的 List 不为空，则可以安全地使用该意向。例如：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">PackageManager packageManager &#x3D; getPackageManager();</span><br><span class="line">List activities &#x3D; packageManager.queryIntentActivities(intent,</span><br><span class="line">        PackageManager.MATCH_DEFAULT_ONLY);</span><br><span class="line">boolean isIntentSafe &#x3D; activities.size() &gt; 0;</span><br></pre></td></tr></table></figure></div>
<p>如果 isIntentSafe 是 true，则至少有一个应用将响应该意向。 如果它是 false，则没有任何应用处理该意向。</p>
<p><font size="4"><strong>3) 启动指定Activity</strong></font></p>
<p> 当我指定意图后，通过startActivity(intent);就可以启动指定Activity<br>此处有一个Google官方的示例：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 构建Intent</span><br><span class="line">Uri location &#x3D; Uri.parse(&quot;geo:0,0?q&#x3D;1600+Amphitheatre+Parkway,+Mountain+View,+California&quot;);</span><br><span class="line">Intent mapIntent &#x3D; new Intent(Intent.ACTION_VIEW, location);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 确定意图可以被接收</span><br><span class="line">PackageManager packageManager &#x3D; getPackageManager();</span><br><span class="line">List&lt;ResolveInfo&gt; activities &#x3D; packageManager.queryIntentActivities(mapIntent, 0);</span><br><span class="line">boolean isIntentSafe &#x3D; activities.size() &gt; 0;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;启动指定应用</span><br><span class="line">if (isIntentSafe) &#123;</span><br><span class="line">    startActivity(mapIntent);</span><br><span class="line">&#125;</span><br><span class="line">显</span><br></pre></td></tr></table></figure></div>
<p><font size="4"><strong>4) 显示应用选择器</strong></font></p>
<p>比如我们要完成”分享操作“，用户可以使用多个App完成分享，我们应明确显示 选择器对话框，如图<a href="https://developer.android.com/images/training/basics/intent-chooser.png">这里写链接内容</a></p>
<p>要显示选择器，需要使用Intent的createChooser()方法 创建Intent，并将其传递至startActivity()</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">Intent intent &#x3D; new Intent(Intent.ACTION_SEND);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">String title &#x3D; getResources().getString(R.string.chooser_title);</span><br><span class="line">&#x2F;&#x2F; Create intent to show chooser</span><br><span class="line">Intent chooser &#x3D; Intent.createChooser(intent, title);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Verify the intent will resolve to at least one activity</span><br><span class="line">if (intent.resolveActivity(getPackageManager()) !&#x3D; null) &#123;</span><br><span class="line">    startActivity(chooser);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>这将显示一个对话框，其中有响应传递给 createChooser() 方法的意向的应用列表，并且将提供的文本用作 对话框标题</p>
<p><strong><font size="4">2. 接收其他Activity返回的结果</font></strong></p>
<p><font size="3">通过Intent.startActivityForResult()来完成。</font></p>
<p> <font size="3">首先在启动另一个Activity时，我们需要指定request code以便返回结果时，我们可以正常处理它。</font></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">static final int PICK_CONTACT_REQUEST &#x3D; 1;  &#x2F;&#x2F; The request code</span><br><span class="line">...</span><br><span class="line">private void pickContact() &#123;</span><br><span class="line">    Intent pickContactIntent &#x3D; new Intent(Intent.ACTION_PICK, Uri.parse(&quot;content:&#x2F;&#x2F;contacts&quot;));</span><br><span class="line">    pickContactIntent.setType(Phone.CONTENT_TYPE); </span><br><span class="line">    startActivityForResult(pickContactIntent, PICK_CONTACT_REQUEST);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><font size="3">当用户完成操作后，返回数据，系统会调用Activity的 onActivityResult()方法，</font></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123;</span><br><span class="line">    &#x2F;&#x2F; 检查requestCode是否真确</span><br><span class="line">    if (requestCode &#x3D;&#x3D; PICK_CONTACT_REQUEST) &#123;</span><br><span class="line">        &#x2F;&#x2F; 确保请求时成功的</span><br><span class="line">        if (resultCode &#x3D;&#x3D; RESULT_OK) &#123;</span><br><span class="line">           &#x2F;&#x2F;完成我们的业务逻辑</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<blockquote>
<p>为了成功处理结果，我们必须了解Intent的格式，比如联系人返回的是带内容的URI，照相机返回的是Bitmap</p>
</blockquote>
<p><font size="3">如何根据返回的URI来读取数据，我们需要对ContentResolver 和 ContentProvider 有了解</font></p>
<p><font size="3">下面就是一个三者结合的获取联系人的实例：</font></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123;</span><br><span class="line">    &#x2F;&#x2F; 检查requestCode</span><br><span class="line">    if (requestCode &#x3D;&#x3D; PICK_CONTACT_REQUEST) &#123;</span><br><span class="line">        &#x2F;&#x2F; 确保请求成功</span><br><span class="line">        if (resultCode &#x3D;&#x3D; RESULT_OK) &#123;</span><br><span class="line">            &#x2F;&#x2F;获得选择的联系人的URI</span><br><span class="line">            Uri contactUri &#x3D; data.getData();</span><br><span class="line">            &#x2F;&#x2F; 我们只需要NUMBER这一列的信息，</span><br><span class="line">            String[] projection &#x3D; &#123;Phone.NUMBER&#125;;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 显示根据NUMBER查询的结果</span><br><span class="line">            &#x2F;&#x2F; We don&#39;t need a selection or sort order (there&#39;s only one result for the given URI)</span><br><span class="line">            &#x2F;&#x2F; 在这里我们并没有对查询的结果进行排序，因为在主线程中进行这种数据库操作，有可能阻塞线程</span><br><span class="line">            &#x2F;&#x2F;优化方案是异步完成排序的操作，这里只是展示多个App间的通信</span><br><span class="line">            Cursor cursor &#x3D; getContentResolver()</span><br><span class="line">                    .query(contactUri, projection, null, null, null);</span><br><span class="line">            cursor.moveToFirst();</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;从NUMBER那一列当中取回phone NUMBER</span><br><span class="line">            int column &#x3D; cursor.getColumnIndex(Phone.NUMBER);</span><br><span class="line">            String number &#x3D; cursor.getString(column);</span><br><span class="line">			&#x2F;&#x2F;接下来就是要操作这些phone number了</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong><font size="4">3. 接收其他Activity返回的结果</font></strong></p>
<p>要允许其他应用开始您的Activity，需要 <intent-filter> 在相应元素的宣示说明文件中添加一个 <activity> 元素。</activity></intent-filter></p>
<p>例如，此处有一个在数据类型为文本或图像时处理 ACTION_SEND 意向的意向过滤器：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">&lt;activity android:name&#x3D;&quot;ShareActivity&quot;&gt;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">        &lt;action android:name&#x3D;&quot;android.intent.action.SEND&quot;&#x2F;&gt;</span><br><span class="line">        &lt;category android:name&#x3D;&quot;android.intent.category.DEFAULT&quot;&#x2F;&gt;</span><br><span class="line">        &lt;data android:mimeType&#x3D;&quot;text&#x2F;plain&quot;&#x2F;&gt;</span><br><span class="line">        &lt;data android:mimeType&#x3D;&quot;image&#x2F;*&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;intent-filter&gt;</span><br><span class="line">&lt;&#x2F;activity&gt;</span><br></pre></td></tr></table></figure></div>
<p><action>定义操作，通常是系统定义的值之一，比如ACTION_SEND 或 ACTION_VIEW。<br><data>定义与Intent关联的数据，只需通过 android:mimeType 指定我们接收的数据类型，比如text/plain 或 image/jpeg。<br><category>所有的隐式Intent，都使用 CATEGORY_DEFAULT 进行定义</category></data></action></p>
<p><strong><font size="4">4. 处理Activity中的Intent</font></strong></p>
<p><font size="3">当Activity开始时，调用getIntent检索开始Activity的Intent，</font></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">    super.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">    setContentView(R.layout.main);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Intent intent &#x3D; getIntent();</span><br><span class="line">    Uri data &#x3D; intent.getData();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 指出接收的数据类型</span><br><span class="line">    if (intent.getType().indexOf(&quot;image&#x2F;&quot;) !&#x3D; -1) &#123;</span><br><span class="line">        &#x2F;&#x2F; 处理带有图片的Intent</span><br><span class="line">    &#125; else if (intent.getType().equals(&quot;text&#x2F;plain&quot;)) &#123;</span><br><span class="line">        &#x2F;&#x2F; 处理带有文本的Intent</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong><font size="4">5. 向指定Activity中返回数据</font></strong><br><font size="3">只需调用setResult指定结果代码和Intent</font></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">Intent result &#x3D; new Intent(&quot;com.example.RESULT_ACTION&quot;, Uri.parse(&quot;content:&#x2F;&#x2F;result_uri&quot;);</span><br><span class="line">setResult(Activity.RESULT_OK, result);</span><br><span class="line">finish();</span><br></pre></td></tr></table></figure></div>
<p><font size="3">记住必须为结果指定结果码，通常为 RESULT_OK 或 RESULT_CANCELED。</font></p>
<p><font size="3">我们也可以在Intent中 用Bundle存储额外的信息</font></p>
<p><font size="3">细心的同学可能发现一个问题： </font></p>
<p><font size="3"> 启动Activity 有startActivity() 和startActivityForResult() 两种启动方式，返回结果的形式id偶有setResult()吗？</font></p>
<p><font size="3"> 如果开启当前Activity的Intent可能需要结果，只需调用 setResult()。 如果原始Activity已调用 startActivityForResult()，则系统将向其传递您提供给 setResult() 的结果；否则，会忽略结果。</font></p>
<h1 id="使用大型开源框架完成组件间的通信"><a href="#使用大型开源框架完成组件间的通信" class="headerlink" title="使用大型开源框架完成组件间的通信"></a>使用大型开源框架完成组件间的通信<a href="#使用大型开源框架完成组件间的通信" class="header-anchor">#</a></h1><p><font size="4">Github上非常火的两大通信组件EventBus和otto：</font></p>
<p><strong><font size="5"> ## 1. EventBus</font></strong> </p>
<p><font size="4">EventBus 是一个 Android 事件发布/订阅框架，通过解耦发布者和订阅者简化 Android 事件传递，这里的事件可以理解为消息，本文中统一称为事件。事件传递既可用于 Android 四大组件间通讯，也可以用户异步线程和主线程间通讯等等。</font></p>
<p><font size="4">传统的事件传递方式包括：Handler、BroadCastReceiver、Interface 回调，相比之下 EventBus 的优点是代码简洁，使用简单，并将事件发布和订阅充分解耦。</font></p>
<p><font size="5">1）概念：</font></p>
<p><font size="4">事件(Event)：又可称为消息，本文中统一用事件表示。其实就是一个对象，可以是网络请求返回的字符串，也可以是某个开关状态等等。事件类型(EventType)指事件所属的 Class。<br>事件分为一般事件和 Sticky 事件，相对于一般事件，Sticky 事件不同之处在于，当事件发布后，再有订阅者开始订阅该类型事件，依然能收到该类型事件最近一个 Sticky 事件。</font></p>
<p><font size="4">订阅者(Subscriber)：订阅某种事件类型的对象。当有发布者发布这类事件后，EventBus 会执行订阅者的 onEvent 函数，这个函数叫事件响应函数。订阅者通过 register 接口订阅某个事件类型，unregister 接口退订。订阅者存在优先级，优先级高的订阅者可以取消事件继续向优先级低的订阅者分发，默认所有订阅者优先级都为 0。 </font></p>
<p><font size="4">发布者(Publisher)：发布某事件的对象，通过 post 接口发布事件。</font></p>
<p><font size="4">本项目较为简单，总体设计和流程图：</font></p>
<img src="http://cdn.yangchaofan.cn/BlogGifRes/20210306/qrFh6gW0eeyS.webp">



<p><strong><font size="5">2)使用方式：</font></strong></p>
<ul>
<li>build.gradle 中加入依赖<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">compile &#39;org.greenrobot:eventbus:3.0.0&#39;</span><br></pre></td></tr></table></figure></div></li>
<li>代码中指需三步 </li>
</ul>
<p><strong><font size="3">1.  定义事件：只需要是一个Java类</font></strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">  public class MessageEvent &#123;</span><br><span class="line">    public final String message;</span><br><span class="line"></span><br><span class="line">    public MessageEvent(String message) &#123;</span><br><span class="line">        this.message &#x3D; message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>   <strong><font size="3">2.  完成订阅者</font></strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;MessageEvent被Eventbus post提交的时候 将会回调这个方法</span><br><span class="line">&#x2F;&#x2F;这种方式 提示我们可以直接定义自己的事件</span><br><span class="line">@Subscribe</span><br><span class="line">public void onMessageEvent(MessageEvent event)&#123;</span><br><span class="line">    Toast.makeText(getActivity(), event.message, Toast.LENGTH_SHORT).show();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 当一些其他事件post提交的时候，回调这个方法</span><br><span class="line">@Subscribe</span><br><span class="line">public void handleSomethingElse(SomeOtherEvent event)&#123;</span><br><span class="line">    doSomethingWith(event);</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<p>在Activity或者Fragment中绑定订阅者</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onStart() &#123;</span><br><span class="line">    super.onStart();</span><br><span class="line">    EventBus.getDefault().register(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void onStop() &#123;</span><br><span class="line">   EventBus.getDefault().unregister(this);</span><br><span class="line">    super.onStop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong><font size="3">3.  发布事件：</font></strong></p>
<pre><code>​```
EventBus.getDefault().post(new MessageEvent(&quot;Hello everyone!&quot;));
​```
</code></pre>
<h1 id="很遗憾未完成的部分"><a href="#很遗憾未完成的部分" class="headerlink" title="很遗憾未完成的部分"></a>很遗憾未完成的部分<a href="#很遗憾未完成的部分" class="header-anchor">#</a></h1><ol start="5">
<li>Binder 机制以及应用</li>
<li>网络通信基础篇：Google 课程–AnsycTask+HttpClient </li>
<li>网络通信提高篇：开源框架Ansyc-Httpclient，okttp，Retrofit</li>
</ol>
<h1 id="本文参考并翻译"><a href="#本文参考并翻译" class="headerlink" title="本文参考并翻译"></a>本文参考并翻译<a href="#本文参考并翻译" class="header-anchor">#</a></h1><ol>
<li><a href="https://developer.android.com/training/basics/fragments/communicating.html"> Google 课程 Communicating with Other Fragments</a> </li>
<li><a href="https://developer.android.com/guide/components/aidl.html">Google 解释 AIDL进程间通信</a></li>
<li><a href="https://developer.android.com/training/multiple-threads/communicate-ui.html">Google 解释 Handler</a></li>
<li><a href="https://developer.android.com/reference/android/os/AsyncTask.html">Google 解释 AsyncTask</a></li>
<li><a href="https://developer.android.com/reference/android/content/BroadcastReceiver.html">Google BroadcastReceiver API</a></li>
<li><a href="https://developer.android.com/training/basics/intents/index.html?hl=vi"> Google 课程 Interacting with Other Apps</a></li>
<li><a href="https://developer.android.com/guide/topics/providers/content-provider-creating.html">Google  解释 contentprovider </a></li>
<li><a href="https://developer.android.com/reference/android/content/BroadcastReceiver.html">Google BroadcastReceiver 课程</a> </li>
<li><a href="https://developer.android.com/guide/components/services.html">Google  Service 课程</a></li>
<li><a href="https://developer.android.com/guide/components/processes-and-threads.html#">Google 解释 进程和线程</a></li>
<li><a href="http://greenrobot.org/eventbus/documentation/">EventBus官方文档</a></li>
</ol>
<link rel="stylesheet" href="/css/bilicard.css" type="text/css"></font>]]></content>
      <categories>
        <category>Android</category>
        <category>面试</category>
        <category>应用层</category>
        <category>项目架构</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Communication</tag>
      </tags>
  </entry>
  <entry>
    <title>Android性能优化【史诗巨著之内存篇】</title>
    <url>/blog//2016/06/performance-android/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>摘自本人16年的的博客<a href="http://blog.csdn.net/chivalrousman/article/details/51553114#t16">《Google官方  详解  Android 性能优化【史诗巨著之内存篇】》</a></p>
<p>博客使用的图片链接服务已经挂掉了，等以后有时间补上。</p>
<h1 id="为什么关注性能"><a href="#为什么关注性能" class="headerlink" title="为什么关注性能"></a>为什么关注性能<a href="#为什么关注性能" class="header-anchor">#</a></h1><hr>
<p>对于一款APP，用户首先关注的是 app的性能，而不是APP本身的属性功能，用户不关心你是否是搞社交，是否搞电商，是否是一款强大的美图滤镜app，用户首先关注的是 性能—-<font color="##000000"><strong>性能不好</strong>，用户会直接卸载，在应用市场给一个恶狠狠得差评，小则影响产品口碑，大则影响公司的品牌和声誉，作为程序员，app的性能更应该作为我们关注的一个功能，而不是出了问题 才去门头苦恼加班加点的负担。</font></p>
<p>老实说，提高app性能的确非常难，处理这些问题 你必须知道：</p>
<ol>
<li>应用速度慢的原因</li>
<li>还必须正确使用分析工具来分析数据</li>
</ol>
<p>为此诞生了本文：</p>
<ol>
<li>了解这些工具并用它们找到造成性能不好的原因</li>
<li>从理论角度了解它们</li>
</ol>
<h1 id="如何优化app的性能"><a href="#如何优化app的性能？" class="headerlink" title="如何优化app的性能？"></a>如何优化app的性能？<a href="#如何优化app的性能" class="header-anchor">#</a></h1><hr>
<p>性能优化听上去是一项非常艰巨的功能，但仔细思考，其实非常简单：</p>
<p>1.获取信息</p>
<p>有人说你应用慢，应用闪退（崩掉，crash掉）的时候你需要找到原因。</p>
<p>通过运行 分析和反馈工具软件来收集应用相关的信息，我们需要明确哪些可以测量，哪些可以优化</p>
<p>也就是说任何应用开始优化时，整个过程取决于问题的可测性以及性能优化的可评价性。 开发中经常遇到的坎，问题不可复现，以及对于某一个细节是否需要优化 拿不定主意，这个需要我们自己身处其境 考虑分析各方面因素 得出结论，而不是纯粹得靠感觉。</p>
<p>2.分析数据</p>
<p>很多时候，我们并不能直接理解问题的原因，比如内存溢出（OOM）的error，判断内存溢出需要计算很多个变量得内存大小，我们并不能直观通过眼球看出来一个app 运行过程那些变量的内存，这里我们就需要运行分析工具来帮助我们，将其转化为可视化的图表，</p>
<blockquote>
<p>   在这里，我们可能还是看不懂那些图表，横线竖线，具体是个什么玩意，没有关系，去弄懂它们！就可以成为性能大师了.现在你看那些内存中的二进制转换成图表的过程，就类似于古代的算命大师，步骤1和步骤2 会不断的循环，搜集数据，分析数据···有时候我们不只使用一种搜集工具和分析工具，这就需要自己针对性能得种类来深入研究了</p>
</blockquote>
<p>3.Tack action!</p>
<p> 发现了问题，找到了问题所在以及发生的原因，我们必须要恰当的去解决它，根据项目进度，该性能的优化成本，性能优先级，考虑项目中使用的java库或者android开源框架，其中的一些严格限制，</p>
<p>在你提出方案等待技术委员会评审之前，这些因素都是我们需要考虑的，因为提出的优化方案，不一定会被公司高层接受（除非你就是高层）。</p>
<blockquote>
<p>工具不是规则，理解事物的规则和流程比仅会使用更重要</p>
</blockquote>
<h1 id="为什么关注内存"><a href="#为什么关注内存" class="headerlink" title="为什么关注内存"></a>为什么关注内存<a href="#为什么关注内存" class="header-anchor">#</a></h1><blockquote>
<p>内存大小属于手机性能之一</p>
</blockquote>
<p>举个简单的例子，内存就像你的卧室一样，当你在老家住着动辄几百平的村庄，舒服惯了，突然变卖家产一门心思想创业来到北京，家里的老本只够你住几平米的卫生间的时候，你就会注意到内存【房间】大小的重要性了。</p>
<p>首先我们要知道内存是如何影响系统运行</p>
<p>通常我们认为代码执行速度等同于物理硬件的执行速度，我们的代码指令都是通过使用内存来完成的。通过为实例对象，常量，变量分配内存，来完成操作，但是如何释放这些内存，通常我们并不清楚。</p>
<img src="http://cdn.yangchaofan.cn/2222.png">



<p>一旦分配出去的内存没有及时回收，会引造成系统卡顿，执行操作缓慢现象，这种现象称之为内存泄漏，Memory leak</p>
<img src="http://cdn.yangchaofan.cn/333.png">




<h1 id="java垃圾回收机制官方详解"><a href="#Java垃圾回收机制官方详解" class="headerlink" title="Java垃圾回收机制官方详解"></a>Java垃圾回收机制官方详解<a href="#java垃圾回收机制官方详解" class="header-anchor">#</a></h1><blockquote>
<p>java中的JVM就是一个抽象的计算机，和实际的计算机一样，它具有指令集并使用不同的存储区域，JVM负责执行代码，管理数据，管理内存和寄存器。</p>
</blockquote>
<p>垃圾回收机制只做两件基本的事情：</p>
<ol>
<li> 发现无用的对象</li>
<li> 回收被无用对象占用的内存空间，使得该空间可以被程序再次利用</li>
</ol>
<p>通常，垃圾回收具有如下特点：</p>
<ol>
<li><p>垃圾回收机制的工作目标是回收无用对象的内存空间，这些内存空间都是JVM堆内存的内存资源，对于其他物理资源，比如数据库连接，磁盘I/O 等资源无能为力</p>
</li>
<li><p>为了让垃圾回收机制尽快回收那些对象，可以将该对象引用变量置为null，</p>
</li>
<li><p><font color="#0000FF"><strong>垃圾回收发生的不可预知性</strong></font>，不同JVM 采用不同的算法和机制，有可能定时回收，有可能cpu空闲回收，也有可能内存消耗极限发生，即使通过Runtime对象的gc（），System.gc（）来建议系统进行回收，但这之属于建议，不能精确控制垃圾回收机制的执行,</p>
</li>
</ol>
<pre><code>&gt; 意思就是说，垃圾回收机制什么时候开始执行，并不是我们程序员能控制的，我们只能给予建议。
</code></pre>
<p><font color="#0000FF">那么问题来了，如何精确的进行垃圾回收呢？</font><br><font color="#0000FF">那么问题来了，如何精确的进行垃圾回收呢？</font><br><font color="#0000FF">那么问题来了，如何精确的进行垃圾回收呢？</font></p>
<p>回答很明确，确保每一个对象都进行了有效的释放。对于不再需要的对象，不要引用他们，一旦在别的地方保持对这个对象的引用，垃圾回收机制 暂时不会回收该对象，则会导致严重得问题—-<font color="#FF00FF">系统可用内存越来越少，垃圾回收执行的频率越来越高，cpu全都被垃圾回收的操作占有了，系统性能自然而然就下降了！</font></p>
<p>java8 已经删除了永生代内存，即一些常驻内存，不会回收的数据，而是改为使用本地内存来存储类的元数据，称之为元空间（Metaspace），不过貌似和Android开发没关系(-__-)。</p>
<p>回顾完java垃圾回收，下面介绍<br>##Android 自己的回收机制-Runtime 回收机制</p>
<img src="http://cdn.yangchaofan.cn/androidruntimeheap.png">



<p>经由为数据分配内存的类型，以及系统如何有效的利用gc回收内存，并为新的对象分配内存。</p>
<p>所有要申请的内存都被划分到内存空间中，根据这些特点，哪些数据分配到哪些内存中，取决于Android的版本，</p>
<p>最为重要的一点，Android系统为每个运行中的app分配了预设的内存通常为16m-32m之间，当分配的内存越多，系统内存不足时，系统就可能会执行内存清理，注意，是可能会执行，是否执行垃圾清理是由系统自己判断的。</p>
<p>进行垃圾回收，以确保有足够的内存分配给其他的应用操作，不同的Android版本，会有不同的gc操作，例如在davailk中，gc代表终止程序操作，</p>
<img src="http://cdn.yangchaofan.cn/空间预设大小.png">



<p>##代码是如何影响程序执行的？</p>
<img src="http://cdn.yangchaofan.cn/gc1.png">

<p>上图是正常的界面刷新流程，</p>
<img src="http://cdn.yangchaofan.cn/gc2.png">



<p>上图，gc占据了一大块的时间，对于我们人类来说很短，但是对于系统来说很长了。</p>
<img src="http://cdn.yangchaofan.cn/gc3.png">




<p>综合三张图分析：代码质量很差，使得系统为我们的app分配了过多内存，而且没有及时回收，系统需要更多的时间去执行gc回收，那么系统就没时间去保持界面的活跃，所以就造成了卡顿的现象。，</p>
<blockquote>
<p>在一个循环体中，重复得创建对象，就会造成内存污染，马上就会有很多gc<br>启动，由于这一额外的内存压力，内存泄漏仍然会产生，当可用内存降低到一定总量时，会强制系统gc执行，那循环体中的那部分操作会显示出卡顿的情况，甚至有可能在内存极限的时候，我们开发的应用会闪退。</p>
</blockquote>
<p>所以，唯一的解决办法是：减少代码申请的内存量，不使用的对象及时回收。</p>
<h1 id="memory-monitor"><a href="#Memory-Monitor" class="headerlink" title="Memory Monitor"></a>Memory Monitor<a href="#memory-monitor" class="header-anchor">#</a></h1><img src="http://cdn.yangchaofan.cn/gc4.png">



<p>整个层叠图，代表还有多少内存可用<br>深蓝色区域：代表正在使用的内存大小<br>浅灰色区域：代表空闲未分配内存</p>
<img src="http://cdn.yangchaofan.cn/gc5.png">



<p>这个红色箭头所指的坡度表示急需大量的内存，内存分配也急剧的增加。<br>上图是一个内存管理良好的例子</p>
<p>下图我们看一个内存糟糕的例子</p>
<img src="http://cdn.yangchaofan.cn/gc6.png">



<blockquote>
<p>分析</p>
</blockquote>
<p><font color="#fff22f22">这里有一部分代码占用了大量的内存，然后又一下子释放了内存，生成不断重复又窄又长的曲线，这就是程序在花大量的时间在进行垃圾清理，运行垃圾清理的时间越多，其他操作可用的时间就越少，比如跟网络交互数据，页面刷新，打电话，听歌等等，这样就造成了卡顿<font></font></font></p>
<p>###<strong>使用Montior过程中遇到的 No Debugable Application的问题</strong></p>
<img src="http://cdn.yangchaofan.cn/montior.png">




<blockquote>
<p>solution：Tools-Android-Android adb interact</p>
<p>最初并不会见效，重启app即可，</p>
</blockquote>
<img src="http://cdn.yangchaofan.cn/montior2.png">

<h1 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏<a href="#内存泄漏" class="header-anchor">#</a></h1><hr>
<p>在这里我才开始引入内存泄漏的原因【虽然文章前面已经提到，但是在这里才着重拿出来作为一节】</p>
<p>网络上和一些书籍对内存泄漏解释是 应该回收的对象没有回收，有点不全面，我认为深一点来说，内存泄漏是针对系统而言的，内存泄漏指的是不能被使用的内存，但是垃圾回收器无法识别出来，对其进行回收，这些对象一直存在于堆中，并且持续占据着内存空间，无法被删除，随着不断泄漏，系统可用的内存就越来越小，意味着系统又需要花更多的时间 去进行内存清理操作，进行垃圾回收操作的次数越来越多，</p>
<blockquote>
<p>简单的内存泄漏：对没有使用的对象 循环引用<br>复杂一点的：在listview还没有绘制完成时就添加到activity  &gt;</p>
</blockquote>
<h1 id="heap-viewer"><a href="#Heap-Viewer" class="headerlink" title="Heap Viewer"></a>Heap Viewer<a href="#heap-viewer" class="header-anchor">#</a></h1><blockquote>
<p>Heap viewer使用步骤，我录制了gift图，详情请看：</p>
</blockquote>
<img src="http://cdn.yangchaofan.cn/heapviewer.gif">



<blockquote>
<p> 了解Heap Viewer:<br> Heap Viewer可以有效的分析程序在堆中分配的数据类型及数量和 大小小</p>
</blockquote>
<p> <img src="https://img-blog.csdnimg.cn/img_convert/aee4a58d58a1f48cf83bee00191ac4dc.png" alt="这里写图片描述">  </p>
<blockquote>
<p>  这里表示 byte数组和boolean数组的数量为177，占用了1.423M的内存</p>
</blockquote>
<p>#内存泄漏的情况</p>
<img src="http://cdn.yangchaofan.cn/gc7.png">



<p>绿色箭头标出来的那部分 代码就是有问题的部分，原因在于，可以内存几乎为0，所有的内存已经被程序占用，首先记住，我们的代码有问题，造成了内存泄漏，并且，垃圾回收机制无法回收那部分内存空间</p>
<p>下图为30s之后的内存回收情况</p>
<img src="http://cdn.yangchaofan.cn/gc8.png">



<p>启动第二次gc，此时Android调整并提高应用的内存上限，这样做的同时，如果漏洞没有修复，表明内存泄漏仍然存在，那么还会有第三次，第四次同样的gc操作，直至系统无法调整提高给应用更高的内存上限，造成内存溢出，甚至可能死机，</p>
<p>#Trace Viewer分配追踪器<br>  <img src="https://img-blog.csdnimg.cn/img_convert/b8eeebf564c906276013a33b4db3a7a0.png" alt="这里写图片描述"></p>
<blockquote>
<blockquote>
<p>Trace Viewer可以精确追踪到代码的位置，限于篇幅请按照上图点击 那几个按钮  自行摸索考功它的功能能</p>
</blockquote>
</blockquote>
<h1 id="高效加载图片图片"><a href="#高效加载图片图片" class="headerlink" title="高效加载图片图片"></a>高效加载图片图片<a href="#高效加载图片图片" class="header-anchor">#</a></h1><h2 id="为什么只关注图片加载而不去处理其他数据来解决内存不足的问题"><a href="#为什么只关注图片加载，而不去处理其他数据来解决内存不足的问题？" class="headerlink" title="为什么只关注图片加载，而不去处理其他数据来解决内存不足的问题？"></a><strong>为什么只关注图片加载，而不去处理其他数据来解决内存不足的问题？</strong><a href="#为什么只关注图片加载而不去处理其他数据来解决内存不足的问题" class="header-anchor">#</a></h2><ol>
<li><p>Android 加载图片会创建Bitmap,drawable实例，占用内存空间，如果不进行高效处理，程序会很快达到 Android系统分配给APP的内存上限，直至挂掉</p>
</li>
<li><p>图片资源相比文本资源，在内存中会占据更大的内存，从字节数就可以看出来</p>
</li>
<li><p>在我们的应用中正确恰当高效的加载 图片资源 是一件非常棘手的事情</p>
</li>
</ol>
<blockquote>
<ol>
<li>Android 系统会分配给单个APP至少 16M左右的内存，） Android Compatibility Definition Document (CDD)中，根据不同手机的尺寸和屏幕像素来要求应用最小内存，我们开发 的应用需要优化内存至最低内存限制，然而请记住，许多手机对内存有着更高的要求。</li>
<li>图片消耗大量的内存，尤其是高像素的图片，比如入门级单反相机拍摄出来的一张图片，都有可能超出APP的最低内存限制</li>
<li>app 中一些常见的UI 比如 ListView, GridView and ViewPager，都需要立刻加载大量的图片，注意是立刻，这对内存管理提出了很高的要求。</li>
</ol>
</blockquote>
<p><strong>所以我们需要高效得加载图片。</strong></p>
<h1 id="高效的加载大图"><a href="#高效的加载大图：" class="headerlink" title="高效的加载大图："></a>高效的加载大图：<a href="#高效的加载大图" class="header-anchor">#</a></h1><p>一张图片的像素，尺寸，分别率，由可能超过Android的UI组件本身大小，UI组件的大小是由手机设备屏幕决定的，这些超出的部分，会消耗更多的内存。</p>
<p>应该让图片去匹配我们的手机设备，所以，我们需要对图片进行处理：</p>
<ol>
<li>不能超过每个应用程序的内存限制</li>
<li>用最小的内存加载图片</li>
</ol>
<h2 id="只需三步"><a href="#只需三步" class="headerlink" title="只需三步"></a>只需三步<a href="#只需三步" class="header-anchor">#</a></h2><h2 id="1-读取内存中bitmap的尺寸和类型"><a href="#1-读取内存中Bitmap的尺寸和类型" class="headerlink" title="1. 读取内存中Bitmap的尺寸和类型"></a><strong>1. 读取内存中Bitmap的尺寸和类型</strong><a href="#1-读取内存中bitmap的尺寸和类型" class="header-anchor">#</a></h2><p> BitmapFactory类提供了很多解析Bitmap的方法（decodeByteArray(), decodeFile(), decodeResource(), etc.），每一种解析方法都有一个额外的参数 BitmapFactory.Options，设置inJustDecodeBounds 属性为true可以禁止应用分配内存，此时bitmap返回为null，但是我们可以通过BitmapFactory.Options对象来获取很多有用的参数</p>
<p> 此时 你可以通过BitmapFactory.Options来读取图片的尺寸和类型</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line">BitmapFactory.Options options = <span class="keyword">new</span> BitmapFactory.Options();</span><br><span class="line">options.inJustDecodeBounds = <span class="keyword">true</span>;</span><br><span class="line">BitmapFactory.decodeResource(getResources(), R.id.myimage, options);</span><br><span class="line"><span class="keyword">int</span> imageHeight = options.outHeight;</span><br><span class="line"><span class="keyword">int</span> imageWidth = options.outWidth;</span><br><span class="line">String imageType = options.outMimeType;</span><br></pre></td></tr></table></figure></div>
<blockquote>
<p>总结：为了避免java.lang.OutOfMemory ，在加载图片之前需要检查原图的大小是否超出最低内存限制。</p>
</blockquote>
<h2 id="2-加载一张小图使得系统分配较少的内存给它"><a href="#2-加载一张小图，使得系统分配较少的内存给它。" class="headerlink" title="2. 加载一张小图，使得系统分配较少的内存给它。"></a><strong>2. 加载一张小图，使得系统分配较少的内存给它。</strong><a href="#2-加载一张小图使得系统分配较少的内存给它" class="header-anchor">#</a></h2><blockquote>
<p>现在我们已经获取到了图片的尺寸，加载一张图片之前，我们需要考虑：</p>
</blockquote>
<ul>
<li><p>计算整张图片需要多大的内存</p>
</li>
<li><p>我们希望给它多大的内存</p>
</li>
<li><p>加载图片的组件比如Imageview的尺寸是多大</p>
</li>
<li><p>当前手机设备的屏幕尺寸和分辨率</p>
</li>
</ul>
<p>例如一张1080<em>720的图片要展示在一个128</em>72的Imageview上</p>
<p>实际 项目中，比如一张2048x1536的图片，我们通过设置inSampleSize为4，来创建实际大小为512x384的bitmap，这样需要的内存为0.75MB而不是之前的12MB（色彩模式都是ARGB_8888的情况下），</p>
<p>Google官方提供了两个方法来供我们使用，可以封装到自己的工具类中：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateInSampleSize</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            BitmapFactory.Options options, <span class="keyword">int</span> reqWidth, <span class="keyword">int</span> reqHeight)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获得内存中图片的宽高</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> height = options.outHeight;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> width = options.outWidth;</span><br><span class="line">    <span class="keyword">int</span> inSampleSize = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (height &gt; reqHeight || width &gt; reqWidth) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> halfHeight = height / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> halfWidth = width / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算出一个数值，必须符合为2的幂（1，2，4，8，tec），赋值给inSampleSize</span></span><br><span class="line">        <span class="comment">// 图片宽高应大于期望的宽高的时候，才进行计算</span></span><br><span class="line">        <span class="keyword">while</span> ((halfHeight / inSampleSize) &gt; reqHeight</span><br><span class="line">                &amp;&amp; (halfWidth / inSampleSize) &gt; reqWidth) &#123;</span><br><span class="line">            inSampleSize *= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inSampleSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bitmap <span class="title">decodeSampledBitmapFromResource</span><span class="params">(Resources res, <span class="keyword">int</span> resId,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> reqWidth, <span class="keyword">int</span> reqHeight)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一次解析 inJustDecodeBounds=true 只是用来获取bitmap在内存中的尺寸和类型，系统并不会为其分配内存，</span></span><br><span class="line">    <span class="keyword">final</span> BitmapFactory.Options options = <span class="keyword">new</span> BitmapFactory.Options();</span><br><span class="line">    options.inJustDecodeBounds = <span class="keyword">true</span>;</span><br><span class="line">    BitmapFactory.decodeResource(res, resId, options);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算出一个数值</span></span><br><span class="line">    options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据inSampleSize 数值来解析bitmap</span></span><br><span class="line">    options.inJustDecodeBounds = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> BitmapFactory.decodeResource(res, resId, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<blockquote>
<p>研究一个新的函数，我们先关注函数的输入和输出提高阅读能力</p>
</blockquote>
<h2 id="3接着为我们的ui组件imageview设置一张缩略图咯"><a href="#3-接着为我们的UI组件ImageView设置一张缩略图咯：" class="headerlink" title="3.接着为我们的UI组件ImageView设置一张缩略图咯："></a><strong>3.接着为我们的UI组件ImageView设置一张缩略图咯：</strong><a href="#3接着为我们的ui组件imageview设置一张缩略图咯" class="header-anchor">#</a></h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line">mImageView.setImageBitmap(</span><br><span class="line">    decodeSampledBitmapFromResource(getResources(), R.id.myimage, <span class="number">100</span>, <span class="number">100</span>));</span><br></pre></td></tr></table></figure></div>
<p>为了完全理解这一部分，初学者请自行查阅</p>
<ol>
<li> BitmapFactory.decode   </li>
<li> BitmapFactory.Options</li>
</ol>
<h1 id="使asynctask加载bitmap"><a href="#使AsyncTask加载Bitmap" class="headerlink" title="使AsyncTask加载Bitmap"></a>使AsyncTask加载Bitmap<a href="#使asynctask加载bitmap" class="header-anchor">#</a></h1><p>当图片资源来自网络或者硬盘的时候，最好不要直接在主线程中加载它，例如IO资源或者数据库资源都会占用CPU，CPU 要做的事情过多，Android手机会造成卡顿得现象，</p>
<p><strong>好在Google 提供了解决办法–AsyncTask异步加载工具</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BitmapWorkerTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">Integer</span>, <span class="title">Void</span>, <span class="title">Bitmap</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WeakReference&lt;ImageView&gt; imageViewReference;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> data = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BitmapWorkerTask</span><span class="params">(ImageView imageView)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 用弱引用确保能被垃圾回收机制回收</span></span><br><span class="line">        imageViewReference = <span class="keyword">new</span> WeakReference&lt;ImageView&gt;(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在后台解析bitmap</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Bitmap <span class="title">doInBackground</span><span class="params">(Integer... params)</span> </span>&#123;</span><br><span class="line">        data = params[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> decodeSampledBitmapFromResource(getResources(), data, <span class="number">100</span>, <span class="number">100</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一旦完成，imageView将会加载bitmap</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(Bitmap bitmap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (imageViewReference != <span class="keyword">null</span> &amp;&amp; bitmap != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> ImageView imageView = imageViewReference.get();</span><br><span class="line">            <span class="keyword">if</span> (imageView != <span class="keyword">null</span>) &#123;</span><br><span class="line">                imageView.setImageBitmap(bitmap);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>接着我们在主线程中执行它即可</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadBitmap</span><span class="params">(<span class="keyword">int</span> resId, ImageView imageView)</span> </span>&#123;</span><br><span class="line">    BitmapWorkerTask task = <span class="keyword">new</span> BitmapWorkerTask(imageView);</span><br><span class="line">    task.execute(resId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h1 id="使用lrucache缓存图片"><a href="#使用Lrucache缓存图片" class="headerlink" title="使用Lrucache缓存图片"></a>使用Lrucache缓存图片<a href="#使用lrucache缓存图片" class="header-anchor">#</a></h1><p><font size="4"><strong>1.  为什么要缓存图片？</strong><font></font></font></p>
<p>对于如何高效的加载一张图片 ，我们似乎已经得心应手了，这里要泼一盆凉水给大家，因为我们的应用不仅只是加载一张图片这么简单，比如ListView, GridView or ViewPager，RecyclerView，需要立刻加载出大量的bitmap，滑动的过程不断加载bitmap，还要求不卡顿，内存够用，这似乎又是一件棘手的事情。</p>
<p>Google 又提供了一种解决思路：对于ListView，RecyclerView，有可见的item和不可见的item，回收不可见的item  内存，分配给可见的，这样内存得到了重复利用，避免重复创建对象，不断申请并分配新的内存空间，触发最低内存限制的危险。</p>
<p>所以我们要管理 这些 已经创建好的内存。</p>
<p><font size="4"><strong>2.  使用内存缓存</strong><font></font></font></p>
<ol>
<li><p>为什么优先使用内存缓存？ </p>
<p>答：相比硬盘缓存的读取速度，读取内存中的数据更快</p>
</li>
<li><p>Google官方有什么建议？  </p>
<p>答：Google推荐Lrucache类，底层使用用强引用封装的LinkedHashMap，来存储最近使用的对象，它自动会回收最近使用的对象当中，使用的最少的那一个对象的内存，这一点毋庸置疑值得推荐！</p>
</li>
</ol>
<blockquote>
<p>一种过时的做法，是用虚引用或者弱引用来标记bitmap，这种方法在Android 3.0以后已经不提倡了，因为类似JDK1.8那样，bitmap的内存是放在本地内存中的，它的回收是不确定的，有可能导致APP挂掉，切勿使用。 </p>
</blockquote>
<ol start="3">
<li><p>Lrucache这么棒，我们该如何用？</p>
<p>Lrucache就可以当作一种存储数据的结构，类似list，set，可以存储对象，获取对象，对应的有add（） 和get（）方法，它与数组一样，初始化的时候需要指定一个初始的大小。</p>
<p>那么Lrucache实例 初始的大小该如何确定？<br>在计算大小之前，我们需要明确几件事情：</p>
</li>
</ol>
<ul>
<li><p>我们的Activity和Application还有多少可用内存？</p>
</li>
<li><p>我们的Activity和Application还有多少可用内存？</p>
</li>
<li><p>第一次加载的时候，需要为多少图片分配内存？可见的item数量，决定了图片的数量，图片的数量*每张图片的内存大小就是初始化需要分配的内存。</p>
</li>
<li><p>用户当前手机的屏幕尺寸和屏幕密度（为什么要这俩参数？大屏幕手机 ，初始化的时候会加载更多的item，需要的内存更大）</p>
</li>
<li><p>这张图片我们要怎样配置？图片的尺寸如何设置，颜色模式如何配置？根据不同的需求，比如是做用户头像，还是信息展示？都有各自的应用场景的要求。我们需要分类判断.</p>
</li>
<li><p>cache大小是由内存大小决定的，而不是 它存储数据的个数决定</p>
<blockquote>
<p>这让我想起一个在项目开发中常见的bug，use a bitmap which has bean recycler</p>
</blockquote>
<p> <font size="4"><strong>4. Lrucache使用实例</strong><font>     </font></font></p>
</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> LruCache&lt;String, Bitmap&gt; mMemoryCache;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 当Lrucache使用的内存大小超过虚拟机最大的可用内存时候，Android会抛出OutOfMemory exception</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> maxMemory = (<span class="keyword">int</span>) (Runtime.getRuntime().maxMemory() / <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用虚拟机可用1/8</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> cacheSize = maxMemory / <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  在Lrucache构造函数中初始化它的大小</span></span><br><span class="line">    <span class="comment">// int in its constructor</span></span><br><span class="line">    mMemoryCache = <span class="keyword">new</span> LruCache&lt;String, Bitmap&gt;(cacheSize) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">sizeOf</span><span class="params">(String key, Bitmap bitmap)</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//cache大小是由内存大小决定的，而不是 它存储数据的个数决定</span></span><br><span class="line">         <span class="keyword">return</span> bitmap.getByteCount() / <span class="number">1024</span>;</span><br><span class="line">        &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBitmapToMemoryCache</span><span class="params">(String key, Bitmap bitmap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getBitmapFromMemCache(key) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mMemoryCache.put(key, bitmap);</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> Bitmap <span class="title">getBitmapFromMemCache</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mMemoryCache.get(key);</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<p>loadBitmap的过程很简洁：如果内存缓存中有这张bitmap，则直接刷新imageview，如果bitmap为空，则启动后台线程去加载bitmap，接着刷新imageview</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadBitmap</span><span class="params">(<span class="keyword">int</span> resId, ImageView imageView)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> String imageKey = String.valueOf(resId);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Bitmap bitmap = getBitmapFromMemCache(imageKey);</span><br><span class="line">    <span class="keyword">if</span> (bitmap != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mImageView.setImageBitmap(bitmap);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mImageView.setImageResource(R.drawable.image_placeholder);</span><br><span class="line">        BitmapWorkerTask task = <span class="keyword">new</span> BitmapWorkerTask(mImageView);</span><br><span class="line">        task.execute(resId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<p>异步线程  BitmapWorkerTask</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BitmapWorkerTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">Integer</span>, <span class="title">Void</span>, <span class="title">Bitmap</span>&gt; </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Decode image in background.</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Bitmap <span class="title">doInBackground</span><span class="params">(Integer... params)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Bitmap bitmap = decodeSampledBitmapFromResource(</span><br><span class="line">                getResources(), params[<span class="number">0</span>], <span class="number">100</span>, <span class="number">100</span>));</span><br><span class="line">        addBitmapToMemoryCache(String.valueOf(params[<span class="number">0</span>]), bitmap);</span><br><span class="line">        <span class="keyword">return</span> bitmap;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><font size="4"><strong>5. 磁盘缓存</strong><font><br>与内存缓存相结合的还有磁盘缓存，虽然磁盘读取速度较慢，但是持久存储的，不像内存缓存那样，在内存极限情况下仍然会被清理，比如后台正在执行数据加载，突然打进来一个电话，内存不足系统可能会进行垃圾回收。缓存就没有了</font></font></p>
<p>Google官方提供直接DiskLruCache 类</p>
<p>为什么要使用DiskLruCache 很明了：就是解决当内存缓存不可用的情形</p>
<blockquote>
<p>内当需要频繁访问缓存的图片资源时，比如APP的画廊功能，可以考虑使用ContentProvider解决更为妥当。</p>
</blockquote>
<p>下面是它的源码</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> DiskLruCache mDiskLruCache;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object mDiskCacheLock = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> mDiskCacheStarting = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DISK_CACHE_SIZE = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">10</span>; <span class="comment">// 10MB</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DISK_CACHE_SUBDIR = <span class="string">&quot;thumbnails&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Initialize memory cache</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Initialize disk cache on background thread</span></span><br><span class="line">    File cacheDir = getDiskCacheDir(<span class="keyword">this</span>, DISK_CACHE_SUBDIR);</span><br><span class="line">    <span class="keyword">new</span> InitDiskCacheTask().execute(cacheDir);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InitDiskCacheTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">File</span>, <span class="title">Void</span>, <span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Void <span class="title">doInBackground</span><span class="params">(File... params)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mDiskCacheLock) &#123;</span><br><span class="line">            File cacheDir = params[<span class="number">0</span>];</span><br><span class="line">            mDiskLruCache = DiskLruCache.open(cacheDir, DISK_CACHE_SIZE);</span><br><span class="line">            mDiskCacheStarting = <span class="keyword">false</span>; <span class="comment">// Finished initialization</span></span><br><span class="line">            mDiskCacheLock.notifyAll(); <span class="comment">// Wake any waiting threads</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BitmapWorkerTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">Integer</span>, <span class="title">Void</span>, <span class="title">Bitmap</span>&gt; </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Decode image in background.</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Bitmap <span class="title">doInBackground</span><span class="params">(Integer... params)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String imageKey = String.valueOf(params[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check disk cache in background thread</span></span><br><span class="line">        Bitmap bitmap = getBitmapFromDiskCache(imageKey);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bitmap == <span class="keyword">null</span>) &#123; <span class="comment">// Not found in disk cache</span></span><br><span class="line">            <span class="comment">// Process as normal</span></span><br><span class="line">            <span class="keyword">final</span> Bitmap bitmap = decodeSampledBitmapFromResource(</span><br><span class="line">                    getResources(), params[<span class="number">0</span>], <span class="number">100</span>, <span class="number">100</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add final bitmap to caches</span></span><br><span class="line">        addBitmapToCache(imageKey, bitmap);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bitmap;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBitmapToCache</span><span class="params">(String key, Bitmap bitmap)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Add to memory cache as before</span></span><br><span class="line">    <span class="keyword">if</span> (getBitmapFromMemCache(key) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mMemoryCache.put(key, bitmap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Also add to disk cache</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mDiskCacheLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mDiskLruCache != <span class="keyword">null</span> &amp;&amp; mDiskLruCache.get(key) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mDiskLruCache.put(key, bitmap);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Bitmap <span class="title">getBitmapFromDiskCache</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mDiskCacheLock) &#123;</span><br><span class="line">        <span class="comment">// Wait while disk cache is started from background thread</span></span><br><span class="line">        <span class="keyword">while</span> (mDiskCacheStarting) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mDiskCacheLock.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mDiskLruCache != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> mDiskLruCache.get(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Creates a unique subdirectory of the designated app cache directory. Tries to use external</span></span><br><span class="line"><span class="comment">// but if not mounted, falls back on internal storage.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> File <span class="title">getDiskCacheDir</span><span class="params">(Context context, String uniqueName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Check if media is mounted or storage is built-in, if so, try and use external cache dir</span></span><br><span class="line">    <span class="comment">// otherwise use internal cache dir</span></span><br><span class="line">    <span class="keyword">final</span> String cachePath =</span><br><span class="line">            Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState()) ||</span><br><span class="line">                    !isExternalStorageRemovable() ? getExternalCacheDir(context).getPath() :</span><br><span class="line">                            context.getCacheDir().getPath();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> File(cachePath + File.separator + uniqueName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<p> <strong>6.处理运行时变更的缓存</strong><br>当屏幕旋转，或者其他原因导致Activity  restart，这个时候难道又让我们重新创建大量的图像资源？<br>回答是否定的，Google提供了一种解决方案：</p>
<p>通过在Activity中使用fragment，构造Fragment时，通过设置 setRetainInstance(true))来设置缓存，<br>话不多说，直接上代码：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> LruCache&lt;String, Bitmap&gt; mMemoryCache;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    RetainFragment retainFragment =</span><br><span class="line">            RetainFragment.findOrCreateRetainFragment(getFragmentManager());</span><br><span class="line">    mMemoryCache = retainFragment.mRetainedCache;</span><br><span class="line">    <span class="keyword">if</span> (mMemoryCache == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mMemoryCache = <span class="keyword">new</span> LruCache&lt;String, Bitmap&gt;(cacheSize) &#123;</span><br><span class="line">            ... <span class="comment">// Initialize cache here as usual</span></span><br><span class="line">        &#125;</span><br><span class="line">        retainFragment.mRetainedCache = mMemoryCache;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RetainFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;RetainFragment&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> LruCache&lt;String, Bitmap&gt; mRetainedCache;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RetainFragment</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RetainFragment <span class="title">findOrCreateRetainFragment</span><span class="params">(FragmentManager fm)</span> </span>&#123;</span><br><span class="line">        RetainFragment fragment = (RetainFragment) fm.findFragmentByTag(TAG);</span><br><span class="line">        <span class="keyword">if</span> (fragment == <span class="keyword">null</span>) &#123;</span><br><span class="line">            fragment = <span class="keyword">new</span> RetainFragment();</span><br><span class="line">            fm.beginTransaction().add(fragment, TAG).commit();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fragment;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setRetainInstance(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<blockquote>
<p>尊重博主原创，如需转载，请附上本文链接接：<br><a href="http://blog.csdn.net/chivalrousman/article/details/51567118">http://blog.csdn.net/chivalrousman/article/details/51567118</a></p>
</blockquote>
<h1 id="补充-ui组件并发性问题"><a href="#补充-UI组件并发性问题" class="headerlink" title="补充-UI组件并发性问题"></a>补充-UI组件并发性问题<a href="#补充-ui组件并发性问题" class="header-anchor">#</a></h1><p>这一部分涉及到UI细节，例如ListView，Viewpager的优化</p>
<h1 id="viewpager"><a href="#ViewPager" class="headerlink" title="ViewPager"></a>ViewPager<a href="#viewpager" class="header-anchor">#</a></h1><p>ViewPager是一个非常棒的组件，通过使用ViewPager和PagerAdapter可以实现类似新闻标题的滑动条以及常见的画廊功能。</p>
<p>谈到优化，Google 建议使用 PagerAdapter的子类FragmentStatePagerAdapter ，它可以在后台自动销毁和保存ViewPager中使用的Fragment的数据，通过使用它可以节省内存开销。</p>
<blockquote>
<p>Note：当然，如果我们可以使用PagerAdapter来完成少许图片资源的展示，毕竟我们的优化是为了节省内存开销。</p>
</blockquote>
<p>下面实例展示了带有ImageView的ViewPager，在主activity持有ViewPager和它的适配器。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageDetailActivity</span> <span class="keyword">extends</span> <span class="title">FragmentActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXTRA_IMAGE = <span class="string">&quot;extra_image&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ImagePagerAdapter mAdapter;</span><br><span class="line">    <span class="keyword">private</span> ViewPager mPager;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A static dataset to back the ViewPager adapter</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> Integer[] imageResIds = <span class="keyword">new</span> Integer[] &#123;</span><br><span class="line">            R.drawable.sample_image_1, R.drawable.sample_image_2, R.drawable.sample_image_3,</span><br><span class="line">            R.drawable.sample_image_4, R.drawable.sample_image_5, R.drawable.sample_image_6,</span><br><span class="line">            R.drawable.sample_image_7, R.drawable.sample_image_8, R.drawable.sample_image_9&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.image_detail_pager); <span class="comment">// Contains just a ViewPager</span></span><br><span class="line"></span><br><span class="line">        mAdapter = <span class="keyword">new</span> ImagePagerAdapter(getSupportFragmentManager(), imageResIds.length);</span><br><span class="line">        mPager = (ViewPager) findViewById(R.id.pager);</span><br><span class="line">        mPager.setAdapter(mAdapter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ImagePagerAdapter</span> <span class="keyword">extends</span> <span class="title">FragmentStatePagerAdapter</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> mSize;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ImagePagerAdapter</span><span class="params">(FragmentManager fm, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(fm);</span><br><span class="line">            mSize = size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mSize;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Fragment <span class="title">getItem</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ImageDetailFragment.newInstance(position);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在适配器的getItem中使用了自定义的Fragment，它持有ImageView，并负责完成展示</p>
<h2 id="看上去已经大功告成-了但事实真的如此吗"><a href="#看上去已经大功告成-了，但事实真的如此吗？" class="headerlink" title="看上去已经大功告成 了，但事实真的如此吗？"></a>看上去已经大功告成 了，但事实真的如此吗？<a href="#看上去已经大功告成-了但事实真的如此吗" class="header-anchor">#</a></h2><p>下面是ImageDetailFragment的细节，通过ImageDetailFragment，看上去已经大功告成 了，但事实真的如此吗？</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageDetailFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String IMAGE_DATA_EXTRA = <span class="string">&quot;resId&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mImageNum;</span><br><span class="line">    <span class="keyword">private</span> ImageView mImageView;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> ImageDetailFragment <span class="title">newInstance</span><span class="params">(<span class="keyword">int</span> imageNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ImageDetailFragment f = <span class="keyword">new</span> ImageDetailFragment();</span><br><span class="line">        <span class="keyword">final</span> Bundle args = <span class="keyword">new</span> Bundle();</span><br><span class="line">        args.putInt(IMAGE_DATA_EXTRA, imageNum);</span><br><span class="line">        f.setArguments(args);</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Empty constructor, required as per Fragment docs</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ImageDetailFragment</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        mImageNum = getArguments() != <span class="keyword">null</span> ? getArguments().getInt(IMAGE_DATA_EXTRA) : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(LayoutInflater inflater, ViewGroup container,</span></span></span><br><span class="line"><span class="function"><span class="params">            Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// image_detail_fragment.xml contains just an ImageView</span></span><br><span class="line">        <span class="keyword">final</span> View v = inflater.inflate(R.layout.image_detail_fragment, container, <span class="keyword">false</span>);</span><br><span class="line">        mImageView = (ImageView) v.findViewById(R.id.imageView);</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityCreated</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onActivityCreated(savedInstanceState);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> resId = ImageDetailActivity.imageResIds[mImageNum];</span><br><span class="line">        mImageView.setImageResource(resId); <span class="comment">//为ImageView设置图片</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<blockquote>
<p>阅读一段代码，除了学习外，还要思考它有什么缺点，如果是我，我该如何提高。</p>
</blockquote>
<p>希望你能注意到这些问题，上述代码是在UI线程中加载的，可能会导致我们开发的应用长时间无响应而被迫挂掉。所以，请使用AsyncTask开启子线程来加载图片：</p>
<blockquote>
<p>在阅读这段代码之前，请首先阅读上一篇博文 内存优化中的AsyncTsak部分</p>
</blockquote>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageDetailActivity</span> <span class="keyword">extends</span> <span class="title">FragmentActivity</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadBitmap</span><span class="params">(<span class="keyword">int</span> resId, ImageView imageView)</span> </span>&#123;</span><br><span class="line">        mImageView.setImageResource(R.drawable.image_placeholder);</span><br><span class="line">        BitmapWorkerTask task = <span class="keyword">new</span> BitmapWorkerTask(mImageView);</span><br><span class="line">        task.execute(resId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ... <span class="comment">// include BitmapWorkerTask class，</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageDetailFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityCreated</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onActivityCreated(savedInstanceState);</span><br><span class="line">        <span class="keyword">if</span> (ImageDetailActivity.class.isInstance(getActivity())) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> resId = ImageDetailActivity.imageResIds[mImageNum];</span><br><span class="line">            <span class="comment">// 使用子线程来加载图片</span></span><br><span class="line">            ((ImageDetailActivity) getActivity()).loadBitmap(resId, mImageView);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<blockquote>
<p> 请至少阅读完上一篇内存优化的LruCache部分才能保证你理解这里</p>
</blockquote>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageDetailActivity</span> <span class="keyword">extends</span> <span class="title">FragmentActivity</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> LruCache&lt;String, Bitmap&gt; mMemoryCache;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// initialize LruCache</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadBitmap</span><span class="params">(<span class="keyword">int</span> resId, ImageView imageView)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String imageKey = String.valueOf(resId);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Bitmap bitmap = mMemoryCache.get(imageKey);</span><br><span class="line">        <span class="keyword">if</span> (bitmap != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mImageView.setImageBitmap(bitmap);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mImageView.setImageResource(R.drawable.image_placeholder);</span><br><span class="line">            BitmapWorkerTask task = <span class="keyword">new</span> BitmapWorkerTask(mImageView);</span><br><span class="line">            task.execute(resId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ... <span class="comment">// include updated BitmapWorkerTask </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<blockquote>
<p>注意，只有阅读完上一篇内存优化中的Lrucache部分和AsyncTask部分才能保证你完全读懂上述代码</p>
</blockquote>
<h1 id="recyclerviewgridviewlistview"><a href="#RecyclerView，GridView，ListView" class="headerlink" title="RecyclerView，GridView，ListView"></a>RecyclerView，GridView，ListView<a href="#recyclerviewgridviewlistview" class="header-anchor">#</a></h1><p>下面可能是大家经常的做法：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageGridFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> <span class="keyword">implements</span> <span class="title">AdapterView</span>.<span class="title">OnItemClickListener</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ImageAdapter mAdapter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A static dataset to back the GridView adapter</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> Integer[] imageResIds = <span class="keyword">new</span> Integer[] &#123;</span><br><span class="line">            R.drawable.sample_image_1, R.drawable.sample_image_2, R.drawable.sample_image_3,</span><br><span class="line">            R.drawable.sample_image_4, R.drawable.sample_image_5, R.drawable.sample_image_6,</span><br><span class="line">            R.drawable.sample_image_7, R.drawable.sample_image_8, R.drawable.sample_image_9&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Empty constructor as per Fragment docs</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ImageGridFragment</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        mAdapter = <span class="keyword">new</span> ImageAdapter(getActivity());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> View v = inflater.inflate(R.layout.image_grid_fragment, container, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">final</span> GridView mGridView = (GridView) v.findViewById(R.id.gridView);</span><br><span class="line">        mGridView.setAdapter(mAdapter);</span><br><span class="line">        mGridView.setOnItemClickListener(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onItemClick</span><span class="params">(AdapterView&lt;?&gt; parent, View v, <span class="keyword">int</span> position, <span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Intent i = <span class="keyword">new</span> Intent(getActivity(), ImageDetailActivity.class);</span><br><span class="line">        i.putExtra(ImageDetailActivity.EXTRA_IMAGE, position);</span><br><span class="line">        startActivity(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageAdapter</span> <span class="keyword">extends</span> <span class="title">BaseAdapter</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Context mContext;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ImageAdapter</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>();</span><br><span class="line">            mContext = context;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> imageResIds.length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">getItem</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> imageResIds[position];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getItemId</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> position;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> View <span class="title">getView</span><span class="params">(<span class="keyword">int</span> position, View convertView, ViewGroup container)</span> </span>&#123;</span><br><span class="line">            ImageView imageView;</span><br><span class="line">            <span class="keyword">if</span> (convertView == <span class="keyword">null</span>) &#123; <span class="comment">// if it&#x27;s not recycled, initialize some attributes</span></span><br><span class="line">                imageView = <span class="keyword">new</span> ImageView(mContext);</span><br><span class="line">                imageView.setScaleType(ImageView.ScaleType.CENTER_CROP);</span><br><span class="line">                imageView.setLayoutParams(<span class="keyword">new</span> GridView.LayoutParams(</span><br><span class="line">                        LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                imageView = (ImageView) convertView;</span><br><span class="line">            &#125;</span><br><span class="line">            imageView.setImageResource(imageResIds[position]); <span class="comment">// Load image into ImageView</span></span><br><span class="line">            <span class="keyword">return</span> imageView;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>看上去非常棒，对吗？但是我们如何才能做的更好？</p>
<p>如果你能发现主线程加载图片的问题，恭喜你，有一点点进步。但是重复提醒你使用AsyncTask，显然不是我写这一节的目的。</p>
<p>我们还需要警惕GridView 中的<strong>并发</strong>问题，因为iGridView 会回收子View的内存空间。</p>
<h2 id="并发问题"><a href="#并发问题" class="headerlink" title="并发问题"></a>并发问题<a href="#并发问题" class="header-anchor">#</a></h2><p>像ListView和GridView，与RecyclerView使用AsyncTask的时候，不能忽视一个问题：Android系统为了高效分配内存，这些组件都会在上下滑动的时候回收子view的内存。在滑动的时候，并不能保证AsyncTask可以完成当前任务。此外，也不能保证异步任务可以按照顺序完成。</p>
<p>Google在<a href="http://android-developers.blogspot.com/2010/07/multithreading-for-performance.html%20%20%20%20%20%E2%80%9C%20Multithreading%20for%20Performance%E2%80%9D"> Multithreading for Performance</a> 提供了建议：在AsyncTask中，用弱引用来存储ImageView，通过使用弱引用来被检查ImageView是否加载完成</p>
<p>好吧，理论上是这样，我们开始行动：</p>
<ol>
<li><strong>自定义Drawable去存储异步任务重的弱引用，只有这样，才能保证task执行完毕之后，ImageView才会显示图片</strong></li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncDrawable</span> <span class="keyword">extends</span> <span class="title">BitmapDrawable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WeakReference&lt;BitmapWorkerTask&gt; bitmapWorkerTaskReference;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AsyncDrawable</span><span class="params">(Resources res, Bitmap bitmap,</span></span></span><br><span class="line"><span class="function"><span class="params">            BitmapWorkerTask bitmapWorkerTask)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(res, bitmap);</span><br><span class="line">        bitmapWorkerTaskReference =</span><br><span class="line">            <span class="keyword">new</span> WeakReference&lt;BitmapWorkerTask&gt;(bitmapWorkerTask);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BitmapWorkerTask <span class="title">getBitmapWorkerTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bitmapWorkerTaskReference.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<ol start="2">
<li> <strong>在执行BitmapWorkerTask之前，你需要创建 AsyncDrawable 并且绑定到ImageView上，通过如下代码：</strong></li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadBitmap</span><span class="params">(<span class="keyword">int</span> resId, ImageView imageView)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cancelPotentialWork(resId, imageView)) &#123;</span><br><span class="line">        <span class="keyword">final</span> BitmapWorkerTask task = <span class="keyword">new</span> BitmapWorkerTask(imageView);</span><br><span class="line">        <span class="keyword">final</span> AsyncDrawable asyncDrawable =</span><br><span class="line">                <span class="keyword">new</span> AsyncDrawable(getResources(), mPlaceHolderBitmap, task);</span><br><span class="line">        imageView.setImageDrawable(asyncDrawable);</span><br><span class="line">        task.execute(resId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<ol start="3">
<li><p><strong>仅仅这些代码还是不够的，Google 还引入 cancelPotentialWork（）来检查是否有其他的task任务在使用当前ImageView，如果有，就会取消当前任务，取消这个做法是不是很让人眼前一亮呢！</strong></p>
<p>这是cancelPotentialWork（）的实现</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">cancelPotentialWork</span><span class="params">(<span class="keyword">int</span> data, ImageView imageView)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> BitmapWorkerTask bitmapWorkerTask = getBitmapWorkerTask(imageView);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bitmapWorkerTask != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> bitmapData = bitmapWorkerTask.data;</span><br><span class="line">        <span class="comment">// If bitmapData is not yet set or it differs from the new data</span></span><br><span class="line">        <span class="keyword">if</span> (bitmapData == <span class="number">0</span> || bitmapData != data) &#123;</span><br><span class="line">            <span class="comment">// Cancel previous task</span></span><br><span class="line">            bitmapWorkerTask.cancel(<span class="keyword">true</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// The same work is already in progress</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// No task associated with the ImageView, or an existing task was cancelled</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li><p><strong>我们还需要get方法获得相关的ImageView</strong></p>
</li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> BitmapWorkerTask <span class="title">getBitmapWorkerTask</span><span class="params">(ImageView imageView)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (imageView != <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="keyword">final</span> Drawable drawable = imageView.getDrawable();</span><br><span class="line">       <span class="keyword">if</span> (drawable <span class="keyword">instanceof</span> AsyncDrawable) &#123;</span><br><span class="line">           <span class="keyword">final</span> AsyncDrawable asyncDrawable = (AsyncDrawable) drawable;</span><br><span class="line">           <span class="keyword">return</span> asyncDrawable.getBitmapWorkerTask();</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<ol start="5">
<li><strong>最后就是更新task中的onPostExecute（）检查任务是否取消，</strong></li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BitmapWorkerTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">Integer</span>, <span class="title">Void</span>, <span class="title">Bitmap</span>&gt; </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(Bitmap bitmap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isCancelled()) &#123;</span><br><span class="line">            bitmap = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (imageViewReference != <span class="keyword">null</span> &amp;&amp; bitmap != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> ImageView imageView = imageViewReference.get();</span><br><span class="line">            <span class="keyword">final</span> BitmapWorkerTask bitmapWorkerTask =</span><br><span class="line">                    getBitmapWorkerTask(imageView);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span> == bitmapWorkerTask &amp;&amp; imageView != <span class="keyword">null</span>) &#123;</span><br><span class="line">                imageView.setImageBitmap(bitmap);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>至此，我们已经了解Google 对于并发加载的解决方案，只需要在getView（）实现它们就可以啦！</p>
<h2 id="在gridview解决并发"><a href="#在GridView解决并发" class="headerlink" title="在GridView解决并发"></a>在GridView解决并发<a href="#在gridview解决并发" class="header-anchor">#</a></h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageGridFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> <span class="keyword">implements</span> <span class="title">AdapterView</span>.<span class="title">OnItemClickListener</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageAdapter</span> <span class="keyword">extends</span> <span class="title">BaseAdapter</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> View <span class="title">getView</span><span class="params">(<span class="keyword">int</span> position, View convertView, ViewGroup container)</span> </span>&#123;</span><br><span class="line">            ...</span><br><span class="line">            loadBitmap(imageResIds[position], imageView)</span><br><span class="line">            <span class="keyword">return</span> imageView;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadBitmap</span><span class="params">(<span class="keyword">int</span> resId, ImageView imageView)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cancelPotentialWork(resId, imageView)) &#123;</span><br><span class="line">            <span class="keyword">final</span> BitmapWorkerTask task = <span class="keyword">new</span> BitmapWorkerTask(imageView);</span><br><span class="line">            <span class="keyword">final</span> AsyncDrawable asyncDrawable =</span><br><span class="line">                    <span class="keyword">new</span> AsyncDrawable(getResources(), mPlaceHolderBitmap, task);</span><br><span class="line">            imageView.setImageDrawable(asyncDrawable);</span><br><span class="line">            task.execute(resId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncDrawable</span> <span class="keyword">extends</span> <span class="title">BitmapDrawable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> WeakReference&lt;BitmapWorkerTask&gt; bitmapWorkerTaskReference;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">AsyncDrawable</span><span class="params">(Resources res, Bitmap bitmap,</span></span></span><br><span class="line"><span class="function"><span class="params">                BitmapWorkerTask bitmapWorkerTask)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(res, bitmap);</span><br><span class="line">            bitmapWorkerTaskReference =</span><br><span class="line">                <span class="keyword">new</span> WeakReference&lt;BitmapWorkerTask&gt;(bitmapWorkerTask);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> BitmapWorkerTask <span class="title">getBitmapWorkerTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> bitmapWorkerTaskReference.get();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">cancelPotentialWork</span><span class="params">(<span class="keyword">int</span> data, ImageView imageView)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> BitmapWorkerTask bitmapWorkerTask = getBitmapWorkerTask(imageView);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bitmapWorkerTask != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> bitmapData = bitmapWorkerTask.data;</span><br><span class="line">            <span class="keyword">if</span> (bitmapData != data) &#123;</span><br><span class="line">                <span class="comment">// Cancel previous task</span></span><br><span class="line">                bitmapWorkerTask.cancel(<span class="keyword">true</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// The same work is already in progress</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// No task associated with the ImageView, or an existing task was cancelled</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> BitmapWorkerTask <span class="title">getBitmapWorkerTask</span><span class="params">(ImageView imageView)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (imageView != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">final</span> Drawable drawable = imageView.getDrawable();</span><br><span class="line">           <span class="keyword">if</span> (drawable <span class="keyword">instanceof</span> AsyncDrawable) &#123;</span><br><span class="line">               <span class="keyword">final</span> AsyncDrawable asyncDrawable = (AsyncDrawable) drawable;</span><br><span class="line">               <span class="keyword">return</span> asyncDrawable.getBitmapWorkerTask();</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ... <span class="comment">// include updated BitmapWorkerTask class</span></span><br></pre></td></tr></table></figure></div>
<blockquote>
<p>这样解决并发的办法，同理适用于ListView， Recycler<br>这也是热门加载框架ImageLoader，Volley  的加载原理。原理还是Google提出的！</p>
</blockquote>
<p>这样就可以流畅的展示图片。</p>
<h2 id="view-holder设计模式"><a href="#View-Holder设计模式" class="headerlink" title="View Holder设计模式"></a>View Holder设计模式<a href="#view-holder设计模式" class="header-anchor">#</a></h2><p>我们的代码可能会调用findViewById（），尤其是当滑动ListView，RecyclerView，GridView的时候，会使得app性能变得糟糕。甚至Adapter会返回一个已经被Android系统回收的View，可是你仍然需要初始化加载这个view并刷新它。</p>
<p>Google提出了使用 “View Holder” 设计模式</p>
<p><strong>1. 首先创建 ViewHolder类，存储子View内部所有需要展示的布局</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewHolder</span> </span>&#123;</span><br><span class="line">  TextView text;</span><br><span class="line">  TextView timestamp;</span><br><span class="line">  ImageView icon;</span><br><span class="line">  ProgressBar progress;</span><br><span class="line">  <span class="keyword">int</span> position;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>2.  接着填充ViewHolder并且存储到布局中</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line">ViewHolder holder = <span class="keyword">new</span> ViewHolder();</span><br><span class="line">holder.icon = (ImageView) convertView.findViewById(R.id.listitem_image);</span><br><span class="line">holder.text = (TextView) convertView.findViewById(R.id.listitem_text);</span><br><span class="line">holder.timestamp = (TextView) convertView.findViewById(R.id.listitem_timestamp);</span><br><span class="line">holder.progress = (ProgressBar) convertView.findViewById(R.id.progress_spinner);</span><br><span class="line">convertView.setTag(holder);</span><br></pre></td></tr></table></figure></div>
<blockquote>
<p>‘view holder’ 设计模式同样也适用于ListView，RecyclerView，GridView</p>
</blockquote>
<hr>
<h1 id="有趣的是"><a href="#有趣的是" class="headerlink" title="有趣的是"></a>有趣的是<a href="#有趣的是" class="header-anchor">#</a></h1><p>当我通宵赶完这篇博客的时候，我的计算机也提醒我内存不足了 (●’◡’●)</p>
<img src="http://cdn.yangchaofan.cn/gc9.png">



<h1 id="写本文所参考的"><a href="#写本文所参考的：" class="headerlink" title="写本文所参考的："></a>写本文所参考的：<a href="#写本文所参考的" class="header-anchor">#</a></h1><ol>
<li><a href="http://blog.csdn.net/testcs_dn/article/details/45719357">Markdown字体颜色写法</a></li>
<li><a href="https://classroom.udacity.com/courses/ud825/lessons">Google 官方 Android Performance 课程</a></li>
<li><a href="https://developer.android.com/training/building-graphics.html">Google 官方 Android  Diplaying  Bitmaps Efficiently 课程</a></li>
<li><a href="https://developer.android.com/training/articles/memory.html">Managing Your App’s Memory</a></li>
<li><a href="https://developer.android.com/training/displaying-bitmaps/process-bitmap.html#concurrency">Google 官方 Processing Bitmaps Off the UI Thread课程</a> </li>
<li><a href="https://developer.android.com/training/displaying-bitmaps/process-bitmap.html#concurrency"> Multithreading for Performance </a></li>
</ol>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明<a href="#说明" class="header-anchor">#</a></h1><p>后续会更新</p>
<ul>
<li> Google官方提供的ListView，RecyclerView的优化方案以及</li>
<li> Android内存管理机制</li>
<li> JVM内存管理机制</li>
</ul>
<link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>Android</category>
        <category>应用层</category>
        <category>Performance</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Performance</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 百大框架排行榜</title>
    <url>/blog//2016/04/Android-TOP-100-Program/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote>
<p>说明：无聊之时作的一篇笔记式文章，</p>
<p>精力有限，很多错误之处，受时间与能力限制，没能及时修改，隐隐懊悔，<br>受读者启发，遂将此文公之于众，旨在号召大家共同编辑、共同参与，让此排行榜帮助更多的Android开发者。</p>
<p>读者参与方式：<br>1.在博客原文站点进行评论，提出对文章内容的修改意见，请务必描述准确。<br>2.使用Github的Pull requests，clone本地-&gt;重新编辑-&gt;提交。请务必核查准确。<br>3.提Issues，我每周末会统一解决Issues（这种会影响关注者的时间线，最末推荐）。</p>
<div id="cnblogs_post_body">

<p><a href="https://github.com/ShaunSheep/Android_100_TOP-Projects">文本文Gihutb项目地址</a></p>
</div></blockquote>
<h1 id="框架提供一定能力的小段程序"><a href="#框架：提供一定能力的小段程序" class="headerlink" title=" 框架：提供一定能力的小段程序"></a><span style="font-family: 宋体; background-color: #ff9900"> 框架：提供一定能力的小段程序</span><a href="#框架提供一定能力的小段程序" class="header-anchor">#</a></h1><h1 id="一榜单介绍"><a href="#一-榜单介绍" class="headerlink" title="一.榜单介绍"></a>一.榜单介绍<a href="#一榜单介绍" class="header-anchor">#</a></h1><p><span style="font-size: 15px">排行榜包括四大类：</span></p>
<p><span style="font-size: 15px">单一框架：仅提供路由、网络层、UI层、通信层或其他<strong>单一功能</strong>的框架</span></p>
<p><span style="font-size: 15px">混合开发框架：提供开发<strong>hybrid app、h5与webview结合能力、web app能力</strong>的框架</span></p>
<p><span style="font-size: 15px">企业级开源项目：可以独立运行的app，有极高的学习价值、思路借鉴意义</span></p>
<p><span style="font-size: 15px">书籍类开源项目：类似Open-sourc-project这样的导航类项目；大型公司的Android课程的学习目录 tips</span></p>
<p><span style="font-size: 16px; font-family: 宋体">榜单排序依据：</span></p>
<p><span style="font-size: 15px">1.项目开源</span></p>
<p><span style="font-size: 15px">2.github上该项目的star个数</span></p>
<p><span style="font-size: 15px">3.开发团队、作者的实力</span></p>
<p>为了保证榜单内容的多样性，榜单上尽可能的不重复同类型框架（比如多款listview增强框架）</p>
<p><span style="font-family: 黑体; font-size: 18px">适用读者范围：</span></p>
<ul>
<li>  <span style="font-size: 16px">正在入门Android的新手~~~Android初级开发工程师  初出茅庐</span></li>
</ul>
<p>　<span style="font-size: 15px">　<strong>熟读</strong>《书籍导航类项目排行榜》，勤加练习进步会更大；<strong>编译运行并动脑思考</strong>《企业级开源项目》中的案例，可以提升开发完整项目的能力；;<strong>略读</strong>《框架百大排行榜》，最大的作用是的是拓展视野，可以看到很多时下流行的名词概念术语</span></p>
<ul>
<li>  <span style="font-size: 16px">Android初级开发工程师~~~中级开发工程师    知其然知其所以然</span></li>
</ul>
<p>　<span style="font-size: 15px">　熟练、快速、高效的默写出《企业级开源项目》中的（自己感兴趣）典型案例，对提高书写代码的自信，提升项目功能整体设计能力；深究《框架百大排行榜》排名靠前框架的<strong>原理</strong>，会让自己在与家人、同事、同学聚会之时多了一些炫耀的资本；如果你能熟练运用《框架百大排行榜》里所提到的框架，在遇到某种需求的时候，立刻会拿出<strong>“最优秀的框架”</strong>去解决，意味着你离中级工程师不太远了</span></p>
<ul>
<li>  <span style="font-size: 16px">中级、高级、资深工程师   知其然知其不可然</span></li>
</ul>
<p><span style="font-size: 15px">　　　《框架百大排行榜》里所提到的流行词、流行术语——使用能力、融会贯通其原理、讲解框架能力的高低，将让你不断的在这三个级别徘徊；</span></p>
<p><span style="font-size: 15px">　　　会有意识的合并榜单里多款同类型框架，来弥补单一框架的某些缺陷，比如将同为网络请求框架的Volley和Okhttp封装到一起应对不同场面的需求；</span></p>
<p><span style="font-size: 15px">　　　会有意识的二次开发、修改源码来扩展榜单所提到的大型框架；</span></p>
<p><span style="font-size: 15px">　　　能够在开发团队里推动、部署某些框架的能力——比如要在一个新加入的陌生团队说服leader和项目成员使用热更新、插件化、组件化、hybrid 开发等多种开发模式，你是否有这个实力?</span></p>
<p><span style="font-size: 15px">　　</span></p>
<p> <span style="font-size: 16px">框架名次越靠前，值得使用的优先级就越高、研究原理得到的收获会更多、对读者启发的价值就越大</span></p>
<h1 id="二百大框架排行榜"><a href="#二-百大框架排行榜" class="headerlink" title="二.百大框架排行榜"></a>二.百大框架排行榜<a href="#二百大框架排行榜" class="header-anchor">#</a></h1><p>快速索引</p>
<table>
<thead>
<tr>
<th>框架名称</th>
<th>上榜关键字</th>
</tr>
</thead>
<tbody><tr>
<td>1.Retrofit</td>
<td>网络</td>
</tr>
<tr>
<td>2.okhttp</td>
<td>网络</td>
</tr>
<tr>
<td>3.Butter Knife</td>
<td>代码模板</td>
</tr>
<tr>
<td>4.MPAndroidChart</td>
<td>图表</td>
</tr>
<tr>
<td>5.Glide</td>
<td>图片</td>
</tr>
<tr>
<td>6.leakcanary</td>
<td>内存</td>
</tr>
<tr>
<td>7.Android-Universal-Image-Loader</td>
<td>图片</td>
</tr>
<tr>
<td>8.EventBus</td>
<td>事件消息</td>
</tr>
<tr>
<td>9.zxing</td>
<td>条码扫描</td>
</tr>
<tr>
<td>10.picasso</td>
<td>图片</td>
</tr>
<tr>
<td>11.lottie-android</td>
<td>动画</td>
</tr>
<tr>
<td>12.fresco</td>
<td>图片</td>
</tr>
<tr>
<td>13.RxAndroid</td>
<td>异步</td>
</tr>
<tr>
<td>14.SlidingMenu</td>
<td>菜单</td>
</tr>
<tr>
<td>15.PhotoView</td>
<td>图片</td>
</tr>
<tr>
<td>16.material-dialogs</td>
<td>UI</td>
</tr>
<tr>
<td>17.android-async-http</td>
<td>网络</td>
</tr>
<tr>
<td>18.androidannotations</td>
<td>注解</td>
</tr>
<tr>
<td>19.fastjson</td>
<td>json</td>
</tr>
<tr>
<td>20.Material-Animations</td>
<td>动画</td>
</tr>
<tr>
<td>21.tinker</td>
<td>热修复</td>
</tr>
<tr>
<td>22.ViewPagerIndicator</td>
<td>UI</td>
</tr>
<tr>
<td>23.Android-CleanArchitecture</td>
<td>架构</td>
</tr>
<tr>
<td>24.Android-PullToRefresh</td>
<td>刷新</td>
</tr>
<tr>
<td>25.flexbox-layout</td>
<td>UI</td>
</tr>
<tr>
<td>26.AndroidSwipeLayout</td>
<td>UI</td>
</tr>
<tr>
<td>27.realm-java</td>
<td>数据库</td>
</tr>
<tr>
<td>28.greenDAO</td>
<td>数据</td>
</tr>
<tr>
<td>29.stetho</td>
<td>调试</td>
</tr>
<tr>
<td>30.BaseRecyclerViewAdapterHelper</td>
<td>UI</td>
</tr>
<tr>
<td>31.AndroidViewAnimations</td>
<td>动画</td>
</tr>
<tr>
<td>32.MaterialDrawer</td>
<td>菜单</td>
</tr>
<tr>
<td>33.Android-ObservableScrollView</td>
<td>UI</td>
</tr>
<tr>
<td>34.CircleImageView</td>
<td>图片</td>
</tr>
<tr>
<td>35.logger</td>
<td>调试</td>
</tr>
<tr>
<td>32.MaterialDrawer</td>
<td>菜单</td>
</tr>
<tr>
<td>36.agera</td>
<td>异步</td>
</tr>
<tr>
<td>37.BottomBar</td>
<td>菜单</td>
</tr>
<tr>
<td>38.Calligraphy</td>
<td>字体</td>
</tr>
<tr>
<td>39.AndroidSlidingUpPanel</td>
<td>UI</td>
</tr>
<tr>
<td>40.AppIntro</td>
<td>UI</td>
</tr>
<tr>
<td>41.recyclerview-animators</td>
<td>动画</td>
</tr>
<tr>
<td>42.dagger</td>
<td>依赖注入</td>
</tr>
<tr>
<td>43.Android-Bootstrap</td>
<td>UI</td>
</tr>
<tr>
<td>44.RxBinding</td>
<td>响应式</td>
</tr>
<tr>
<td>45.ListViewAnimations</td>
<td>动画</td>
</tr>
<tr>
<td>46.UItimateRecyclerView</td>
<td>图片</td>
</tr>
<tr>
<td>47.uCrop</td>
<td>UI</td>
</tr>
<tr>
<td>48.RxJava-Android-Samples</td>
<td>用例</td>
</tr>
<tr>
<td>49.AndroidAutoLayout</td>
<td>适配</td>
</tr>
<tr>
<td>50.EffectiveAndroidUI</td>
<td>性能</td>
</tr>
<tr>
<td>51.Luban</td>
<td>图片</td>
</tr>
<tr>
<td>52.DroidPlugin</td>
<td>插件化</td>
</tr>
<tr>
<td>53.otto</td>
<td>响应式</td>
</tr>
<tr>
<td>54.u2020</td>
<td>用例</td>
</tr>
<tr>
<td>55.buck</td>
<td>构建</td>
</tr>
<tr>
<td>56.PermissionsDispatcher</td>
<td>权限</td>
</tr>
<tr>
<td>57.android-gif-drawable</td>
<td>GIF</td>
</tr>
<tr>
<td>58.Apktool</td>
<td>反编译</td>
</tr>
<tr>
<td>59.dynamic-load-apk</td>
<td>插件化</td>
</tr>
<tr>
<td>60.atlas</td>
<td>插件化</td>
</tr>
<tr>
<td>61.volley</td>
<td>网络</td>
</tr>
<tr>
<td>62.androidmvp</td>
<td>用例</td>
</tr>
<tr>
<td>63.SwipeBackLayout</td>
<td>手势</td>
</tr>
<tr>
<td>64.FlycoTabLayout</td>
<td>UI</td>
</tr>
<tr>
<td>65.android-testing</td>
<td>测试</td>
</tr>
<tr>
<td>66.FileDownloader</td>
<td>下载</td>
</tr>
<tr>
<td>67.JieCaoVideoPlayer</td>
<td>多媒体</td>
</tr>
<tr>
<td>68.glide-transformations</td>
<td>图片</td>
</tr>
<tr>
<td>69.android-gpuimage</td>
<td>图片</td>
</tr>
<tr>
<td>70.RxPermissions</td>
<td>权限</td>
</tr>
<tr>
<td>71.freeline</td>
<td>编译</td>
</tr>
<tr>
<td>72.RxLifecycle</td>
<td>生命周期</td>
</tr>
<tr>
<td>73.classyshark</td>
<td>反编译</td>
</tr>
<tr>
<td>74.acra</td>
<td>崩溃日志</td>
</tr>
<tr>
<td>75.DiskLruCache</td>
<td>文件</td>
</tr>
<tr>
<td>76.dexposed</td>
<td>热修复</td>
</tr>
<tr>
<td>77.Litho</td>
<td>性能</td>
</tr>
<tr>
<td>78.mosby</td>
<td>MVP</td>
</tr>
<tr>
<td>79.AndResGuard</td>
<td>混淆</td>
</tr>
<tr>
<td>80.StatusBarUtil</td>
<td>状态栏</td>
</tr>
<tr>
<td>81.robolectric</td>
<td>测试</td>
</tr>
<tr>
<td>82.Fragmentation</td>
<td>嵌套</td>
</tr>
<tr>
<td>83.Small</td>
<td>插件化</td>
</tr>
<tr>
<td>84.JsBridge</td>
<td>hybrid</td>
</tr>
<tr>
<td>85.richeditor-android</td>
<td>UI</td>
</tr>
<tr>
<td>86.Transitions-Everywhere</td>
<td>动画</td>
</tr>
<tr>
<td>87.android-viewbadger</td>
<td>勋章</td>
</tr>
<tr>
<td>88.AndroidWiFiADB</td>
<td>调试</td>
</tr>
<tr>
<td>89.emojicon</td>
<td>表情包</td>
</tr>
<tr>
<td>90.packer-ng-plugin</td>
<td>多渠道</td>
</tr>
<tr>
<td>91.android-priority-jobqueue</td>
<td>多线程</td>
</tr>
<tr>
<td>92.Android-Debug-Database</td>
<td>调试</td>
</tr>
<tr>
<td>93.conceal</td>
<td>加密</td>
</tr>
<tr>
<td>94.ARouter</td>
<td>页面路由</td>
</tr>
<tr>
<td>95.MagicaSakura</td>
<td>多主题</td>
</tr>
<tr>
<td>96.CustomActivityOnCrash</td>
<td>崩溃</td>
</tr>
<tr>
<td>97.XhsEmoticonsKeyboard</td>
<td>键盘</td>
</tr>
<tr>
<td>98.Android Debug Database</td>
<td>数据库调试</td>
</tr>
</tbody></table>
<h2 id="1-retrofit"><a href="#1-Retrofit" class="headerlink" title="1. Retrofit"></a>1. Retrofit<a href="#1-retrofit" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：Retrofit是一款类型安全的网络框架，基于HTTP协议，服务于Android和java语言</span></p>
<p><span style="font-size: 15px">上榜理由：Retrofit以21.8k的stars量雄踞github中android子标题榜首，第一当之无愧。</span></p>
<p><span style="font-size: 15px">官网地址 <a href="http://square.github.io/retrofit/">http://square.github.io/retrofit/</a></span></p>
<p><span style="font-size: 15px">github  <a target="_blank"> https://github.com/square/retrofit</a></span></p>
<p><span style="font-size: 15px">作者：square团队</span></p>
<p><span style="font-size: 15px">使用：</span></p>
<div class="cnblogs_code">

<pre>compile <span style="color: #800000">'</span><span style="color: #800000">com.squareup.retrofit2:retrofit:2.3.0</span><span style="color: #800000">'</span></pre>

</div>

<h2 id="2okhttp"><a href="#2-okhttp" class="headerlink" title="2.okhttp"></a>2.okhttp<a href="#2okhttp" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：okhttp是一款基于HTTP和HTTP2.0协议的网络框架，服务于java和android客户端</span></p>
<p><span style="font-size: 15px">上榜理由，okhttp以20.4k的stars量雄踞github中android子标题第二名。大型公司比如淘宝也封装的是okhttp。Retrofit2.0开始内置okhttp框架，Retrofit专注封装接口完成业务需求，okhttp专注网络请求的安全高效，笔者将两者区分开，是想让后来学习者知道，这是两套框架，学习框架原理时可以分开学习，以免理解混乱。</span></p>
<p><span style="font-size: 15px">官网地址   <a href="https://github.com/JakeWharton/butterknife">http://square.github.io/okhttp/</a></span></p>
<p><span style="font-size: 15px">github    <a href="https://github.com/square/okhttp">https://github.com/square/okhttp</a></span></p>
<p><span style="font-size: 15px">作者：square团队</span></p>
<p><span style="font-size: 15px">使用：</span></p>
<div class="cnblogs_code">

<pre>compile <span style="color: #800000">'</span><span style="color: #800000">com.squareup.okhttp3:okhttp:3.8.0</span><span style="color: #800000">'</span></pre>

</div>

<h2 id="3butter-knife"><a href="#3-Butter-Knife" class="headerlink" title="3.Butter Knife"></a>3.Butter Knife<a href="#3butter-knife" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：Butter Knife所提供了一种能力——使用注解生成模板代码，将view与方法和参数绑定。</span></p>
<p><span style="font-size: 15px">上榜理由：github上16.5K个star，配合Androidstudio提供的Butter Knife插件，帮助开发者省却了频繁findviewbyid的烦恼，最新的Butter Knife还提供了onclick绑定以及字符串的初始化，初学者可以查阅Butter Knife以及Butter Knife插件进一步学习！</span></p>
<p><span style="font-size: 15px">官网地址：<a href="http://jakewharton.github.io/butterknife/">http://jakewharton.github.io/butterknife/</a></span></p>
<p><span style="font-size: 15px">github：<a href="https://github.com/JakeWharton/butterknife">https://github.com/JakeWharton/butterknife</a></span></p>
<p><span style="font-size: 15px">作者：JakeWharton ，也是square团队成员之一</span></p>
<p><span style="font-size: 15px">使用：</span></p>
<div class="cnblogs_code">

<pre><span style="color: #000000">dependencies {
  compile</span> <span style="color: #800000">'</span><span style="color: #800000">com.jakewharton:butterknife:8.6.0</span><span style="color: #800000">'</span> <span style="color: #000000">annotationProcessor</span> <span style="color: #800000">'</span><span style="color: #800000">com.jakewharton:butterknife-compiler:8.6.0</span><span style="color: #800000">'</span> <span style="color: #000000">}</span></pre>

</div>

<h2 id="4mpandroidchart"><a href="#4-MPAndroidChart" class="headerlink" title="4.MPAndroidChart"></a>4.MPAndroidChart<a href="#4mpandroidchart" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：MPAndroidChart是一款图表框架</span></p>
<p><span style="font-size: 15px">上榜理由：github上16.1K个star，以快速、简洁。强大著称的图表框架</span></p>
<p><span style="font-size: 15px">官网地址 <a href="https://github.com/PhilJay/MPAndroidChart">https://github.com/PhilJay/MPAndroidChart</a>  </span></p>
<p><span style="font-size: 15px">github  <a href="https://github.com/PhilJay/MPAndroidChart">https://github.com/PhilJay/MPAndroidChart</a></span></p>
<p><span style="font-size: 15px">作者：PhilJay</span></p>
<p><span style="font-size: 15px">使用：</span></p>
<p><span style="font-size: 15px">1. 在AS中加入Gradle依赖</span></p>
<ul>
<li><p>  <span style="font-size: 15px">在根目录的 <code>build.gradle上加入</code>:</span></p>
</li>
<li><div class="cnblogs_code">

  <pre><span style="color: #000000">allprojects {
      repositories {
          maven { url</span> <span style="color: #800000">"</span><span style="color: #800000">https://jitpack.io</span><span style="color: #800000">"</span> <span style="color: #000000">}
      }
  }</span></pre>

  </div>
</li>
<li><p><span style="font-size: 15px">在app的build.gradle上加入：</span></p>
</li>
<li><div class="cnblogs_code">

  <pre><span style="color: #000000">dependencies {
      compile</span> <span style="color: #800000">'</span><span style="color: #800000">com.github.PhilJay:MPAndroidChart:v3.0.2</span><span style="color: #800000">'</span> <span style="color: #000000">}</span></pre>

  </div>

</li>
</ul>
<h2 id="5-glide"><a href="#5-glide" class="headerlink" title="5. glide"></a>5. glide<a href="#5-glide" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：glide是一款专注于提供<strong>流畅划动能力</strong>的“图片加载和缓存框架”</span></p>
<p><span style="font-size: 15px">上榜理由：15.9k个star，图片加载类框架排名第一的框架，google 在2014开发者大会上演示的camera app就是基于gilde框架开发的</span></p>
<p><span style="font-size: 15px">github <a href="https://github.com/bumptech/glide">https://github.com/bumptech/glide</a></span></p>
<p><span style="font-size: 15px">作者 Bump Technologies团队</span></p>
<p><span style="font-size: 15px">使用：</span></p>
<div class="cnblogs_code">

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

<pre><span style="color: #000000">repositories {
  mavenCentral()
}

dependencies {
    compile</span> <span style="color: #800000">'</span><span style="color: #800000">com.github.bumptech.glide:glide:3.8.0</span><span style="color: #800000">'</span> <span style="color: #000000">compile</span> <span style="color: #800000">'</span><span style="color: #800000">com.android.support:support-v4:19.1.0</span><span style="color: #800000">'</span> <span style="color: #000000">}</span></pre>

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

</div>

<h2 id="6leakcanary"><a href="#6-leakcanary" class="headerlink" title="6.leakcanary"></a>6.leakcanary<a href="#6leakcanary" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：一款内存检测框架，服务于java和android客户端</span></p>
<p><span style="font-size: 15px">上榜理由：方便，简洁是leakcanary最大的特点，只需在应用的apllication中集成，就可以直接使用它；15.5k个star说明了它有多么受欢迎</span></p>
<p><span style="font-size: 15px">github <a href="https://github.com/square/leakcanary">https://github.com/square/leakcanary</a></span></p>
<p><span style="font-size: 15px">作者 square团队</span></p>
<p><span style="font-size: 15px">使用</span>：</p>
<div class="cnblogs_code">

<pre> <span style="color: #000000">dependencies {
   debugCompile</span> <span style="color: #800000">'</span><span style="color: #800000">com.squareup.leakcanary:leakcanary-android:1.5.1</span><span style="color: #800000">'</span> <span style="color: #000000">releaseCompile</span> <span style="color: #800000">'</span><span style="color: #800000">com.squareup.leakcanary:leakcanary-android-no-op:1.5.1</span><span style="color: #800000">'</span> <span style="color: #000000">testCompile</span> <span style="color: #800000">'</span><span style="color: #800000">com.squareup.leakcanary:leakcanary-android-no-op:1.5.1</span><span style="color: #800000">'</span> <span style="color: #000000">}</span></pre>

</div>

<p><span style="font-size: 15px">在 <code>Application</code> 中写入:</span></p>
<div class="cnblogs_code">

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

<pre><span style="color: #0000ff">public</span> <span style="color: #0000ff">class</span> <span style="color: #000000">ExampleApplication extends Application {

  @Override</span> <span style="color: #0000ff">public</span> <span style="color: #0000ff">void</span> <span style="color: #000000">onCreate() {
    super.onCreate();</span> <span style="color: #0000ff">if</span> (LeakCanary.isInAnalyzerProcess(<span style="color: #0000ff">this</span><span style="color: #000000">)) {</span> <span style="color: #008000">//</span> <span style="color: #008000">This process is dedicated to LeakCanary for heap analysis.</span> <span style="color: #008000">//</span> <span style="color: #008000">You should not init your app in this process.</span>
      <span style="color: #0000ff">return</span><span style="color: #000000">;
    }
    LeakCanary.install(</span><span style="color: #0000ff">this</span><span style="color: #000000">);</span> <span style="color: #008000">//</span> <span style="color: #008000">Normal app init code...</span>
 <span style="color: #000000">}
}</span></pre>

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

</div>

<h2 id="7android-universal-image-loader"><a href="#7-Android-Universal-Image-Loader" class="headerlink" title="7.Android-Universal-Image-Loader"></a>7.Android-Universal-Image-Loader<a href="#7android-universal-image-loader" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：曾经的图片加载框架王者，android开发老手都用过它</span></p>
<p><span style="font-size: 15px">上榜理由:android端图片加载框架的老大哥了，15.3k个star足以证明它的热门，UIL与gilde最大区别是可定制，UIL提供了大量配置方式，图片加载状态的回调（成功，失败，进行中），加载动画等；以及提供了移动端图片加载框架的缓存思路：三级缓存策略 sd卡-内存-网络；值得注意的是，UIL以及两年未更新了，但笔者仍推荐各位使用！</span></p>
<p><span style="font-size: 15px">github <a href="https://github.com/nostra13/Android-Universal-Image-Loader">https://github.com/nostra13/Android-Universal-Image-Loader</a></span></p>
<p><span style="font-size: 15px">作者 nostra13</span></p>
<p><span style="font-size: 15px">使用：</span></p>
<p><span style="font-size: 15px">下载地址  <a href="https://github.com/nostra13/Android-Universal-Image-Loader/raw/master/downloads/universal-image-loader-1.9.5.jar">universal-image-loader-1.9.5.jar</a></span></p>
<p><span style="font-size: 15px"> </span></p>
<h2 id="8eventbus"><a href="#8-EventBus" class="headerlink" title="8.EventBus"></a>8.EventBus<a href="#8eventbus" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：EventBus是一款本地组件间通信框架</span></p>
<p><span style="font-size: 15px">上榜理由：组件间通信框架star量第一：14.8k，在大型项目的Activities，fragments，Threads，Services都可以看到它的使用场景，尽管EventBus在向未创建的组件传递事件时有些局限，仅适合在“活着的”组件间传递消息，但仍不妨碍它活跃在各个大型项目各个场景里。</span></p>
<p><span style="font-size: 15px">官网地址 <a href="http://greenrobot.org/eventbus/documentation/how-to-get-started/">http://greenrobot.org/eventbus/documentation/how-to-get-started/</a></span></p>
<p><span style="font-size: 15px">github  <a href="https://github.com/greenrobot/EventBus">https://github.com/greenrobot/EventBus</a></span></p>
<p><span style="font-size: 15px">作者 greenrobot </span></p>
<p><span style="font-size: 15px">使用：</span></p>
<div class="cnblogs_code">

<pre>compile <span style="color: #800000">'</span><span style="color: #800000">org.greenrobot:eventbus:3.0.0</span><span style="color: #800000">'</span></pre>

</div>

<h2 id="9zxing"><a href="#9-zxing" class="headerlink" title="9.zxing"></a>9.zxing<a href="#9zxing" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：条码图像处理库</span></p>
<p><span style="font-size: 15px">上榜理由：如果你用过二维码，你肯定已经间接使用过大名鼎鼎的zxing了。13.9K的star量，让它排在本榜单第九，实至名归，如果你有了解二维码的需求，不妨从了解、修改它源码入手。</span></p>
<p><span style="font-size: 15px">github <a href="https://github.com/zxing/zxing"> https://github.com/zxing/zxing</a></span></p>
<p><span style="font-size: 15px">作者  Sean Owen</span></p>
<h2 id="10picasso"><a href="#10-picasso" class="headerlink" title="10.picasso"></a>10.picasso<a href="#10picasso" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：强力的图片下载、缓存框架</span></p>
<p><span style="font-size: 15px">上榜理由：本榜单出现的第三款图片类框架，不同的是picasso更强调图片下载，你可以将picasso集成进你的项目中，你也可以结合gilde和UIL与picasso，三者一齐封装至你的项目中，按需所用。</span></p>
<p><span style="font-size: 15px">官网地址 <a href="http://square.github.io/picasso/">http://square.github.io/picasso/</a></span></p>
<p><span style="font-size: 15px">github  <a href="https://github.com/square/picasso">https://github.com/square/picasso</a></span></p>
<p><span style="font-size: 15px">作者 square团队</span></p>
<p><span style="font-size: 15px">使用：</span></p>
<div class="cnblogs_code">

<pre>compile <span style="color: #800000">'</span><span style="color: #800000">com.squareup.picasso:picasso:2.5.2</span><span style="color: #800000">'</span></pre>

</div>

<p><span style="font-size: 15px">或者下载</span></p>
<p><span style="font-size: 15px"><a href="https://search.maven.org/remote_content?g=com.squareup.picasso&a=picasso&v=LATEST">jar包</a></span></p>
<h2 id="11lottie-android"><a href="#11-lottie-android" class="headerlink" title="11.lottie-android"></a>11.lottie-android<a href="#11lottie-android" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：一款可以在Android端快速展示Adobe Afeter Effect（AE）工具所作动画的框架</span></p>
<p><span style="font-size: 15px">上榜理由：动画类框架第一名，github上13.3k个star证明了他的优越性，利用json文件快速实现动画效果是它最大的便利，而这个json文件也是由Adobe提供的After Effects（AE）工具制作的，在AE中装一个Bodymovin的插件，使用这个插件最终将动画效果生成json文件，这个json文件即可由LottieAnimationView解析并生成绚丽的动画效果。而且它还支持跨平台哟。</span></p>
<p><span style="font-size: 15px">github  <a href="https://github.com/airbnb/lottie-android">https://github.com/airbnb/lottie-android</a></span></p>
<p><span style="font-size: 15px">作者：Airbnb 团队</span></p>
<h2 id="12fresco"><a href="#12-fresco" class="headerlink" title="12.fresco"></a>12.fresco<a href="#12fresco" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：一款可以管理图片内存的框架</span></p>
<p><span style="font-size: 15px">上榜理由:github上12.8k个star，图片类排行榜第四名，facebook的出身证明了它并非是重复造的轮子，在管理图片内存领域上有着它的一片天地，渐进式加载、加载gif都是它与前三位相比独有的特性</span></p>
<p><span style="font-size: 15px">官网地址： <a href="https://www.fresco-cn.org/">https://www.fresco-cn.org/</a></span></p>
<p><span style="font-size: 15px">github  <a href="https://github.com/facebook/fresco">https://github.com/facebook/fresco</a></span></p>
<p><span style="font-size: 15px">作者 facebook</span></p>
<p><span style="font-size: 15px">使用：</span></p>
<div class="cnblogs_code">

<pre><span style="color: #000000">dependencies {</span> <span style="color: #008000">//</span> <span style="color: #008000">其他依赖</span>
  compile <span style="color: #800000">'</span><span style="color: #800000">com.facebook.fresco:fresco:0.12.0</span><span style="color: #800000">'</span> <span style="color: #000000">}</span></pre>

</div>

<p><span style="font-size: 15px">下面的依赖需要根据需求添加：</span></p>
<div class="cnblogs_code">

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

<pre><span style="color: #000000">dependencies {</span> <span style="color: #008000">//</span> <span style="color: #008000">在 API < 14 上的机器支持 WebP 时，需要添加</span>
  compile <span style="color: #800000">'</span><span style="color: #800000">com.facebook.fresco:animated-base-support:0.12.0</span><span style="color: #800000">'</span>

  <span style="color: #008000">//</span> <span style="color: #008000">支持 GIF 动图，需要添加</span>
  compile <span style="color: #800000">'</span><span style="color: #800000">com.facebook.fresco:animated-gif:0.12.0</span><span style="color: #800000">'</span>

  <span style="color: #008000">//</span> <span style="color: #008000">支持 WebP （静态图+动图），需要添加</span>
  compile <span style="color: #800000">'</span><span style="color: #800000">com.facebook.fresco:animated-webp:0.12.0</span><span style="color: #800000">'</span> <span style="color: #000000">compile</span> <span style="color: #800000">'</span><span style="color: #800000">com.facebook.fresco:webpsupport:0.12.0</span><span style="color: #800000">'</span>

  <span style="color: #008000">//</span> <span style="color: #008000">仅支持 WebP 静态图，需要添加</span>
  compile <span style="color: #800000">'</span><span style="color: #800000">com.facebook.fresco:webpsupport:0.12.0</span><span style="color: #800000">'</span> <span style="color: #000000">}</span></pre>

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

</div>

<h2 id="13rxandroid"><a href="#13-RxAndroid" class="headerlink" title="13.RxAndroid"></a>13.RxAndroid<a href="#13rxandroid" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：一款Android客户端组件间异步通信的框架</span></p>
<p><span style="font-size: 15px">上榜理由：github上12.7k个star，位居组件通信框架的第二名，仅在EventBus之后，如果要问两者的区别，Eventbus是用来取代组件间繁琐的interface，RxAndroid是用来取代AnsyTask的，并不冲突；当然RxAndroid的优点并不仅限于此，更多优雅的实现，可以去官网查阅！</span></p>
<p><span style="font-size: 15px">github  <a href="https://github.com/ReactiveX/RxAndroid">https://github.com/ReactiveX/RxAndroid</a></span></p>
<p><span style="font-size: 15px">作者 JakeWharton</span></p>
<p><span style="font-size: 15px">使用：</span></p>
<div class="cnblogs_code">

<pre>compile <span style="color: #800000">'</span><span style="color: #800000">io.reactivex.rxjava2:rxandroid:2.0.1</span><span style="color: #800000">'</span>
compile <span style="color: #800000">'</span><span style="color: #800000">io.reactivex.rxjava2:rxjava:2.1.0</span><span style="color: #800000">'</span></pre>

</div>

<h2 id="14slidingmenu"><a href="#14-SlidingMenu" class="headerlink" title="14.SlidingMenu"></a>14.SlidingMenu<a href="#14slidingmenu" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：侧滑菜单栏框架</span></p>
<p><span style="font-size: 15px">上榜理由：与Userval-Image-loader 齐名的上古神器框架——为你的app提供侧滑菜单栏的功能；github闪更有10.5k个star，证明了它的经久不衰，即使在Google推出了NavigationDrawer，仍然没有减少开发者对SildingMenu的拥簇，经典总是经得起考验的，这个上古神兽已经四年没有更新了；有太多太多的app使用过它，这些都可以在软件的开源许可上看到！</span></p>
<p><span style="font-size: 15px">github <a href="https://github.com/jfeinstein10/SlidingMenu">https://github.com/jfeinstein10/SlidingMenu</a></span></p>
<p><span style="font-size: 15px">作者 Jeremy Feinstein</span></p>
<p><span style="font-size: 15px">使用：</span></p>
<p><span style="font-size: 15px">在gihub上fork源码，集成进项目中</span></p>
<h2 id="15photoview"><a href="#15-PhotoView" class="headerlink" title="15.PhotoView"></a>15.PhotoView<a href="#15photoview" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：一款ImageView展示框架，支持缩放，响应手势</span></p>
<p><span style="font-size: 15px">上榜理由：10.3k的star数量，位于图片类框架排行榜第五位，PhotoView与前四位不同的是这次带来的是图片的展示能力，你一定好奇微信的头像点击放大是如何实现的，很多App的图片显示响应手势按压是如何实现的，了解PhotoView，你一定会开心的！（笔者也不会告诉你ImageView的点击放大效果在Android的sample也有）</span></p>
<p><span style="font-size: 15px">github  <a href="https://github.com/chrisbanes/PhotoView">https://github.com/chrisbanes/PhotoView</a></span></p>
<p><span style="font-size: 15px">作者：chrisbanes</span></p>
<p><span style="font-size: 15px">使用：</span></p>
<div class="cnblogs_code">

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

<pre><span style="color: #000000">在app根目录的build.gradle中加入：
allprojects {
    repositories {
        maven { url</span> <span style="color: #800000">"</span><span style="color: #800000">https://jitpack.io</span><span style="color: #800000">"</span> <span style="color: #000000">}
    }
}
在app的module目录的build.gralde中加入：

dependencies {
    compile</span> <span style="color: #800000">'</span><span style="color: #800000">com.github.chrisbanes:PhotoView:latest.release.here</span><span style="color: #800000">'</span> <span style="color: #000000">}</span></pre>

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

</div>

<p><span style="font-size: 15px">使用</span></p>
<div class="cnblogs_code">

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

<pre><<span style="color: #000000">com.github.chrisbanes.photoview.PhotoView
    android:id</span>=<span style="color: #800000">"</span><span style="color: #800000">@+id/photo_view</span><span style="color: #800000">"</span> <span style="color: #000000">android:layout_width</span>=<span style="color: #800000">"</span><span style="color: #800000">match_parent</span><span style="color: #800000">"</span> <span style="color: #000000">android:layout_height</span>=<span style="color: #800000">"</span><span style="color: #800000">match_parent</span><span style="color: #800000">"</span>/>

 <span style="color: #000000">PhotoView photoView</span> = <span style="color: #000000">(PhotoView) findViewById(R.id.photo_view);
photoView.setImageResource(R.drawable.image);</span></pre>

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

</div>

<h2 id="16material-dialogs"><a href="#16-material-dialogs" class="headerlink" title="16.material-dialogs"></a>16.material-dialogs<a href="#16material-dialogs" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：一款自定义dialog框架</span></p>
<p><span style="font-size: 15px">上榜理由：9.9k个star，也是继PhotoView，SlidingMenu之后第三款自定义View框架，也许你还是自定义View的新人，对Dialog使用的还有点生疏，你可以通过它提升你的Dilaog使用能力</span></p>
<p><span style="font-size: 15px">github  <a href="https://github.com/afollestad/material-dialogs">https://github.com/afollestad/material-dialogs</a></span></p>
<p><span style="font-size: 15px">作者：Aidan Follestad</span></p>
<p><span style="font-size: 15px">使用：</span></p>
<div class="cnblogs_code">

<pre><span style="color: #000000">dependencies {</span> <span style="color: #008000">//</span> <span style="color: #008000">... other dependencies here</span>
    compile <span style="color: #800000">'</span><span style="color: #800000">com.afollestad.material-dialogs:core:0.9.4.5</span><span style="color: #800000">'
}</span></pre>

</div>

<h2 id="17android-async-http"><a href="#17-Android-async-http" class="headerlink" title="17.Android-async-http"></a>17.Android-async-http<a href="#17android-async-http" class="header-anchor">#</a></h2><p><span style="font-size: 15px"> 一句话介绍：一款基于Http协议的异步请求的网络框架，</span></p>
<p><span style="font-size: 15px">上榜理由：虽然你有无数个使用retrofit+okhttp的理由，但9.8k个star，证明它仍然值得你深入学习。值得注意的是，它也已经有两年没更新了，你尽管拿去当你懒惰的理由！</span></p>
<p><span style="font-size: 15px">github   <a href="https://github.com/loopj/android-async-http">https://github.com/loopj/android-async-http</a></span></p>
<p><span style="font-size: 15px">作者：James Smith</span></p>
<p><span style="font-size: 15px">使用：</span></p>
<div class="cnblogs_code">

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

<pre><span style="color: #000000">repositories {
  maven {
    url</span> <span style="color: #800000">'</span><span style="color: #800000">https://oss.sonatype.org/content/repositories/snapshots/</span><span style="color: #800000">'</span> <span style="color: #000000">}
}
dependencies {
  compile</span> <span style="color: #800000">'</span><span style="color: #800000">com.loopj.android:android-async-http:1.5.0-SNAPSHOT</span><span style="color: #800000">'</span> <span style="color: #000000">}</span></pre>

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

</div>

<h2 id="18androidannotations"><a href="#18-androidannotations" class="headerlink" title="18.androidannotations"></a>18.androidannotations<a href="#18androidannotations" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：一款基于注解的快速开发框架</span></p>
<p><span style="font-size: 15px">上榜理由：与Butterknife一样基于注解，利用注解快速完成view的初始化，不同的是androidannotations提供了更多的能力：简单的线程模型等；笔者只接触过Butterknife，无法更进一步叙述androidannotations的优势，如果你志在深入了解注解的妙用，可以尝试探索一下！</span></p>
<p><span style="font-size: 15px">官网地址 <a href="http://androidannotations.org/">http://androidannotations.org/</a></span></p>
<p><span style="font-size: 15px">github <a href="https://github.com/androidannotations/androidannotations">https://github.com/androidannotations/androidannotations</a></span></p>
<p><span style="font-size: 15px">作者： WonderCsabo</span></p>
<h2 id="19fastjson"><a href="#19-fastjson" class="headerlink" title="19.fastjson"></a>19.fastjson<a href="#19fastjson" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍:一款基于json解析、生成的框架</span></p>
<p><span style="font-size: 15px">上榜理由：从它的名字不难看出，快速是它最大的特性，阿里巴巴的出身保证了代码的质量和优越，9.4k的star数量，也是榜单里第一个出现的中国开源框架，涉及网络的app都会用到json，fastjson值得作为你的首选！</span></p>
<p><span style="font-size: 15px">github  <a href="https://github.com/alibaba/fastjson">https://github.com/alibaba/fastjson</a></span></p>
<p><span style="font-size: 15px">作者：alibaba</span></p>
<p><span style="font-size: 15px">使用：</span></p>
<div class="cnblogs_code">

<pre>compile <span style="color: #800000">'</span><span style="color: #800000">com.alibaba:fastjson:1.1.58.android</span><span style="color: #800000">'</span></pre>

</div>

<h2 id="20material-animations"><a href="#20-Material-Animations" class="headerlink" title="20.Material-Animations"></a>20.Material-Animations<a href="#20material-animations" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：一款提供场景转换过渡能力的动画框架</span></p>
<p><span style="font-size: 15px">上榜理由：Android动画框架排行榜第二名，9.3k个star数量，与动画框架榜单第一名lottie-android不同的是，Material-Animations提供的是场景切换的动画效果。Android 官网sample中已经提供了部分Transition （转场动画）的展示，作为初学者很难快速拓展到自己项目中，Material-Animations的示例出现为开发者省去了此类麻烦，直接照搬应用到自己的App中吧。</span></p>
<p><span style="font-size: 15px"> github  <a href="https://github.com/lgvalle/Material-Animations">https://github.com/lgvalle/Material-Animations</a></span></p>
<p><span style="font-size: 15px">作者：Luis G. Valle</span></p>
<p><span style="font-size: 15px">使用：</span></p>
<p><span style="font-size: 15px">down源码，修改学习</span></p>
<h2 id="21tinker"><a href="#21-tinker" class="headerlink" title="21.tinker"></a>21.tinker<a href="#21tinker" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：它是微信官网的Android热补丁解决方案</span></p>
<p><span style="font-size: 15px">上榜理由：9.1k个star，微信在用的热补丁方案，心动不如行动</span></p>
<p><span style="font-size: 15px">官网地址  <a href="http://www.tinkerpatch.com/Docs/intro">http://www.tinkerpatch.com/Docs/intro</a></span></p>
<p><span style="font-size: 15px">github   <a href="https://github.com/Tencent/tinker">https://github.com/Tencent/tinker</a></span></p>
<p><span style="font-size: 15px">作者：Tencent</span></p>
<h2 id="22viewpagerindicator"><a href="#22-ViewPagerIndicator" class="headerlink" title="22.ViewPagerIndicator"></a>22.ViewPagerIndicator<a href="#22viewpagerindicator" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：一款基于ViewPager的页面指示器开源框架</span></p>
<p><span style="font-size: 15px">上榜理由：上古神器，尽管已经五年未更新了，但你仍然可以在淘宝等app中看到它的使用场景，8.9K的star量让它不愠不火的在矗立在榜单里</span></p>
<p><span style="font-size: 15px">官网地址 <a href="http://viewpagerindicator.com/">http://viewpagerindicator.com/</a></span></p>
<p><span style="font-size: 15px">github  <a href="https://github.com/JakeWharton/ViewPagerIndicator">https://github.com/JakeWharton/ViewPagerIndicator</a></span></p>
<p><span style="font-size: 15px">作者：JakeWharton </span></p>
<p><span style="font-size: 15px">使用：</span></p>
<p><span style="font-size: 15px"> 下载 地址<a href="https://github.com/JakeWharton/Android-ViewPagerIndicator/zipball/master"> https://github.com/JakeWharton/Android-ViewPagerIndicator/zipball/master</a></span></p>
<p><span style="font-size: 15px"> </span></p>
<h2 id="23android-cleanarchitecture"><a href="#23-Android-CleanArchitecture" class="headerlink" title="23.Android-CleanArchitecture"></a>23.Android-CleanArchitecture<a href="#23android-cleanarchitecture" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：一个讲解设计框架的demo</span></p>
<p><span style="font-size: 15px">上榜理由：它不是框架，你可以把它当作一本书，它将教会你如何设计简洁的架构，工程里有一个sample app，配合图文讲解，你将对Android客户端的架构有更深一层的认识。8.8k的star数量，证明了它是一本“好书”哟。</span></p>
<p><span style="font-size: 15px">github  <a href="https://github.com/android10/Android-CleanArchitecture">https://github.com/android10/Android-CleanArchitecture</a></span></p>
<p><span style="font-size: 15px">作者：Fernando Cejas</span></p>
<h2 id="24android-pulltorefresh"><a href="#24-Android-PullToRefresh" class="headerlink" title="24..Android-PullToRefresh"></a>24..Android-PullToRefresh<a href="#24android-pulltorefresh" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：一款为普通视图提供刷新UI的视图框架</span></p>
<p><span style="font-size: 15px">上榜理由：8.2K的star数量使它位居刷新类UI框架榜首，强大的兼容能力，该框架支持ListView，GrdiView，WebViewScrollView，ViewPager等众多View增加刷新的能力，如果你有增加上拉加载，下拉加载的需求，你应该考虑它了！</span></p>
<p><span style="font-size: 15px">github <a href="https://github.com/chrisbanes/Android-PullToRefresh">https://github.com/chrisbanes/Android-PullToRefresh</a></span></p>
<p><span style="font-size: 15px">作者：Chris Banes</span></p>
<p><span style="font-size: 15px">使用：</span></p>
<p><span style="font-size: 15px">github fork源码，集成到项目中</span></p>
<h2 id="25flexbox-layout"><a href="#25-flexbox-layout" class="headerlink" title="25.flexbox-layout"></a>25.flexbox-layout<a href="#25flexbox-layout" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：一款弹性伸缩布局</span></p>
<p><span style="font-size: 15px">上榜理由：8.1k个star，前端H5开发者转Android开发的福音，FlexboxLayout作为<code>LinearLayout</code>和<code>RelativeLayout的替代者，值得各位一试，与其一同推出的还有ConstraintLayout。</code></span></p>
<p><span style="font-size: 15px">github  <a href="https://github.com/google/flexbox-layout">https://github.com/google/flexbox-layout</a></span></p>
<p><span style="font-size: 15px">作者：Google</span></p>
<p><span style="font-size: 15px">使用：</span></p>
<div class="cnblogs_code">

<pre><span style="color: #000000">dependencies {
    compile</span> <span style="color: #800000">'</span><span style="color: #800000">com.google.android:flexbox:0.3.0-alpha3</span><span style="color: #800000">'</span> <span style="color: #000000">}</span></pre>

</div>

<h2 id="26androidswipelayout"><a href="#26-AndroidSwipeLayout" class="headerlink" title="26.AndroidSwipeLayout"></a>26.AndroidSwipeLayout<a href="#26androidswipelayout" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：非常强大滑动式布局</span></p>
<p><span style="font-size: 15px">上榜理由:滑动删除是国产app常见需求，商品详情的上下滑动需求作为开发者的我们也经常遇到，AndroidSwipeLayout在github上拥有8K个star，证明它经受住了检验，各位值得一试</span></p>
<p><span style="font-size: 15px">github <a href="https://github.com/daimajia/AndroidSwipeLayout">https://github.com/daimajia/AndroidSwipeLayout</a></span></p>
<p><span style="font-size: 15px">作者：daimajia</span></p>
<p><span style="font-size: 15px">使用：</span></p>
<div class="cnblogs_code">

<pre><span style="color: #000000">dependencies {
    compile</span> <span style="color: #800000">'</span><span style="color: #800000">com.android.support:recyclerview-v7:21.0.0</span><span style="color: #800000">'</span> <span style="color: #000000">compile</span> <span style="color: #800000">'</span><span style="color: #800000">com.android.support:support-v4:20.+</span><span style="color: #800000">'</span> <span style="color: #000000">compile</span> <span style="color: #800000">"</span><span style="color: #800000">com.daimajia.swipelayout:library:1.2.0@aar</span><span style="color: #800000">"</span> <span style="color: #000000">}</span></pre>

</div>

<p><span style="font-size: 15px">或下载 </span></p>
<p><span style="font-size: 15px"><a href="https://github.com/daimajia/AndroidSwipeLayout/releases/download/v1.1.8/AndroidSwipeLayout-v1.1.8.jar">AndroidSwipeLayout-v1.1.8.jar</a></span></p>
<h2 id="27realm-java"><a href="#27-realm-java" class="headerlink" title="27.realm-java"></a>27.realm-java<a href="#27realm-java" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：Realm是一款移动端数据库框架</span></p>
<p><span style="font-size: 15px">上榜理由：核心数据引擎C++打造，比普通的Sqlite型数据库快的多。笔者猜测正是如此，realm以7892个star数让它位于大名鼎鼎的数据库框架GreenDao（7877）之前</span></p>
<p><span style="font-size: 15px">官网地址：<a href="https://realm.io/cn/">https://realm.io/cn/</a></span></p>
<p><span style="font-size: 15px">github <a href="https://github.com/realm/realm-java">https://github.com/realm/realm-java</a></span></p>
<p><span style="font-size: 15px">作者：Realm团队 </span></p>
<p><span style="font-size: 15px">使用：<a href="https://realm.io/docs/java/latest/">https://realm.io/docs/java/latest/</a></span></p>
<h2 id="28greendao"><a href="#28-greenDAO" class="headerlink" title="28.greenDAO"></a>28.greenDAO<a href="#28greendao" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：greenDAO是一款高效、快速的SQLite型数据库</span></p>
<p><span style="font-size: 15px">上榜理由：greenDAO的star数量与Realm不相上下，且与EventBus师出同门，也是由greenrobot团队开发维护的，质量有所保证，但若拷问笔者Realm与greenDao两者的优劣性，只能具体到实际使用当中，模拟线上的使用情形，进行高强度测试后才能下判断，故在此不能一言两语说完，深表遗憾</span></p>
<p><span style="font-size: 15px">官网地址：<a href="http://greenrobot.org/greendao/">http://greenrobot.org/greendao/</a></span></p>
<p><span style="font-size: 15px">github  <a href="https://github.com/greenrobot/greenDAO">https://github.com/greenrobot/greenDAO</a></span></p>
<p><span style="font-size: 15px">使用：</span></p>
<div class="cnblogs_code">

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

<pre><span style="color: #000000">buildscript {
    repositories {
        jcenter()
        mavenCentral()</span> <span style="color: #008000">//</span> <span style="color: #008000">add repository</span>
 <span style="color: #000000">}
    dependencies {
        classpath</span> <span style="color: #800000">'</span><span style="color: #800000">com.android.tools.build:gradle:2.3.1</span><span style="color: #800000">'</span> <span style="color: #000000">classpath</span> <span style="color: #800000">'</span><span style="color: #800000">org.greenrobot:greendao-gradle-plugin:3.2.2</span><span style="color: #800000">'</span> <span style="color: #008000">//</span> <span style="color: #008000">add plugin</span>
 <span style="color: #000000">}
}</span> -----

apply plugin: <span style="color: #800000">'</span><span style="color: #800000">com.android.application</span><span style="color: #800000">'</span> <span style="color: #000000">apply plugin:</span> <span style="color: #800000">'</span><span style="color: #800000">org.greenrobot.greendao</span><span style="color: #800000">'</span> <span style="color: #008000">//</span> <span style="color: #008000">apply plugin</span>
 <span style="color: #000000">dependencies {
    compile</span> <span style="color: #800000">'</span><span style="color: #800000">org.greenrobot:greendao:3.2.2</span><span style="color: #800000">'</span> <span style="color: #008000">//</span> <span style="color: #008000">add library</span>
}</pre>

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

</div>

<h2 id="29stetho"><a href="#29-stetho" class="headerlink" title="29.stetho"></a>29.stetho<a href="#29stetho" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：一款提供在Chrome开发者工具上调试Android app能力的开源框架</span></p>
<p><span style="font-size: 15px">上榜理由：上古时期Android程序员要调试本地数据库，需要进入Android Device Monitor找到/data/data/com.xxx.xxx/databases里面的db文件，导出到PC端，用PC的数据工具查看，现在使用stetho省却了如此的麻烦；如今的Android程序员如果想调试网络请求响应过程中的报文段，需要在请求中加入Log语句，一个信息一个信息打印出来，相当繁琐，现在请使用stetho，省却诸如此类的麻烦把！7.8K个star数，广大Android开发者调试的福音，你值得拥有！</span></p>
<p><span style="font-size: 15px">作者：FaceBook</span></p>
<p><span style="font-size: 15px">官网地址：<a target="_blank"> http://facebook.github.io/stetho/</a></span></p>
<p><span style="font-size: 15px">github   <a href="https://github.com/facebook/stetho">https://github.com/facebook/stetho</a></span></p>
<p><span style="font-size: 15px">使用：</span></p>
<div class="cnblogs_code">

<pre>compile <span style="color: #800000">'</span><span style="color: #800000">com.facebook.stetho:stetho:1.5.0</span><span style="color: #800000">'</span></pre>

</div>

<h2 id="30baserecyclerviewadapterhelper"><a href="#30-BaseRecyclerViewAdapterHelper" class="headerlink" title="30.BaseRecyclerViewAdapterHelper"></a>30.BaseRecyclerViewAdapterHelper<a href="#30baserecyclerviewadapterhelper" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：强大、流畅的Recyvlerview通用适配器</span></p>
<p><span style="font-size: 15px">上榜理由：如果你是RecyclerView的拥簇者，你一定要体验这款专门服务该view的适配器，7.7K个star，让这个家伙位于github上Android 适配器排行榜第一，还有很多惊喜等你去探寻！</span></p>
<p><span style="font-size: 15px">官网地址：<a href="http://www.recyclerview.org/">http://www.recyclerview.org/</a></span></p>
<p><span style="font-size: 15px">作者：陈宇明以及他的小伙伴</span></p>
<p><span style="font-size: 15px">使用：</span></p>
<div class="cnblogs_code">

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

<pre><span style="color: #000000">allprojects {
    repositories {
        ...
        maven { url</span> <span style="color: #800000">"</span><span style="color: #800000">https://jitpack.io</span><span style="color: #800000">"</span> <span style="color: #000000">}
    }
}

dependencies {
        compile</span> <span style="color: #800000">'</span><span style="color: #800000">com.github.CymChad:BaseRecyclerViewAdapterHelper:VERSION_CODE</span><span style="color: #800000">'</span> <span style="color: #000000">}</span></pre>

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

</div>

<h2 id="31androidviewanimations"><a href="#31-AndroidViewAnimations" class="headerlink" title="31.AndroidViewAnimations"></a>31.AndroidViewAnimations<a href="#31androidviewanimations" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：一款提供可爱动画集合的框架</span></p>
<p><span style="font-size: 15px">上榜理由：正如作者所说，它囊括了开发需求过程中所有的动画效果，集成进了这个简洁可爱的动画框架。7.6K的star数，证明了它在动画框架领域的战斗力，让它仅仅位列lottie-android和Material-Animations两个动画框架霸主之后，屈居第三名</span></p>
<p><span style="font-size: 15px">github <a href="https://github.com/daimajia/AndroidViewAnimations">https://github.com/daimajia/AndroidViewAnimations</a></span></p>
<p><span style="font-size: 15px">作者：daimajia</span></p>
<p><span style="font-size: 15px">使用：</span></p>
<div class="cnblogs_code">

<pre><span style="color: #000000">dependencies {
        compile</span> <span style="color: #800000">'</span><span style="color: #800000">com.android.support:support-compat:25.1.1</span><span style="color: #800000">'</span> <span style="color: #000000">compile</span> <span style="color: #800000">'</span><span style="color: #800000">com.daimajia.easing:library:2.0@aar</span><span style="color: #800000">'</span> <span style="color: #000000">compile</span> <span style="color: #800000">'</span><span style="color: #800000">com.daimajia.androidanimations:library:2.2@aar</span><span style="color: #800000">'</span> <span style="color: #000000">}</span></pre>

</div>

<p><span style="font-size: 15px">sample：</span></p>
<div class="cnblogs_code">

<pre><span style="color: #000000">YoYo.with(Techniques.Tada)
    .duration(</span><span style="color: #800080">700</span><span style="color: #000000">)
    .repeat(</span><span style="color: #800080">5</span><span style="color: #000000">)
    .playOn(findViewById(R.id.edit_area));</span></pre>

</div>

<h2 id="32-materialdrawer"><a href="#32-MaterialDrawer" class="headerlink" title="32. MaterialDrawer"></a>32. MaterialDrawer<a href="#32-materialdrawer" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：强大的塑料风格的抽屉框架</span></p>
<p><span style="font-size: 15px">上榜理由：7.6K的star数量，作者的持续更新状态，如果你还在犹豫上手SlidingMenu遇到bug没人管的困境，那么你可以入手它作为你的抽屉布局 </span></p>
<p><span style="font-size: 15px">github  <a href="https://github.com/mikepenz/MaterialDrawer">https://github.com/mikepenz/MaterialDrawer</a></span></p>
<p><span style="font-size: 15px">作者：Mike Penz</span></p>
<p><span style="font-size: 15px">使用:</span></p>
<div class="cnblogs_code">

<pre>compile(<span style="color: #800000">'</span><span style="color: #800000">com.mikepenz:materialdrawer:5.9.2@aar</span><span style="color: #800000">'</span><span style="color: #000000">) {
    transitive</span> = <span style="color: #0000ff">true</span> <span style="color: #000000">}</span></pre>

</div>

<div class="cnblogs_code">

<pre><span style="color: #0000ff">new</span> DrawerBuilder().withActivity(<span style="color: #0000ff">this</span>).build();</pre>

</div>

<h2 id="33android-observablescrollview"><a href="#33-Android-ObservableScrollView" class="headerlink" title="33.Android-ObservableScrollView"></a>33.Android-ObservableScrollView<a href="#33android-observablescrollview" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：一款让视图滑动更具有视觉效果的滑动式框架</span></p>
<p><span style="font-size: 15px">上榜理由：7.5K的star数量，证明了它曾经的价值，github上提供了12种滑动效果，你可以用它弥补其他框架的不足，提升你的App体验！</span></p>
<p><span style="font-size: 15px">github <a href="https://github.com/ksoichiro/Android-ObservableScrollView">https://github.com/ksoichiro/Android-ObservableScrollView</a></span></p>
<p><span style="font-size: 15px">作者：Soichiro Kashima</span></p>
<p><span style="font-size: 15px">使用：</span></p>
<div class="cnblogs_code">

<pre>compile com.github.ksoichiro:android-observablescrollview</pre>

</div>

<h2 id="34circleimageview"><a href="#34-CircleImageView" class="headerlink" title="34.CircleImageView"></a>34.CircleImageView<a href="#34circleimageview" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：圆角ImageView</span></p>
<p><span style="font-size: 15px">上榜理由：也许你已经听说过无数种展示圆角图片的方法，但如果你不尝试尝试CircleImageView，那么你的知识库会因为少了它黯然失色，有的时候完成需求是开发者优先考虑的，不同实现方法牵扯到的性能差异更值得让人深思，如果你有心在<strong>图片性能</strong>上有所涉猎，那么CircleImageView绝对不会让你败兴而归。最后别忘了记得去看Romain Guy的建议哟。</span></p>
<p><span style="font-size: 15px">github <a href="https://github.com/hdodenhof/CircleImageView">https://github.com/hdodenhof/CircleImageView</a></span></p>
<p><span style="font-size: 15px">作者：Henning Dodenhof</span></p>
<p><span style="font-size: 15px">使用：</span></p>
<div class="cnblogs_code">

<pre><span style="color: #000000">dependencies {
    ...
    compile</span> <span style="color: #800000">'</span><span style="color: #800000">de.hdodenhof:circleimageview:2.1.0</span><span style="color: #800000">'</span> <span style="color: #000000">}</span></pre>

</div>

<div class="cnblogs_code">

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

<pre><<span style="color: #000000">de.hdodenhof.circleimageview.CircleImageView
    xmlns:app</span>=<span style="color: #800000">"</span><span style="color: #800000">http://schemas.android.com/apk/res-auto</span><span style="color: #800000">"</span> <span style="color: #000000">android:id</span>=<span style="color: #800000">"</span><span style="color: #800000">@+id/profile_image</span><span style="color: #800000">"</span> <span style="color: #000000">android:layout_width</span>=<span style="color: #800000">"</span><span style="color: #800000">96dp</span><span style="color: #800000">"</span> <span style="color: #000000">android:layout_height</span>=<span style="color: #800000">"</span><span style="color: #800000">96dp</span><span style="color: #800000">"</span> <span style="color: #000000">android:src</span>=<span style="color: #800000">"</span><span style="color: #800000">@drawable/profile</span><span style="color: #800000">"</span> <span style="color: #000000">app:civ_border_width</span>=<span style="color: #800000">"</span><span style="color: #800000">2dp</span><span style="color: #800000">"</span> <span style="color: #000000">app:civ_border_color</span>=<span style="color: #800000">"</span><span style="color: #800000">#FF000000</span><span style="color: #800000">"</span>/></pre>

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

</div>

<h2 id="35logger"><a href="#35-logger" class="headerlink" title="35.logger"></a>35.logger<a href="#35logger" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：一款让log日志优雅显示的框架</span></p>
<p><span style="font-size: 15px">上榜理由：logger作为调试框架，并未给出很强大的能力，它最大的亮点是优雅的输出log信息，并且支持多种格式：线程、Json、Xml、List、Map等，如果你整日沉迷于汪洋大海般的log信息不能自拔，logger就是你的指路明灯！6.6k个star让他位列调试框架第二名，屈居facebook的stetho之后</span></p>
<p><span style="font-size: 15px">github <a href="https://github.com/orhanobut/logger">https://github.com/orhanobut/logger</a></span></p>
<p><span style="font-size: 15px">作者：Orhan Obut</span></p>
<p><span style="font-size: 15px">使用：</span></p>
<div class="cnblogs_code">

<pre>compile <span style="color: #800000">'</span><span style="color: #800000">com.orhanobut:logger:2.1.1</span><span style="color: #800000">'</span></pre>

</div>

<div class="cnblogs_code">

<pre><span style="color: #000000">Logger.d(MAP);
Logger.d(SET);
Logger.d(LIST);
Logger.d(ARRAY);</span> <span style="color: #000000">Logger.json(JSON_CONTENT);
Logger.xml(XML_CONTENT);</span></pre>

</div>

<h2 id="36agera"><a href="#36-agera" class="headerlink" title="36.agera"></a>36.agera<a href="#36agera" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍:一款服务于Android平台的响应式编程框架</span></p>
<p><span style="font-size: 15px">上榜理由：google专门推出一套响应式编程框架服务于Android开发者，相比于之响应式编程框架榜首的 RxJava RxAndroid，它更轻量，两者最大的不同点在于agera基于push event、pull data （VS Rx系列 push data）。</span></p>
<p><span style="font-size: 15px">github <a href="https://github.com/google/agera">https://github.com/google/agera</a></span></p>
<p><span style="font-size: 15px">作者：Google</span></p>
<p><span style="font-size: 15px">使用：</span></p>
<div class="cnblogs_code">

<pre>  compile <span style="color: #800000">'</span><span style="color: #800000">com.google.android.agera:agera:1.3.0</span><span style="color: #800000">'</span></pre>

</div>

<p>扩展能力</p>
<div class="cnblogs_code">

<pre>  compile <span style="color: #800000">'</span><span style="color: #800000">com.google.android.agera:content:1.3.0</span><span style="color: #800000">'</span> <span style="color: #000000">compile</span> <span style="color: #800000">'</span><span style="color: #800000">com.google.android.agera:database:1.3.0</span><span style="color: #800000">'</span> <span style="color: #000000">compile</span> <span style="color: #800000">'</span><span style="color: #800000">com.google.android.agera:net:1.3.0</span><span style="color: #800000">'</span> <span style="color: #000000">compile</span> <span style="color: #800000">'</span><span style="color: #800000">com.google.android.agera:rvadapter:1.3.0</span><span style="color: #800000">'</span> <span style="color: #000000">compile</span> <span style="color: #800000">'</span><span style="color: #800000">com.google.android.agera:rvdatabinding:1.3.0</span><span style="color: #800000">'</span></pre>

</div>

<h2 id="37bottombar"><a href="#37-BottomBar" class="headerlink" title="37.BottomBar"></a>37.BottomBar<a href="#37bottombar" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：一款底部导航栏视图框架</span></p>
<p><span style="font-size: 15px">上榜理由：底部栏里的王者框架，6.3K的star数量，证明了它的优秀，完全遵循材料设计规范，上手非常方便。如果说缺点，无法设置icon与titile的间距，无法自定义视图的大小等，但这些都可以通过修改源代码解决，笔者献丑也修改了一套符合国内开发者的底部导航框架，即将开源。</span></p>
<p><span style="font-size: 15px">github  <a href="https://github.com/roughike/BottomBar">https://github.com/roughike/BottomBar</a></span></p>
<p><span style="font-size: 15px">作者：Iiro Krankka</span></p>
<p><span style="font-size: 15px">使用：</span></p>
<div class="cnblogs_code">

<pre>compile <span style="color: #800000">'</span><span style="color: #800000">com.roughike:bottom-bar:2.3.1</span><span style="color: #800000">'</span></pre>

</div>

<h2 id="38calligraphy"><a href="#38-Calligraphy" class="headerlink" title="38.Calligraphy"></a>38.Calligraphy<a href="#38calligraphy" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：一款自定义字体框架</span></p>
<p><span style="font-size: 15px">上榜理由：如果你还在为一键修改App内所有字体样式而烦恼，6.3K个star的Calligraphy就值得你拥有，它可以同时修改整个整个项目的Textview字体，也可以单独 设置某个Textview的字体，还在等什么，快来试试吧！</span></p>
<p><span style="font-size: 15px">github  <a href="https://github.com/chrisjenx/Calligraphy">https://github.com/chrisjenx/Calligraphy</a></span></p>
<p><span style="font-size: 15px">作者：Christopher Jenkins</span></p>
<p><span style="font-size: 15px">使用：</span></p>
<div class="cnblogs_code">

<pre><span style="color: #000000">dependencies {
    compile</span> <span style="color: #800000">'</span><span style="color: #800000">uk.co.chrisjenx:calligraphy:2.3.0</span><span style="color: #800000">'</span> <span style="color: #000000">}</span></pre>

</div>

<h2 id="39androidslidinguppanel"><a href="#39-AndroidSlidingUpPanel" class="headerlink" title="39.AndroidSlidingUpPanel"></a>39.AndroidSlidingUpPanel<a href="#39androidslidinguppanel" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：可拖动的滑动面板视图框架</span></p>
<p><span style="font-size: 15px">上榜理由：如果你的项目需要一个可拖拽的滑动式面板（展示某些详情信息，播放音乐，地图信息等），那么推荐你使用它，6.3k个star，来自创业公司umano的作品，证明它是用心推出的杰作</span></p>
<p><span style="font-size: 15px">github <a href="https://github.com/umano/AndroidSlidingUpPanel">https://github.com/umano/AndroidSlidingUpPanel</a></span></p>
<p><span style="font-size: 15px">作者：umano<span class="author"><a href="https://github.com/umano">
</a></span></span></p>
<p><span style="font-size: 15px">使用：</span></p>
<div class="cnblogs_code">

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

<pre><span style="color: #000000">dependencies {
    repositories {
        mavenCentral()
    }
    
    compile</span> <span style="color: #800000">'</span><span style="color: #800000">com.sothree.slidinguppanel:library:3.3.1</span><span style="color: #800000">'</span> <span style="color: #000000">}</span></pre>

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

</div>

<h2 id="40appintro"><a href="#40-AppIntro" class="headerlink" title="40.AppIntro"></a>40.AppIntro<a href="#40appintro" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：一款提供快速制作欢迎页的框架</span></p>
<p><span style="font-size: 15px">上榜理由：笔者从未把打算把欢迎页框架纳入排行榜当中，作为国内开发者，ViewPager开发App的欢迎页已经是手到擒来的需求，为何一个开源的欢迎页框架会在github上拥有6.3k个star？也许你会不屑一顾，是的，往往就在不屑一顾的瞬间，机遇就悄悄溜走了。</span></p>
<p><span style="font-size: 15px">github <a href="https://github.com/apl-devs/AppIntro">https://github.com/apl-devs/AppIntro</a></span></p>
<p><span style="font-size: 15px">作者：Paolo Rotolo</span></p>
<div class="cnblogs_code">

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

<pre> <span style="color: #000000">allprojects {
        repositories {
            ...
            maven { url</span> <span style="color: #800000">'</span><span style="color: #800000">https://jitpack.io</span><span style="color: #800000">'</span> <span style="color: #000000">}
        }
    }
    
    dependencies {
            compile</span> <span style="color: #800000">'</span><span style="color: #800000">com.github.apl-devs:appintro:v4.2.0</span><span style="color: #800000">'</span> <span style="color: #000000">}</span></pre>

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

</div>

<h2 id="41recyclerview-animators"><a href="#41-recyclerview-animators" class="headerlink" title="41.recyclerview-animators"></a>41.recyclerview-animators<a href="#41recyclerview-animators" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：一款为Recyclerview提供扩展动画能力的框架</span></p>
<p><span style="font-size: 15px">上榜理由：有一句老话：如果有天你失去对新事物的兴趣，那就说明你老了。recyclerview已经推出快三年了，还在用listview的人们，是否已经发掘自己渐渐变老；不要灰心，快为你的项目加入recyclerview-animators框架吧，为“自己”加入新鲜的血液和能量！（笔者备注：6.2K个star）</span></p>
<p><span style="font-size: 15px">github  <a href="https://github.com/wasabeef/recyclerview-animators">https://github.com/wasabeef/recyclerview-animators</a></span></p>
<p><span style="font-size: 15px">作者；<a href="https://github.com/wasabeef">https://github.com/wasabeef</a></span></p>
<p><span style="font-size: 15px">使用：</span></p>
<div class="cnblogs_code">

<pre><span style="color: #000000">dependencies {</span> <span style="color: #008000">//</span> <span style="color: #008000">jCenter</span>
  compile <span style="color: #800000">'</span><span style="color: #800000">jp.wasabeef:recyclerview-animators:2.2.6</span><span style="color: #800000">'</span> <span style="color: #000000">}</span></pre>

</div>

<h2 id="42dagger"><a href="#42-dagger" class="headerlink" title="42.dagger"></a>42.dagger<a href="#42dagger" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：一款通过依赖注入降低程序间耦合的开发框架</span></p>
<p><span style="font-size: 15px">上榜理由：github 上dagger1版本 有6.2k个star ， dagger2版本有7.3k个；由square完成的dagger1版本，到如今google团队接手的dagger2版本，强力开发团队保证了代码在设计上的优越性；如果你想探究Android 领域的设计模式，这也是不错的选择。</span></p>
<p><span style="font-size: 15px">官网地址：<a href="https://google.github.io/dagger/">https://google.github.io/dagger/</a></span></p>
<p><span style="font-size: 15px">github ：<a href="https://github.com/google/dagger">https://github.com/google/dagger</a></span></p>
<p><span style="font-size: 15px">作者：google</span></p>
<p><span style="font-size: 15px">使用：</span></p>
<div class="cnblogs_code">

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

<pre><span style="color: #000000">dependencies {
  compile</span> <span style="color: #800000">'</span><span style="color: #800000">com.google.dagger:dagger:2.x</span><span style="color: #800000">'</span> <span style="color: #000000">annotationProcessor</span> <span style="color: #800000">'</span><span style="color: #800000">com.google.dagger:dagger-compiler:2.x</span><span style="color: #800000">'</span> <span style="color: #000000">}
If you</span><span style="color: #800000">'</span><span style="color: #800000">re using classes in dagger.android you</span><span style="color: #800000">'</span><span style="color: #000000">ll also want to include:

compile</span> <span style="color: #800000">'</span><span style="color: #800000">com.google.dagger:dagger-android:2.x</span><span style="color: #800000">'</span> <span style="color: #000000">compile</span> <span style="color: #800000">'</span><span style="color: #800000">com.google.dagger:dagger-android-support:2.x</span><span style="color: #800000">'</span>
annotationProcessor <span style="color: #800000">'</span><span style="color: #800000">com.google.dagger:dagger-android-processor:2.x</span><span style="color: #800000">'</span></pre>

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

</div>

<h2 id="43android-bootstarp"><a href="#43-Android-Bootstarp" class="headerlink" title="43.Android-Bootstarp"></a>43.Android-Bootstarp<a href="#43android-bootstarp" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：一款提供在Android应用上实现Bootstrap（web框架）所作出效果的框架</span></p>
<p><span style="font-size: 15px">上榜理由：榜单上第二款响应web技术的Android 端框架，还记得第一名是谁吗——flexbox-layout，作为Android开发者，你有必要去了解Web技术了。5.9k个star，证明它不容小觑</span></p>
<p><span style="font-size: 15px">github <a href="https://github.com/Bearded-Hen/Android-Bootstrap">https://github.com/Bearded-Hen/Android-Bootstrap</a></span></p>
<p><span style="font-size: 15px">作者:Bearded-Hen团队</span></p>
<p><span style="font-size: 15px">使用：</span></p>
<div class="cnblogs_code">

<pre><span style="color: #000000">dependencies {
   compile</span> <span style="color: #800000">'</span><span style="color: #800000">com.beardedhen:androidbootstrap:{X.X.X}</span><span style="color: #800000">'</span> <span style="color: #000000">}</span></pre>

</div>

<h2 id="44rxbinding"><a href="#44-RxBinding" class="headerlink" title="44.RxBinding"></a>44.RxBinding<a href="#44rxbinding" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：一款提供UI组件事件响应能力的框架</span></p>
<p><span style="font-size: 15px">上榜理由：如果你还未开始RxAndroid 之旅，RxBinding可以作为你的第一站，通过RXBinding，你将理解响应式编程的快乐，让项目里的事件流程更清晰。5.6K个star，RxAndroid作者亲自操刀，快来试用吧！</span></p>
<p><span style="font-size: 15px">github  <a href="https://github.com/JakeWharton/RxBinding">https://github.com/JakeWharton/RxBinding</a></span></p>
<p><span style="font-size: 15px">作者：JakeWharton</span></p>
<div class="cnblogs_code">

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

<pre><span style="color: #000000">Platform bindings:

compile</span> <span style="color: #800000">'</span><span style="color: #800000">com.jakewharton.rxbinding2:rxbinding:2.0.0</span><span style="color: #800000">'</span>
<span style="color: #800000">'</span><span style="color: #800000">support-v4</span><span style="color: #800000">'</span> <span style="color: #000000">library bindings:

compile</span> <span style="color: #800000">'</span><span style="color: #800000">com.jakewharton.rxbinding2:rxbinding-support-v4:2.0.0</span><span style="color: #800000">'</span>
<span style="color: #800000">'</span><span style="color: #800000">appcompat-v7</span><span style="color: #800000">'</span> <span style="color: #000000">library bindings:

compile</span> <span style="color: #800000">'</span><span style="color: #800000">com.jakewharton.rxbinding2:rxbinding-appcompat-v7:2.0.0</span><span style="color: #800000">'</span>
<span style="color: #800000">'</span><span style="color: #800000">design</span><span style="color: #800000">'</span> <span style="color: #000000">library bindings:

compile</span> <span style="color: #800000">'</span><span style="color: #800000">com.jakewharton.rxbinding2:rxbinding-design:2.0.0</span><span style="color: #800000">'</span>
<span style="color: #800000">'</span><span style="color: #800000">recyclerview-v7</span><span style="color: #800000">'</span> <span style="color: #000000">library bindings:

compile</span> <span style="color: #800000">'</span><span style="color: #800000">com.jakewharton.rxbinding2:rxbinding-recyclerview-v7:2.0.0</span><span style="color: #800000">'</span>
<span style="color: #800000">'</span><span style="color: #800000">leanback-v17</span><span style="color: #800000">'</span> <span style="color: #000000">library bindings:

compile</span> <span style="color: #800000">'</span><span style="color: #800000">com.jakewharton.rxbinding2:rxbinding-leanback-v17:2.0.0</span><span style="color: #800000">'</span></pre>

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

</div>

<h2 id="45listviewanimations"><a href="#45-ListViewAnimations" class="headerlink" title="45.ListViewAnimations"></a>45.ListViewAnimations<a href="#45listviewanimations" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：一款为ListView提供动展示画效果能力的框架</span></p>
<p><span style="font-size: 15px">上榜理由：如果有一天我承认自己老了，我还会排排我的兄弟——ListView，证明我和它一起战斗过。ListViewAnimations的存在就是证明我们这些“老年人”仍有用武之地，也许你有说不出口的难处，无法体会到RecyclerView里动画的快乐，拥有ListViewAnimations，你一样可以骄傲的说，我的孩子（每个item）也有自己的动效啦。（笔者备注 5.6K个star）</span></p>
<p><span style="font-size: 15px">github  <a href="https://github.com/nhaarman/ListViewAnimations">https://github.com/nhaarman/ListViewAnimations</a></span></p>
<p><span style="font-size: 15px">作者：nhaarman</span></p>
<p><span style="font-size: 15px">使用：</span></p>
<div class="cnblogs_code">

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

<pre><span style="color: #000000">repositories {
    mavenCentral()
}

dependencies {
    compile</span> <span style="color: #800000">'</span><span style="color: #800000">com.nhaarman.listviewanimations:lib-core:3.1.0@aar</span><span style="color: #800000">'</span> <span style="color: #000000">compile</span> <span style="color: #800000">'</span><span style="color: #800000">com.nhaarman.listviewanimations:lib-manipulation:3.1.0@aar</span><span style="color: #800000">'</span> <span style="color: #000000">compile</span> <span style="color: #800000">'</span><span style="color: #800000">com.nhaarman.listviewanimations:lib-core-slh:3.1.0@aar</span><span style="color: #800000">'</span> <span style="color: #000000">}</span></pre>

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

</div>

<h2 id="46uitimaterecyclerview"><a href="#46-UItimateRecyclerView" class="headerlink" title="46.UItimateRecyclerView"></a>46.UItimateRecyclerView<a href="#46uitimaterecyclerview" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：一款提供刷新、加载更多、动画特效等额外能力的RecyclerView框架</span></p>
<p><span style="font-size: 15px">上榜理由：榜单上第三次出现RecyclerView的身影，足以证明RecyclerView的优异性，5.5K个star，框架里所提供众多的能力，如果你是个功利开发者，那么此框架会为你节省很多学习时间，它可以完成多item式布局的大多数需求，值得注意的是，这个项目也是在其他项目的思路上二次开发的。</span></p>
<p><span style="font-size: 15px">github  <a href="https://github.com/cymcsg/UltimateRecyclerView">https://github.com/cymcsg/UltimateRecyclerView</a></span></p>
<p><span style="font-size: 15px">作者：MarshalChen</span></p>
<p><span style="font-size: 15px">使用</span>：</p>
<div class="cnblogs_code">

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

<pre><span style="color: #000000">repositories {
    jcenter()
    }
dependencies {
    ...
    compile</span> <span style="color: #800000">'</span><span style="color: #800000">com.marshalchen.ultimaterecyclerview:library:0.7.2</span><span style="color: #800000">'</span> <span style="color: #000000">}</span></pre>

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

</div>

<h2 id="47ucrop"><a href="#47-uCrop" class="headerlink" title="47.uCrop"></a>47.uCrop<a href="#47ucrop" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：一款优雅的图片裁剪框架</span></p>
<p><span style="font-size: 15px">上榜理由：5.3K个star，图片编辑模块单独拎出来也是一款优雅的App。</span></p>
<p><span style="font-size: 15px">github  <a href="https://github.com/Yalantis/uCrop">https://github.com/Yalantis/uCrop</a></span></p>
<p><span style="font-size: 15px">作者：Yalantis</span></p>
<p><span style="font-size: 15px">使用：</span></p>
<div class="cnblogs_code">

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

<pre><span style="color: #000000">allprojects {
   repositories {
      jcenter()
      maven { url</span> <span style="color: #800000">"</span><span style="color: #800000">https://jitpack.io</span><span style="color: #800000">"</span> <span style="color: #000000">}
   }
}

compile</span> <span style="color: #800000">'</span><span style="color: #800000">com.github.yalantis:ucrop:2.2.1</span><span style="color: #800000">'</span> </pre>

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

</div>

<h2 id="48rxjava-android-samples"><a href="#48-RxJava-Android-Samples" class="headerlink" title="48.RxJava-Android-Samples"></a>48.RxJava-Android-Samples<a href="#48rxjava-android-samples" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：一款介绍RxJava使用场景的app</span></p>
<p><span style="font-size: 15px">上榜理由：榜单出现的第一个<strong>“仅仅为告诉你如何使用另一个项目”</strong>的开源项目，它可以说是RxJava的用例，你想得到的想不到的RxJava用法这里都有，这就是为什么它以5.2k个star矗立在这份榜单里的原因。遗憾自己没有创作这么一个受人追捧的demo？赶快动手写个其他的“XX项目用例吧”</span></p>
<p><span style="font-size: 15px">github  <a href="https://github.com/kaushikgopal/RxJava-Android-Samples">https://github.com/kaushikgopal/RxJava-Android-Samples</a></span></p>
<p><span style="font-size: 15px">作者：kaushikgopal</span></p>
<p><span style="font-size: 15px">使用：</span></p>
<p><span style="font-size: 15px">clone到本地慢慢探索吧</span></p>
<h2 id="49androidautolayout"><a href="#49-AndroidAutoLayout" class="headerlink" title="49.AndroidAutoLayout"></a>49.AndroidAutoLayout<a href="#49androidautolayout" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：一个提供适配能力的框架</span></p>
<p><span style="font-size: 15px">上榜理由：5.2K个star，鸿洋老弟的作品，适合小项目的开发团队，拿到设计MM的px像素设计稿是不是很头疼捏？这个框架一键式搞定你的问题，它有很多的不足，但在追求完美适配的路上，你值得探索和了解它！笔者并不推荐把它应用到已经成熟运行的项目中，毕竟市面上已经有太多的适配解决方案了，适配问题就像是个大杂烩，想炒一盘好菜，就得备好各种佐料（适配小方案），当你把各种小佐料用的炉火纯青的时候，你离美食大厨就不远了。</span></p>
<p><span style="font-size: 15px">github <a href="https://github.com/hongyangAndroid/AndroidAutoLayout">https://github.com/hongyangAndroid/AndroidAutoLayout</a></span></p>
<p><span style="font-size: 15px">作者：张鸿洋</span></p>
<p><span style="font-size: 15px">使用：</span></p>
<div class="cnblogs_code">

<pre><span style="color: #000000">dependencies {
    compile</span> <span style="color: #800000">'</span><span style="color: #800000">com.zhy:autolayout:1.4.5</span><span style="color: #800000">'</span> <span style="color: #000000">}</span></pre>

</div>

<h2 id="50effectiveandroidui"><a href="#50-EffectiveAndroidUI" class="headerlink" title="50.EffectiveAndroidUI"></a>50.EffectiveAndroidUI<a href="#50effectiveandroidui" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：一款讲解高效展示UI的教学型App</span></p>
<p><span style="font-size: 15px">上榜理由：编程新手很难对MVC MVP,MVVM等模式有深刻的理解，如果有一个示例型app，那对初学者会有很大裨益，笔者在遇到它时也是相见恨晚。4.8K个star，证明了它经受了广大开发者的考验与审视，其中Effective UI的编程思想更是与Android官方课程里的Effective UI课程不谋而合，并且，此项目还包含了fragment、dagger、主题样式、Butterknife等众多小知识点，作为编程初学者的学习用例再适合不过了</span></p>
<p><span style="font-size: 15px">github  <a href="https://github.com/pedrovgs/EffectiveAndroidUI">https://github.com/pedrovgs/EffectiveAndroidUI</a></span></p>
<p><span style="font-size: 15px">作者：Pedro Vicente </span></p>
<p><span style="font-size: 15px">使用：</span></p>
<p><span style="font-size: 15px">clone项目到本地</span></p>
<h2 id="51luban"><a href="#51-Luban" class="headerlink" title="51.Luban"></a>51.Luban<a href="#51luban" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：最接近微信的图片压缩框架</span></p>
<p><span style="font-size: 15px">上榜理由：好的思路总是可以让你大放异彩，Luban仅以图片压缩单一功能，俘获了4.8K个star，证明了它在图片压缩上的造诣，它可能不是最优秀的，但它是让你我最接近伟大的项目</span></p>
<p><span style="font-size: 15px">github  <a href="https://github.com/Curzibn/Luban">https://github.com/Curzibn/Luban</a></span></p>
<p><span style="font-size: 15px">作者：Curzibn</span></p>
<p><span style="font-size: 15px">使用：</span></p>
<div class="cnblogs_code">

<pre>compile <span style="color: #800000">'</span><span style="color: #800000">top.zibin:Luban:1.1.1</span><span style="color: #800000">'</span></pre>

</div>

<h2 id="52droidplugin"><a href="#52-DroidPlugin" class="headerlink" title="52.DroidPlugin"></a>52.DroidPlugin<a href="#52droidplugin" class="header-anchor">#</a></h2><p>一句话介绍：一款热门的插件化开发框架</p>
<p>上榜理由：4.8K个star，插件化框架榜单第一名，，360团队出品，框架质量有保证，有成功案例——360手机助手，并且持续维护着</p>
<p>github <a href="https://github.com/DroidPluginTeam/DroidPlugin/blob/master/readme_cn.md">https://github.com/DroidPluginTeam/DroidPlugin/blob/master/readme_cn.md</a></p>
<p>作者：Andy Zhang</p>
<p>使用:</p>
<p>clone项目到本地</p>
<h2 id="53-otto"><a href="#53-otto" class="headerlink" title="53. otto"></a>53. otto<a href="#53-otto" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍:一款老旧且强大的事件总线框架</span></p>
<p><span style="font-size: 15px">上榜理由：4.8K个star，是square团队早先推出的事件响应型框架，淘宝app的事件驱动也是基于此框架封装的，如今square已经建议开发者采用RxJava RxAndroid来代替otto了。但otto仍有与EventBus横向对比的价值，纵向来说，otto与square自家开发的Rx系列框架的差异同样值得开发者们去探究。</span></p>
<p><span style="font-size: 15px">github <a href="https://github.com/square/otto">https://github.com/square/otto</a></span></p>
<p><span style="font-size: 15px">作者：square</span></p>
<p><span style="font-size: 15px">使用：</span></p>
<div class="cnblogs_code">

<pre><span style="color: #000000">repositories {
    mavenCentral()
    maven { url</span> <span style="color: #800000">"</span><span style="color: #800000">https://oss.sonatype.org/content/repositories/snapshots/</span><span style="color: #800000">"</span> <span style="color: #000000">}
}

compile</span> <span style="color: #800000">'</span><span style="color: #800000">com.michaelpardo:activeandroid:3.1.0-SNAPSHOT</span><span style="color: #800000">'</span></pre>

</div>

<h2 id="54u2020"><a href="#54-u2020" class="headerlink" title="54.u2020"></a>54.u2020<a href="#54u2020" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：一款提供<strong>Dagger的高级教学示例</strong>的app（额，名字是有点绕）</span></p>
<p><span style="font-size: 15px">上榜理由：4.7K个star，JakeWharton牵头开发的教学类app，教你使用Dagger在其他高级框架的用法，它展示了Dagger与ButterKnife、Retrofit、Moshi、Picasso、Okhttp、RxJava、Timber、Madge、LeakCanar等众多优秀框架结合起来的高级用法，你也可以借鉴到自己的项目当中</span></p>
<p><span style="font-size: 15px">github  <a href="https://github.com/JakeWharton/u2020">https://github.com/JakeWharton/u2020</a></span></p>
<p><span style="font-size: 15px">作者：JakeWharton</span></p>
<p><span style="font-size: 15px"> </span></p>
<h2 id="55buck"><a href="#55-buck" class="headerlink" title="55.buck"></a>55.buck<a href="#55buck" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：buck是一个快速构建系统</span></p>
<p><span style="font-size: 15px">上榜理由：facebook+google出身的作者，对构建代码的出色理解，加上大型团队的维护，以及增量更新时的快速高效，让buck成为了微信Android团队构建项目的首选，构建大型项目时，它比gradle更快，然而中小公司并不适合此框架，但作为立志在框架设计领域有一番作为的人们，欢迎来一探究竟</span></p>
<p><span style="font-size: 15px">官网地址：<a href="https://buckbuild.com/">https://buckbuild.com/</a></span></p>
<p><span style="font-size: 15px">github  <a href="https://github.com/facebook/buck">https://github.com/facebook/buck</a></span></p>
<p><span style="font-size: 15px">作者：facebook</span></p>
<p><span style="font-size: 15px">使用：</span></p>
<div class="cnblogs_code">

<pre>linux or mac system  +docs</pre>

</div>

<h2 id="56permissionsdispatcher"><a href="#56-PermissionsDispatcher" class="headerlink" title="56.PermissionsDispatcher"></a>56.PermissionsDispatcher<a href="#56permissionsdispatcher" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：一款基于注解的提供<strong>解决运行时危险权限</strong>方案的框架</span></p>
<p><span style="font-size: 15px">上榜理由：自Android6.0 Google提出危险权限一词起，用户安全性被提到一定的高度，一些运行时对用户较为危险的权限将不再自动被开发者获取，需要经过用户批准，开发者才可以继续使用该权限，如果你曾经被权限问题搞的抓耳挠腮，建议你试试这个框架，它足够解决你的问题</span></p>
<p><span style="font-size: 15px">官网地址：<a href="https://hotchemi.github.io/PermissionsDispatcher/">https://hotchemi.github.io/PermissionsDispatcher/</a></span></p>
<p><span style="font-size: 15px">github <a href="https://github.com/hotchemi/PermissionsDispatcher">https://github.com/hotchemi/PermissionsDispatcher</a></span></p>
<p><span style="font-size: 15px">作者：Shintaro Katafuchi</span></p>
<p><span style="font-size: 15px">使用：</span></p>
<div class="cnblogs_code">

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

<pre><span style="color: #000000">dependencies {
  compile(</span><span style="color: #800000">'</span><span style="color: #800000">com.github.hotchemi:permissionsdispatcher:${latest.version}</span><span style="color: #800000">'</span><span style="color: #000000">) {</span>
      exclude module: <span style="color: #800000">"</span><span style="color: #800000">support-v13</span><span style="color: #800000">"</span> <span style="color: #000000">}
  annotationProcessor</span> <span style="color: #800000">'</span><span style="color: #800000">com.github.hotchemi:permissionsdispatcher-processor:${latest.version}</span><span style="color: #800000">'</span> <span style="color: #000000">}</span>  <span style="color: #000000">repositories {
  jcenter()
  maven { url</span> <span style="color: #800000">'</span><span style="color: #800000">http://oss.jfrog.org/artifactory/oss-snapshot-local/</span><span style="color: #800000">'</span> <span style="color: #000000">}
}</span></pre>

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

</div>

<h2 id="57android-gif-drawable"><a href="#57-android-gif-drawable" class="headerlink" title="57.android-gif-drawable"></a>57.android-gif-drawable<a href="#57android-gif-drawable" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍:一款提供展示GIF动画能力的视图框架</span></p>
<p><span style="font-size: 15px">上榜理由：据我所查国内著名App——知乎使用了android-gif-drawable，因此证明了它的存在价值，尽管在榜单第十一位介绍了lottie-android直接应用AE动画的示例，但AE设计师不是每个公司都配备的，GIF的存在，就必然存在了展示GIF的需要，它值得你拥有！</span></p>
<p><span style="font-size: 15px">github <a href="https://github.com/koral--/android-gif-drawable">https://github.com/koral–/android-gif-drawable</a></span></p>
<p><span style="font-size: 15px">作者：Karol Wrótniak</span></p>
<p><span style="font-size: 15px">使用：</span></p>
<div class="cnblogs_code">

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

<pre><span style="color: #000000">repositories {
    mavenCentral()
    maven { url</span> <span style="color: #800000">"</span><span style="color: #800000">https://oss.sonatype.org/content/repositories/snapshots</span><span style="color: #800000">"</span> <span style="color: #000000">}
}
dependencies {
    compile</span> <span style="color: #800000">'</span><span style="color: #800000">pl.droidsonroids.gif:android-gif-drawable:1.2.+</span><span style="color: #800000">'</span> <span style="color: #000000">}</span></pre>

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

</div>

<h2 id="58apktool"><a href="#58-Apktool" class="headerlink" title="58.Apktool"></a>58.Apktool<a href="#58apktool" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：一款反编译apk的工具</span></p>
<p><span style="font-size: 15px">上榜理由：开源的反编译工具，对于志在了解apk逆向破解的诸位，值得拥有，4.5k个star，逆向破解apk神器！</span></p>
<p><span style="font-size: 15px">github  <a href="https://github.com/iBotPeaches/Apktool">https://github.com/iBotPeaches/Apktool</a></span></p>
<p><span style="font-size: 15px">官网地址：<a href="https://ibotpeaches.github.io/Apktool/">https://ibotpeaches.github.io/Apktool/</a></span></p>
<p><span style="font-size: 15px">作者：Connor Tumbleson</span></p>
<h2 id="59dynamic-load-apk"><a href="#59-dynamic-load-apk" class="headerlink" title="59.dynamic-load-apk"></a>59.dynamic-load-apk<a href="#59dynamic-load-apk" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：插件化开发框架</span></p>
<p><span style="font-size: 15px">上榜理由：4.5k个star，位于插件化开发框架第二名（第一名来自360团队），全面的文档介绍让你很快就能上手插件化开发，如果你喜欢大段文字讲解，那么这个项目一定适合你</span></p>
<p><span style="font-size: 15px">github：<a href="https://github.com/singwhatiwanna/dynamic-load-apk">https://github.com/singwhatiwanna/dynamic-load-apk</a></span></p>
<p><span style="font-size: 15px">作者：singwhatiwanna</span></p>
<p><span style="font-size: 15px">使用：</span></p>
<p><span style="font-size: 15px">github上的文档配合作者博客更配哟</span></p>
<h2 id="60atlas"><a href="#60-atlas" class="headerlink" title="60.atlas"></a>60.atlas<a href="#60atlas" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：淘宝推出的组件化开发框架</span></p>
<p><span style="font-size: 15px">上榜理由：淘宝团队所出的精品，atlas框架提供了解耦、组件、动态的开发能力，4.5k个star让他位列组件化开发框架第一名</span></p>
<p><span style="font-size: 15px">github <a href="https://github.com/alibaba/atlas">https://github.com/alibaba/atlas</a></span></p>
<p><span style="font-size: 15px">作者：alibaba</span></p>
<h2 id="61volley"><a href="#61-volley" class="headerlink" title="61.volley"></a>61.volley<a href="#61volley" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：google推荐使用的Android端网络请求框架</span></p>
<p><span style="font-size: 15px">上榜理由：4.4k个star，并不是他不够优秀，而是使用volley已经渐渐成为广大开发者的习惯</span></p>
<p><span style="font-size: 15px">github h<a target="_blank">ttps://github.com/google/volley</a>（新版volley地址）</span></p>
<p><span style="font-size: 15px">作者：google</span></p>
<p><span style="font-size: 15px">使用：</span></p>
<p><span style="font-size: 15px">clone源码到本地</span></p>
<h2 id="62androidmvp"><a href="#62-androidmvp" class="headerlink" title="62.androidmvp"></a>62.androidmvp<a href="#62androidmvp" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：一款展示Android端Mvp设计的demo</span></p>
<p><span style="font-size: 15px">上榜理由：榜单里为数不多、仅凭展示某种设计模式就获得4.2K个star的项目，如果你有尝试mvp的打算，androidmvp可以作为你的前哨站</span></p>
<p><span style="font-size: 15px">github  <a href="https://github.com/antoniolg/androidmvp">https://github.com/antoniolg/androidmvp</a></span></p>
<p><span style="font-size: 15px">作者：Antonio Leiva</span></p>
<p><span style="font-size: 15px">使用：</span></p>
<p><span style="font-size: 15px">clone到本地</span></p>
<h2 id="63swipebacklayout"><a href="#63-SwipeBackLayout" class="headerlink" title="63.SwipeBackLayout"></a>63.SwipeBackLayout<a href="#63swipebacklayout" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍:一款可以让你通过滑动手势关闭页面的的框架</span></p>
<p><span style="font-size: 15px">上榜理由：仿微信滑动退出当前聊天界面的效果，提供了activity的滑动关闭能力，通过这种思路，实现fragment的滑动关闭轻而易举;笔者坚持建议诸位clone源码到本地探索一番；4.2k个star证明很多人都喜爱它</span></p>
<p><span style="font-size: 15px">github <a href="https://github.com/ikew0ng/SwipeBackLayout">https://github.com/ikew0ng/SwipeBackLayout</a></span></p>
<p><span style="font-size: 15px">作者：ike_w0ng</span></p>
<p><span style="font-size: 15px"> 使用:</span></p>
<div class="cnblogs_code">

<pre>compile <span style="color: #800000">'</span><span style="color: #800000">me.imid.swipebacklayout.lib:library:1.0.0</span><span style="color: #800000">'</span></pre>

</div>

<h2 id="64flycotablayout"><a href="#64-FlycoTabLayout" class="headerlink" title="64.FlycoTabLayout"></a>64.FlycoTabLayout<a href="#64flycotablayout" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：一款可以让作出多种多样指示器效果的框架</span></p>
<p><span style="font-size: 15px">上榜理由：尽管我们没有理由为了给app加入页面指示器功能就集成2.5M的依赖库，但是作为了解viewpager或swip views的指示器设计原理的优秀框架，你值得打开它试试，笔者建议单独拆分所需源码，加入到自己的项目中去。4.1K个star，二次开发的作品，仍然推荐！</span></p>
<p><span style="font-size: 15px">github  <a href="https://github.com/ikew0ng/SwipeBackLayout">https://github.com/H07000223/FlycoTabLayout</a></span></p>
<p><span style="font-size: 15px">作者：Flyco</span></p>
<h2 id="65android-testing"><a href="#65-android-testing" class="headerlink" title="65.android-testing"></a>65.android-testing<a href="#65android-testing" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：一款展示四大自动化测试框架用例的demo（Espresso，UiAutomator，AndroidJunitRunner，JUnit4）</span></p>
<p><span style="font-size: 15px">上榜理由：学习者经常会陷入似懂非懂的境地，如果你有幸学习过Android Testing Support Library site的课程，那么你一定对android的四大测试框架迫不及待，这款demo非常适合你，快来学习这个4.1k个star的明星项目吧</span></p>
<p><span style="font-size: 15px">github <a href="https://github.com/googlesamples/android-testing">https://github.com/googlesamples/android-testing</a></span></p>
<p><span style="font-size: 15px">作者：googlesampes团队</span></p>
<h2 id="66filedownloader"><a href="#66-FileDownloader" class="headerlink" title="66.FileDownloader"></a>66.FileDownloader<a href="#66filedownloader" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：一款高效、稳定、灵活、易用的<strong>文件下载引擎</strong></span></p>
<p><span style="font-size: 15px">上榜理由：4.1k证明了它有多受人喜爱，文件下载看似简单的背后暗藏了多少的坑坑点点，我知道你有能力自己实现文件下载功能，但优秀的框架可以提升你的设计编码能力，这款框架可以提升你的实力！</span></p>
<p><span style="font-size: 15px">github <a href="https://github.com/lingochamp/FileDownloader">https://github.com/lingochamp/FileDownloader</a></span></p>
<p><span style="font-size: 15px">作者:LingoChamp团队</span></p>
<p><span style="font-size: 15px">使用：</span></p>
<div class="cnblogs_code">

<pre><span style="color: #000000">dependencies {
    compile</span> <span style="color: #800000">'</span><span style="color: #800000">com.liulishuo.filedownloader:library:1.5.5</span><span style="color: #800000">'</span> <span style="color: #000000">}</span></pre>

</div>

<h2 id="67jiecaovideoplayer"><a href="#67-JieCaoVideoPlayer" class="headerlink" title="67.JieCaoVideoPlayer"></a>67.JieCaoVideoPlayer<a href="#67jiecaovideoplayer" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：基于MediaPlayer api——VideoView 的多媒体播放框架</span></p>
<p><span style="font-size: 15px">上榜理由：榜单里第三款多媒体播放框架，它以灵巧的身姿挤入本榜单，精巧是它最大的优点，不到100k，拥有它，你就可以快速开发类似今日头条那样的视频播放效果，4k个star，证明它值得一试</span></p>
<p><span style="font-size: 15px">github <a href="https://github.com/lipangit/JieCaoVideoPlayer">https://github.com/lipangit/JieCaoVideoPlayer</a></span></p>
<p><span style="font-size: 15px">作者：Nathen</span></p>
<p><span style="font-size: 15px">使用：</span></p>
<div class="cnblogs_code">

<pre>compile <span style="color: #800000">'</span><span style="color: #800000">fm.jiecao:jiecaovideoplayer:5.5.4</span><span style="color: #800000">'</span></pre>

</div>

<h2 id="68glide-transformations"><a href="#68-glide-transformations" class="headerlink" title="68.glide-transformations"></a>68.glide-transformations<a href="#68glide-transformations" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：为众多著名图片加载框架<strong>提供图片形状变幻能力</strong>的框架</span></p>
<p><span style="font-size: 15px">上榜理由：在榜单靠前的部分已经介绍过glide，Picasso，Fresco等图片加载框架，glide-transformations就是一款为他们提供图片变形能力的框架，使用起来非常简单，因此受到了大家的喜爱，github上有3.8K个star</span></p>
<p><span style="font-size: 15px">github  <a href="https://github.com/wasabeef/glide-transformations">https://github.com/wasabeef/glide-transformations</a></span></p>
<p><span style="font-size: 15px">作者：Daichi Furiya</span></p>
<p><span style="font-size: 15px">使用：</span></p>
<div class="cnblogs_code">

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

<pre><span style="color: #000000">repositories {
    jcenter()
}

dependencies {
    compile</span> <span style="color: #800000">'</span><span style="color: #800000">jp.wasabeef:glide-transformations:2.0.2</span><span style="color: #800000">'</span>
    <span style="color: #008000">//</span> <span style="color: #008000">If you want to use the GPU Filters</span>
    compile <span style="color: #800000">'</span><span style="color: #800000">jp.co.cyberagent.android.gpuimage:gpuimage-library:1.4.1</span><span style="color: #800000">'</span> <span style="color: #000000">}</span></pre>

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

</div>

<p><span style="font-size: 15px">在Glide里设置变幻效果</span></p>
<div class="cnblogs_code">

<pre><span style="color: #000000">Set Glide Transform.

Glide.with(</span><span style="color: #0000ff">this</span><span style="color: #000000">).load(R.drawable.demo)
        .bitmapTransform(</span><span style="color: #0000ff">new</span> <span style="color: #000000">BlurTransformation(context))
        .into((ImageView) findViewById(R.id.image));</span></pre>

</div>

<h2 id="69android-gpuimage"><a href="#69-android-gpuimage" class="headerlink" title="69.android-gpuimage"></a>69.android-gpuimage<a href="#69android-gpuimage" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：一款基于OpenGL的图片渲染引擎</span></p>
<p><span style="font-size: 15px">上榜理由：放下GpuImage在IOS平台的荣誉不谈，Android版的android-gpuimage就提供多达70多种图片渲染效果，你还在好奇美图秀秀是如何实现图片变幻的？有了它，一切都不是问题。如果你是美图工具类的工程师，此框架的建设思路也会对你大有裨益。笔者也是通过android-gpuimage仿造了美图App并俘获女友芳心的，再次为它的实力点赞。ios版+android版一共19k个star，已经证明了它的实力，还在等什么呢？</span></p>
<p><span style="font-size: 15px">github：<a href="https://github.com/CyberAgent/android-gpuimage">https://github.com/CyberAgent/android-gpuimage</a></span></p>
<p><span style="font-size: 15px">作者：CyberAgent 团队</span></p>
<p><span style="font-size: 15px">使用：</span></p>
<div class="cnblogs_code">

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

<pre><span style="color: #000000">repositories {
    jcenter()
}

dependencies {
    compile</span> <span style="color: #800000">'</span><span style="color: #800000">jp.co.cyberagent.android.gpuimage:gpuimage-library:1.4.1</span><span style="color: #800000">'</span> <span style="color: #000000">}</span></pre>

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

</div>

<p><span style="font-size: 15px">更多的改造方法，还需要阅读Ios的编程文档，对于有毅力的小伙伴强力推荐！</span></p>
<h2 id="70rxpermissions"><a href="#70-RxPermissions" class="headerlink" title="70.RxPermissions"></a>70.RxPermissions<a href="#70rxpermissions" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：一款基于RxJava完成权限申请的框架</span></p>
<p><span style="font-size: 15px">上榜理由：榜单里第二款提供权服务的框架，基于RxJava的设计，让你可以专心写业务，3.7K个star已经证明了它的实用价值</span></p>
<p><span style="font-size: 15px">github <a href="https://github.com/tbruyelle/RxPermissions">https://github.com/tbruyelle/RxPermissions</a></span></p>
<p><span style="font-size: 15px">作者：Thomas Bruyelle</span></p>
<p><span style="font-size: 15px">使用：</span></p>
<div class="cnblogs_code">

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

<pre><span style="color: #000000">repositories {
    jcenter()</span> <span style="color: #008000">//</span> <span style="color: #008000">If not already there</span>
<span style="color: #000000">}

dependencies {
    compile</span> <span style="color: #800000">'</span><span style="color: #800000">com.tbruyelle.rxpermissions:rxpermissions:0.9.4@aar</span><span style="color: #800000">'</span> <span style="color: #000000">}</span></pre>

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

</div>

<p><span style="font-size: 15px">优雅的使用：</span></p>
<div class="cnblogs_code">

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

<pre>RxPermissions rxPermissions = <span style="color: #0000ff">new</span> RxPermissions(<span style="color: #0000ff">this</span>);

<span style="color: #000000">rxPermissions
    .request(Manifest.permission.CAMERA)
    .subscribe(granted</span> -> <span style="color: #000000">{</span> <span style="color: #0000ff">if</span> (granted) { <span style="color: #008000">//</span> <span style="color: #008000">I can control the camera now</span>
        } <span style="color: #0000ff">else</span> <span style="color: #000000">{</span> <span style="color: #008000">//</span> <span style="color: #008000">Oups permission denied</span>
 <span style="color: #000000">}
    });</span></pre>

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

</div>

<h2 id="71freeline"><a href="#71-freeline" class="headerlink" title="71.freeline"></a>71.freeline<a href="#71freeline" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：一款动态替换的编译构建框架</span></p>
<p><span style="font-size: 15px">上榜理由：继Facebook的Buck，Androdi官方的InstRun之后，蚂蚁金服推出了Freeline编译框架，官网宣称**Freeline与业内主流构建方式相比仍然有数倍的速度领先;**排行有先后，编译速度并不在本榜单排序的考据因素中，因此freeline以3.7个star，暂列编译框架第二名</span></p>
<p><span style="font-size: 15px">官网地址：<a href="https://www.freelinebuild.com/">https://www.freelinebuild.com/</a></span></p>
<p><span style="font-size: 15px">github：<a href="https://github.com/alibaba/freeline">https://github.com/alibaba/freeline</a></span></p>
<p><span style="font-size: 15px">作者：alibaba</span></p>
<p><span style="font-size: 15px">使用：</span></p>
<div class="cnblogs_code">

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

<pre><span style="color: #000000">buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        classpath</span> <span style="color: #800000">'</span><span style="color: #800000">com.antfortune.freeline:gradle:0.8.7</span><span style="color: #800000">'</span> <span style="color: #000000">}
}</span></pre>

<pre>apply <span class="pl-c1">plugin: <span class="pl-s"><span class="pl-pds">'com.antfortune.freeline<span class="pl-pds">'

<span class="pl-en">android {
    <span class="pl-k">...
}</span></span></span></span></span></span></pre>

<p>File → Settings… → Plugins → Browse repositories →freeline.</p>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

</div>

<h2 id="72rxlifecycle"><a href="#72-RxLifecycle" class="headerlink" title="72.RxLifecycle"></a>72.RxLifecycle<a href="#72rxlifecycle" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：一款提供在<strong>使用RxJava过程中管理Activity和Fragment生命周期能力</strong>的框架</span></p>
<p><span style="font-size: 15px">上榜理由：在榜单靠前的部分，你已经了解RxJava和RxAndroid的强大之处，但部分粗心的开发者因为没有及时取消订阅而产生严重的内存泄漏，不要担心，RxLifecycle可以为你解决难题，在gtihub上拥有3.7K个star，国内知名软件——知乎和淘宝也都在使用它</span></p>
<p><span style="font-size: 15px">github  <a href="https://github.com/trello/RxLifecycle">https://github.com/trello/RxLifecycle</a></span></p>
<p><span style="font-size: 15px">作者：trello团队</span></p>
<p><span style="font-size: 15px">使用：</span></p>
<p><span style="font-size: 15px">clone源码到本地</span></p>
<h2 id="73classyshark"><a href="#73-classyshark" class="headerlink" title="73.classyshark"></a>73.classyshark<a href="#73classyshark" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：一款可执行文件浏览器</span></p>
<p><span style="font-size: 15px">上榜理由：榜单里继Apktool之后第二款apk逆向工具，如果你喜欢优雅的图形数据展示，那么你一定不能错过他，classyshark可以将破解的结果以图形化展示用户，方便分析，3.7K个star，让它暂列apk逆向工具第二位！</span></p>
<p><span style="font-size: 15px">github  <a href="https://github.com/google/android-classyshark">https://github.com/google/android-classyshark</a></span></p>
<p><span style="font-size: 15px">作者：google</span></p>
<p><span style="font-size: 15px">使用：</span></p>
<p><span style="font-size: 15px"><span style="color: #24292e; font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;">下载 </span><a href="https://github.com/google/android-classyshark/releases">JAR</a><span style="color: #24292e; font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;"> </span></span></p>
<h2 id="74acra"><a href="#74-acra" class="headerlink" title="74.acra"></a>74.acra<a href="#74acra" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：一款提供<strong>记录**</strong>APP崩溃日志能力**的框架</span></p>
<p><span style="font-size: 15px">上榜理由：如果你面临着收集APP崩溃日志的需求，那么acra是个不错的选择。3.7K个star，让acra位列崩溃日志框架排行榜第一名，acra有足够的能力记录线上APP，并且发回服务端，acra也提供了相当棒的崩溃日志统计服务端框架<span style="background-color: #f5f8fd; font-family: monospace; text-indent: 28px">Acralyzer</span>，cralyzer工作在Apache CouchDB之上，所以除了CouchDB之外，没有必要安装任何额外的软件，移动端开发者也可以借此学习服务端的建设，一举两得！</span></p>
<p><span style="font-size: 15px">github <a href="https://github.com/ACRA/acra">https://github.com/ACRA/acra</a></span></p>
<p><span style="font-size: 15px">服务端github  <a href="https://github.com/ACRA/acralyzer">https://github.com/ACRA/acralyzer</a></span></p>
<p><span style="font-size: 15px">作者：acra团队</span></p>
<p><span style="font-size: 15px">使用：</span></p>
<p><span style="font-size: 15px">没有什么方法比clone源码到本地更方便了</span></p>
<h2 id="75disklrucache"><a href="#75-DiskLruCache" class="headerlink" title="75.DiskLruCache"></a>75.DiskLruCache<a href="#75disklrucache" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：一款提供<strong>磁盘文件缓存管理能力</strong>的框架</span></p>
<p><span style="font-size: 15px">上榜理由：3.7k个star并不足以说明DiskLruCache的优秀，仅仅以管理磁盘文件能力单独拎出来成为一个框架，作者需要很大的勇气，很幸运，作者做到了，并且也成为Google官网提倡的缓存  ；如还记得上次做“一键清除缓存”、“查看缓存文件大小”功能是什么时候吗？DiskLruCache一句话就可以搞定！</span></p>
<p><span style="font-size: 15px">github <a href="https://github.com/JakeWharton/DiskLruCache">https://github.com/JakeWharton/DiskLruCache</a></span></p>
<p><span style="font-size: 15px">作者：JakeWharton</span></p>
<p><span style="font-size: 15px">使用：</span></p>
<div class="cnblogs_code">

<pre>compile <span style="color: #800000">'</span><span style="color: #800000">com.jakewharton:disklrucache:2.0.2</span><span style="color: #800000">'</span></pre>

</div>

<p><span style="font-size: 15px">或者下载 <a href="https://search.maven.org/remote_content?g=com.jakewharton&a=disklrucache&v=LATEST">latest .jar</a></span></p>
<h2 id="76dexposed"><a href="#76-dexposed" class="headerlink" title="76.dexposed"></a>76.dexposed<a href="#76dexposed" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：一款支撑阿里大部分App客户端热修复、线上调试能力的框架</span></p>
<p><span style="font-size: 15px">上榜理由：榜单上再次出现热修复框架的身影，证明App热修复技术的火热，dexposed提供图形化的性能监控、在线热修复bug漏洞、支持AOP编程思想等，不论你是企业热修复技术的设计者还是打算在热修复领域一探究竟的新人，这款框架很适合你。3.5k个star，证明它作为一门技术框架的存在，是多么令人喜爱！</span></p>
<p><span style="font-size: 15px">github  <a href="https://github.com/alibaba/dexposed">https://github.com/alibaba/dexposed</a></span></p>
<p><span style="font-size: 15px">作者：alibaba</span></p>
<p><span style="font-size: 15px">使用：</span></p>
<div class="cnblogs_code">

<pre><span style="color: #000000">dependencies {
        compile</span> <span style="color: #800000">'</span><span style="color: #800000">com.taobao.android:dexposed:0.1.1@aar</span><span style="color: #800000">'</span> <span style="color: #000000">}</span></pre>

</div>

<h2 id="77litho"><a href="#77-Litho" class="headerlink" title="77.Litho"></a>77.Litho<a href="#77litho" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：一款提供<strong>高效构建UI能力</strong>的框架 </span></p>
<p><span style="font-size: 15px">上榜理由：作为一款专门构建UI的框架，Litho高效的地方在于：单独开辟了用于渲染和布局的线程，然后将创建好的组件传递给UI线程去完成最终的渲染，使用更少的视图层级，来提升界面的滚动速度，值得注意的是，它仅支持开发者作出<strong>不可改变的UI组件</strong> **,**3.5K个star，证明了它在构建UI领域的价值，更多的妙处，期待你亲自去发掘！</span></p>
<p><span style="font-size: 15px">github  <a href="https://github.com/facebook/litho">https://github.com/facebook/litho</a></span></p>
<p><span style="font-size: 15px">作者：facebook</span></p>
<p><span style="font-size: 15px"> 使用</span>：</p>
<div class="cnblogs_code">

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

<pre><span style="color: #000000">ependencies {</span> <span style="color: #008000">//</span> <span style="color: #008000">...</span> <span style="color: #008000">//</span> <span style="color: #008000">Litho</span>
  compile <span style="color: #800000">'</span><span style="color: #800000">com.facebook.litho:litho-core:0.3.1</span><span style="color: #800000">'</span> <span style="color: #000000">compile</span> <span style="color: #800000">'</span><span style="color: #800000">com.facebook.litho:litho-widget:0.3.1</span><span style="color: #800000">'</span> <span style="color: #000000">provided</span> <span style="color: #800000">'</span><span style="color: #800000">com.facebook.litho:litho-annotations:0.3.1</span><span style="color: #800000">'</span> <span style="color: #000000">annotationProcessor</span> <span style="color: #800000">'</span><span style="color: #800000">com.facebook.litho:litho-processor:0.3.1</span><span style="color: #800000">'</span>

  <span style="color: #008000">//</span> <span style="color: #008000">SoLoader</span>
  compile <span style="color: #800000">'</span><span style="color: #800000">com.facebook.soloader:soloader:0.2.0</span><span style="color: #800000">'</span>

  <span style="color: #008000">//</span> <span style="color: #008000">Optional</span> <span style="color: #008000">//</span> <span style="color: #008000">For debugging</span>
  debugCompile <span style="color: #800000">'</span><span style="color: #800000">com.facebook.litho:litho-stetho:0.3.1</span><span style="color: #800000">'</span>

  <span style="color: #008000">//</span> <span style="color: #008000">For integration with Fresco</span>
  compile <span style="color: #800000">'</span><span style="color: #800000">com.facebook.litho:litho-fresco:0.3.1</span><span style="color: #800000">'</span>

  <span style="color: #008000">//</span> <span style="color: #008000">For testing</span>
  testCompile <span style="color: #800000">'</span><span style="color: #800000">com.facebook.litho:litho-testing:0.3.1</span><span style="color: #800000">'</span> <span style="color: #000000">}</span></pre>

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

</div>

<h2 id="78mosby"><a href="#78-mosby" class="headerlink" title="78.mosby"></a>78.mosby<a href="#78mosby" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：一款提供<strong>构建MVP项目能力</strong>的框架</span></p>
<p><span style="font-size: 15px">上榜理由：榜单靠前的部分已经介绍了MVC,MVVM,MVP的框架项目，想必此时你在构建企业项目架构上，选择或者开发一款合适的MVP框架迫在眉睫，mosby可以作为你的第一步参考，你可以封装它，也可以照抄它，无论如何，3.4K个star，证明了它在框架设计上有多受开发者的喜爱</span></p>
<p><span style="font-size: 15px">github <a href="https://github.com/sockeqwe/mosby">https://github.com/sockeqwe/mosby</a></span></p>
<p><span style="font-size: 15px">作者：Hannes Dorfmann</span></p>
<p><span style="font-size: 15px">使用：</span></p>
<div class="cnblogs_code">

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

<pre><span style="color: #000000">dependencies {

  compile</span> <span style="color: #800000">'</span><span style="color: #800000">com.hannesdorfmann.mosby3:mvi:3.0.4</span><span style="color: #800000">'</span> <span style="color: #008000">//</span> <span style="color: #008000">Model-View-Intent</span> <span style="color: #008000">//</span> <span style="color: #008000">or</span>
  compile <span style="color: #800000">'</span><span style="color: #800000">com.hannesdorfmann.mosby3:mvp:3.0.4</span><span style="color: #800000">'</span> <span style="color: #008000">//</span> <span style="color: #008000">Plain MVP</span> <span style="color: #008000">//</span> <span style="color: #008000">or</span>
  compile <span style="color: #800000">'</span><span style="color: #800000">com.hannesdorfmann.mosby3:viewstate:3.0.4</span><span style="color: #800000">'</span> <span style="color: #008000">//</span> <span style="color: #008000">MVP + ViewState support</span>
}</pre>

<pre><span class="pl-en">allprojects {
  repositories {
    <span class="pl-k">...

    maven { url <span class="pl-s"><span class="pl-pds">"https://oss.sonatype.org/content/repositories/snapshots/<span class="pl-pds">" }
}</span></span></span></span></span></pre>

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

</div>

<h2 id="79andresguard"><a href="#79-AndResGuard" class="headerlink" title="79.AndResGuard"></a>79.AndResGuard<a href="#79andresguard" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：一款提供资源文件路径混淆 的工具</span></p>
<p><span style="font-size: 15px">上榜理由：如果你是个对APK大小很敏感的人，那么AndResGuard一定适合你，它的原理类似Java Proguard，但是只针对资源。他会将原本冗长的资源路径变短，例如将<code>res/drawable/wechat</code>变为<code>r/d/a，3.4K个star，证明了在优化APK道路上，你不是一个人在战斗！</code></span></p>
<p><span style="font-size: 15px">github  <a href="https://github.com/shwenzhang/AndResGuard">https://github.com/shwenzhang/AndResGuard</a></span></p>
<p><span style="font-size: 15px">作者：wechat team</span></p>
<p><span style="font-size: 15px">使用：</span></p>
<p><span style="font-size: 15px">clone项目到本地，其实也就是个三两句话的文档</span></p>
<h2 id="80statusbarutil"><a href="#80-StatusBarUtil" class="headerlink" title="80.StatusBarUtil"></a>80.StatusBarUtil<a href="#80statusbarutil" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：一款提供<strong>设置沉浸式状态栏样式</strong>能力的框架</span></p>
<p><span style="font-size: 15px">上榜理由：设计师MM总是抱怨系统状态栏不优雅？那就给她一个完美的沉浸式状态栏。StatusBarUtil可以随心所欲的设置状态栏样式，3.3K个star，足以说明它有多受设计MM的喜爱</span></p>
<p><span style="font-size: 15px">github <a href="https://github.com/laobie/StatusBarUtil">https://github.com/laobie/StatusBarUtil</a></span></p>
<p><span style="font-size: 15px">作者：Jaeger</span></p>
<p><span style="font-size: 15px">使用：</span></p>
<div class="cnblogs_code">

<pre>compile <span style="color: #800000">'</span><span style="color: #800000">com.jaeger.statusbarutil:library:1.4.0</span><span style="color: #800000">'</span></pre>

</div>

<h2 id="81robolectric"><a href="#81-robolectric" class="headerlink" title="81.robolectric"></a>81.robolectric<a href="#81robolectric" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：一款不依赖于Android设备的单元测试框架，</span></p>
<p><span style="font-size: 15px">上榜理由：sample中列举了如何对Android四大组件和常见功能测试的用例，3.2K个star，值得充满好奇心的人尝试</span></p>
<p><span style="font-size: 15px">官网地址：<a href="http://robolectric.org/">http://robolectric.org/</a></span></p>
<p><span style="font-size: 15px">github  <a href="https://github.com/robolectric/robolectric">https://github.com/robolectric/robolectric</a></span></p>
<p><span style="font-size: 15px">作者：robolectric</span></p>
<p><span style="font-size: 15px">使用：</span></p>
<div class="cnblogs_code">

<pre>testCompile <span style="color: #800000">"</span><span style="color: #800000">org.robolectric:robolectric:3.3.2</span><span style="color: #800000">"</span></pre>

</div>

<h2 id="82fragmentation"><a href="#82-Fragmentation" class="headerlink" title="82.Fragmentation"></a>82.Fragmentation<a href="#82fragmentation" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍:一款提供<strong>管理Fragmen嵌套</strong>t能力的框架</span></p>
<p><span style="font-size: 15px">上榜理由：对于Activity和Fragment使用，你一定得心应手，但如果要做一套通用的Activity&amp;Fragment嵌套设计，想必你有点手足无措了，Fragmentation可以作为你设计Fragment管理上的第一步，3.2K个star，笔者认为有点名副其实了，项目介绍里说的是Fragment的管理能力，但并未提供Fragment&amp;Activity生命周期、任务栈的管理能力，因此很难直接应用到企业项目当中，但源码当中的设计思路，值得笔者与诸位借鉴，拾人牙慧留有余香！</span></p>
<p><span style="font-size: 15px">github：<a href="https://github.com/YoKeyword/Fragmentation">https://github.com/YoKeyword/Fragmentation</a></span></p>
<p><span style="font-size: 15px">作者：YoKey</span></p>
<p><span style="font-size: 15px">使用：</span></p>
<div class="cnblogs_code">

<pre><span style="color: #008000">//</span> <span style="color: #008000">appcompat v7包是必须的</span>
compile <span style="color: #800000">'</span><span style="color: #800000">me.yokeyword:fragmentation:0.10.7</span><span style="color: #800000">'</span>
<span style="color: #008000">//</span> <span style="color: #008000">如果想使用SwipeBack 滑动边缘退出Fragment/Activity功能，请再添加下面的库</span> <span style="color: #008000">//</span> <span style="color: #008000">compile 'me.yokeyword:fragmentation-swipeback:0.10.4'</span></pre>

</div>

<h2 id="83small"><a href="#83-Small" class="headerlink" title="83.Small"></a>83.Small<a href="#83small" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：轻巧的插件化框架</span></p>
<p><span style="font-size: 15px">上榜理由：作为插件框架榜单的新成员，Small的优点是轻巧，适合作为小团队的插件开发方案，3.1K个star，让它获得了<strong>酷狗音乐</strong>等著名开发团队的青睐，如果你们的团队想逐步实施插件化开发，Small是个不错的选择！</span></p>
<p><span style="font-size: 15px"> 官网地址：<a href="http://code.wequick.net/Small/cn/cases">http://code.wequick.net/Small/cn/cases</a></span></p>
<p><span style="font-size: 15px">github  <a href="https://github.com/wequick/Small">https://github.com/wequick/Small</a></span></p>
<p><span style="font-size: 15px">作者：wequick 团队</span></p>
<p><span style="font-size: 15px">使用：</span></p>
<div class="cnblogs_code">

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

<pre><span style="color: #000000">buildscript  {
    dependencies {
        classpath</span> <span style="color: #800000">'</span><span style="color: #800000">net.wequick.tools.build:gradle-small:1.2.0-alpha6</span><span style="color: #800000">'</span> <span style="color: #000000">}
}

apply plugin:</span> <span style="color: #800000">'</span><span style="color: #800000">net.wequick.small</span><span style="color: #800000">'</span> <span style="color: #000000">small {
    aarVersion</span> = <span style="color: #800000">'</span><span style="color: #800000">1.2.0-alpha6</span><span style="color: #800000">'</span> <span style="color: #000000">}</span></pre>

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

</div>

<h2 id="84jsbridge"><a href="#84-JsBridge" class="headerlink" title="84.JsBridge"></a>84.JsBridge<a href="#84jsbridge" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：一款提供WebView和Javascript通信能力的框架</span></p>
<p><span style="font-size: 15px">上榜理由：该框架提供给了<strong>允许H5页面调用通过JS调用App方法的能力；</strong>3.1K个star，简洁的通讯方式，值得每一个Web\Hybrid App开发者尝试</span></p>
<p><span style="font-size: 15px">gtihub <a href="https://github.com/lzyzsd/JsBridge">https://github.com/lzyzsd/JsBridge</a></span></p>
<p><span style="font-size: 15px">作者：hi大头鬼hi</span></p>
<p><span style="font-size: 15px">使用</span>：</p>
<div class="cnblogs_code">

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

<pre><span style="color: #000000">repositories {</span> <span style="color: #008000">//</span> <span style="color: #008000">...</span>
    maven { url <span style="color: #800000">"</span><span style="color: #800000">https://jitpack.io</span><span style="color: #800000">"</span> <span style="color: #000000">}
}

dependencies {
    compile</span> <span style="color: #800000">'</span><span style="color: #800000">com.github.lzyzsd:jsbridge:1.0.4</span><span style="color: #800000">'</span> <span style="color: #000000">}</span></pre>

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

</div>

<h2 id="85richeditor-android"><a href="#85-richeditor-android" class="headerlink" title="85.richeditor-android"></a>85.richeditor-android<a href="#85richeditor-android" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：一款强大的富文本编辑框架 </span></p>
<p><span style="font-size: 15px">上榜理由：2.8k个star，榜单里第一个为TextView提供扩展能力的框架，你暂时不需要它，但不能不知道它</span></p>
<p><span style="font-size: 15px">github  <a href="https://github.com/wasabeef/richeditor-android">https://github.com/wasabeef/richeditor-android</a></span></p>
<p><span style="font-size: 15px">作者：Daichi Furiya</span></p>
<p><span style="font-size: 15px">使用：</span></p>
<div class="cnblogs_code">

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

<pre><span style="color: #000000">repositories {
    jcenter()
}

dependencies {
    compile</span> <span style="color: #800000">'</span><span style="color: #800000">jp.wasabeef:richeditor-android:1.2.2</span><span style="color: #800000">'</span> <span style="color: #000000">}</span></pre>

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

</div>

<h2 id="86transitions-everywhere"><a href="#86-Transitions-Everywhere" class="headerlink" title="86.Transitions-Everywhere"></a>86.Transitions-Everywhere<a href="#86transitions-everywhere" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：一款教你正确使用Transitions API（Android 转场动画API）的教学型项目</span></p>
<p><span style="font-size: 15px">上榜理由：你可能还未尝试过Android API的Transitions 框架，可能听过，但却无法做出优雅奇妙的动效——别担心，Transitions-Everywhere正如它的名字一样，它将带你全面体验Transitions 的强大之处</span></p>
<p><span style="font-size: 15px">github  <a href="https://github.com/andkulikov/Transitions-Everywhere">https://github.com/andkulikov/Transitions-Everywhere</a></span></p>
<p><span style="font-size: 15px">作者：Andrey Kulikov</span></p>
<p><span style="font-size: 15px">使用：</span></p>
<div class="cnblogs_code">

<pre><span style="color: #000000">dependencies {
    compile</span> <span style="color: #800000">"</span><span style="color: #800000">com.andkulikov:transitionseverywhere:1.7.4</span><span style="color: #800000">"</span> <span style="color: #000000">}</span></pre>

</div>

<h2 id="87android-viewbadger"><a href="#87-android-viewbadger" class="headerlink" title="87.android-viewbadger"></a>87.android-viewbadger<a href="#87android-viewbadger" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：能够快速的<strong>为Android 视图加入“勋章</strong>”能力的框架</span></p>
<p><span style="font-size: 15px">上榜理由：如果说勋章一词听起来陌生，那么显示已读未读个数、小红点标记信息这一类词语你一定不太陌生，笔者相信在诸位实际开发中经常遇到为某些item加入小红点标记的需求，聪明的各位一定有着各种实现方案，为什么不能快速优雅的完成呢？android-viewbadger可以帮你实现，当然，在某些情况下，你需要具备修改源码的能力，以符合设计MM的需求！值得注意的是，这宽项目已经五年没有更新了！</span></p>
<p><span style="font-size: 15px">github <a href="https://github.com/jgilfelt/android-viewbadger">https://github.com/jgilfelt/android-viewbadger</a></span></p>
<p><span style="font-size: 15px">作者：Jeff Gilfelt</span></p>
<p><span style="font-size: 15px">使用：</span></p>
<p><span style="font-size: 15px">clone源码到本地</span></p>
<div class="cnblogs_code">

<pre>View target = <span style="color: #000000">findViewById(R.id.target_view);
BadgeView badge</span> = <span style="color: #0000ff">new</span> BadgeView(<span style="color: #0000ff">this</span><span style="color: #000000">, target);
badge.setText(</span><span style="color: #800000">"</span><span style="color: #800000">1</span><span style="color: #800000">"</span><span style="color: #000000">);
badge.show();</span></pre>

</div>

<h2 id="88androidwifiadb"><a href="#88-AndroidWiFiADB" class="headerlink" title="88.AndroidWiFiADB"></a>88.AndroidWiFiADB<a href="#88androidwifiadb" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：一款不用数据线也可以让你调试手机设备APP的插件项目</span></p>
<p><span style="font-size: 15px">上榜理由：你是否还在担心测试过程中<strong>高强度的拔插数据线</strong>对手机电池和USB端口<strong>造成</strong>终生难以弥补<strong>的损害</strong>？别担心，有wifi有AndroidWiFiADB，无须数据线也可以调试应用了，更有趣的是，在测试工程师一边拿着手机一边找你聊bug的时候，你已经偷偷在它的手机上修复了bug，深藏功与名！</span></p>
<p><span style="font-size: 15px">github <a href="https://github.com/pedrovgs/AndroidWiFiADB">https://github.com/pedrovgs/AndroidWiFiADB</a></span></p>
<p><span style="font-size: 15px">作者：Pedro Vicente Gómez Sánchez</span></p>
<p><span style="font-size: 15px">使用：</span></p>
<div class="cnblogs_code">

<pre>Preferences/Settings->Plugins->Browse Repositories->serch AndroidWiFiADB</pre>

</div>

<h2 id="89emojicon"><a href="#89-emojicon" class="headerlink" title="89.emojicon"></a>89.emojicon<a href="#89emojicon" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：一款提供在TextView、EdiText展示表情包能力的框架</span></p>
<p><span style="font-size: 15px">上榜理由：2.7k个star，,榜单第二款增强TextView显示能力的框架，这款专为表情包设计，如果你曾经好奇微信、QQ的表情显示是如何做到的？这款框架一定能满足你的求知欲。</span></p>
<h2 id="90packer-ng-plugin"><a href="#90-packer-ng-plugin" class="headerlink" title="90.packer-ng-plugin"></a>90.packer-ng-plugin<a href="#90packer-ng-plugin" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：一款打爆工具插件</span></p>
<p><span style="font-size: 15px">上榜利用：笔者尽力维护榜单涉及范围的全面性，因此引入此插件项目——项目号称完成100个渠道包只需要10秒钟，在市面上各种各样多渠道打包方案的今天，选择一款适合自己团队的，才是上上选择</span></p>
<p><span style="font-size: 15px">github <a href="https://github.com/mcxiaoke/packer-ng-plugin">https://github.com/mcxiaoke/packer-ng-plugin</a></span></p>
<p><span style="font-size: 15px">作者：Xiaoke Zhang</span></p>
<p><span style="font-size: 15px">使用：</span></p>
<div class="cnblogs_code">

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

<pre><span style="color: #000000">buildscript {
    ......
    dependencies{</span> <span style="color: #008000">//</span> <span style="color: #008000">add packer-ng</span>
        classpath <span style="color: #800000">'</span><span style="color: #800000">com.mcxiaoke.gradle:packer-ng:1.0.9</span><span style="color: #800000">'</span> <span style="color: #000000">}
}</span> </pre>

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

</div>

<div class="cnblogs_code">

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

<pre>apply plugin: <span style="color: #800000">'</span><span style="color: #800000">packer</span><span style="color: #800000">'</span> <span style="color: #000000">dependencies {
    compile</span> <span style="color: #800000">'</span><span style="color: #800000">com.mcxiaoke.gradle:packer-helper:1.0.9</span><span style="color: #800000">'</span> <span style="color: #000000">}

 android {</span> <span style="color: #008000">//</span><span style="color: #008000">...</span>
 <span style="color: #000000">signingConfigs {
      release {</span> <span style="color: #008000">//</span> <span style="color: #008000">满足下面两个条件时需要此配置</span> <span style="color: #008000">//</span> <span style="color: #008000">1\. Gradle版本 >= 2.14.1</span> <span style="color: #008000">//</span> <span style="color: #008000">2\. Android Gradle Plugin 版本 >= 2.2.0</span> <span style="color: #008000">//</span> <span style="color: #008000">作用是只使用旧版签名，禁用V2版签名模式</span>
        v2SigningEnabled <span style="color: #0000ff">false</span> <span style="color: #000000">}
    }
  }</span></pre>

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

</div>

<h2 id="91android-priority-jobqueue"><a href="#91-android-priority-jobqueue" class="headerlink" title="91.android-priority-jobqueue"></a>91.android-priority-jobqueue<a href="#91android-priority-jobqueue" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：一款提供后台任务管理能力的框架</span></p>
<p><span style="font-size: 15px">上榜理由：如果你是个志在深入研究多线程操作的开发者，这个项目一定不要错过，不论是Activity重新加载、Service使用线程池时的任务优先级和并发问题，都不要担心，Job Manage会照顾优先级，持久性，负载平衡，延迟，网络控制，分组，2.4K个star，优秀的多线程管理能力，况且它依赖的第三方框架很少，值得你一试</span></p>
<p><span style="font-size: 15px">github  <a href="https://github.com/yigit/android-priority-jobqueue">https://github.com/yigit/android-priority-jobqueue</a></span></p>
<p><span style="font-size: 15px">作者：Yigit Boyar</span></p>
<h2 id="92android-debug-database"><a href="#92-Android-Debug-Database" class="headerlink" title="92.Android-Debug-Database"></a>92.Android-Debug-Database<a href="#92android-debug-database" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：一款提供测试App内部数据库能力的框架</span></p>
<p><span style="font-size: 15px">上榜理由：榜单里第二款针对<strong>调试数据库</strong>的框架，一行代码集成，直接在浏览器增删改查App的数据库，2.3k个star，心动不如行动！</span></p>
<p><span style="font-size: 15px">github  <a href="https://github.com/amitshekhariitbhu/Android-Debug-Database">https://github.com/amitshekhariitbhu/Android-Debug-Database</a></span></p>
<p><span style="font-size: 15px">作者：AMIT SHEKHAR</span></p>
<p><span style="font-size: 15px">使用</span>：</p>
<div class="cnblogs_code">

<pre>debugCompile <span style="color: #800000">'</span><span style="color: #800000">com.amitshekhar.android:debug-db:1.0.0</span><span style="color: #800000">'</span></pre>

</div>

<p><span style="font-size: 15px">浏览器键入</span></p>
<div class="cnblogs_code">

<pre> http:<span style="color: #008000">//</span><span style="color: #008000">XXX.XXX.X.XXX:8080</span></pre>

</div>

<h2 id="93conceal"><a href="#93-conceal" class="headerlink" title="93.conceal"></a>93.conceal<a href="#93conceal" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：一款facebook提供的加密本地大文件的框架</span></p>
<p><span style="font-size: 15px">上榜理由：如果还在担心App内的图片的隐私问题，这款facebook提供的文件加密框架足以解决你的问题，facebook客户端的图片和数据都是使用conceal加密的</span></p>
<p><span style="font-size: 15px">官网地址：<a href="http://facebook.github.io/conceal/">http://facebook.github.io/conceal/</a></span></p>
<p><span style="font-size: 15px">github <a href="https://github.com/facebook/conceal">https://github.com/facebook/conceal</a></span></p>
<p><span style="font-size: 15px">作者;facebook</span></p>
<p><span style="font-size: 15px">使用：</span></p>
<p><span style="font-size: 15px">clone项目到本地/官网下载jar</span></p>
<h2 id="94arouter"><a href="#94-ARouter" class="headerlink" title="94.ARouter"></a>94.ARouter<a href="#94arouter" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：一款提供服务、页面跳转路由的框架</span></p>
<p><span style="font-size: 15px">上榜理由：正如作者宣称的那样，该框架提供：从外部URL映射到内部页面、跨模块的页面跳转（页面解耦）、拦截跳转过程等能力，还有更多功能等你去发掘，2.1K个star，值得为企业级的框架喝彩</span></p>
<p><span style="font-size: 15px">github  <a href="https://github.com/alibaba/ARouter">https://github.com/alibaba/ARouter</a></span></p>
<p><span style="font-size: 15px">作者：alibaba </span></p>
<p><span style="font-size: 15px">使用：</span></p>
<div class="cnblogs_code">

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

<pre><span style="color: #000000">ndroid {
    defaultConfig {
    ...
    javaCompileOptions {
        annotationProcessorOptions {
        arguments</span> = <span style="color: #000000">[ moduleName : project.getName() ]
        }
    }
    }
}

dependencies {</span> <span style="color: #008000">//</span> <span style="color: #008000">替换成最新版本, 需要注意的是api</span> <span style="color: #008000">//</span> <span style="color: #008000">要与compiler匹配使用，均使用最新版可以保证兼容</span>
    compile <span style="color: #800000">'</span><span style="color: #800000">com.alibaba:arouter-api:x.x.x</span><span style="color: #800000">'</span> <span style="color: #000000">annotationProcessor</span> <span style="color: #800000">'</span><span style="color: #800000">com.alibaba:arouter-compiler:x.x.x</span><span style="color: #800000">'</span> <span style="color: #000000">...
}</span> <span style="color: #008000">//</span> <span style="color: #008000">旧版本gradle插件(< 2.2)，可以使用apt插件，配置方法见文末'其他#4'</span> <span style="color: #008000">//</span> <span style="color: #008000">Kotlin配置参考文末'其他#5'</span></pre>

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

</div>

<h2 id="95magicasakura"><a href="#95-MagicaSakura" class="headerlink" title="95.MagicaSakura"></a>95.MagicaSakura<a href="#95magicasakura" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：一款提供多主题切换能力的框架</span></p>
<p><span style="font-size: 15px">上榜理由：框架所提供的能力，一直是本榜单所看重的，这款由bilibili提供的多主题框架，作为榜单所涉及范围能补充，1.9个star，感谢bilibili团队所作出的贡献！</span></p>
<p><span style="font-size: 15px">github <a href="https://github.com/Bilibili/MagicaSakura">https://github.com/Bilibili/MagicaSakura</a></span></p>
<p><span style="font-size: 15px">作者:Bilibili</span></p>
<p><span style="font-size: 15px">使用：</span></p>
<div class="cnblogs_code">

<pre>compile <span style="color: #800000">'</span><span style="color: #800000">com.bilibili:magicasakura:0.1.6@aar</span><span style="color: #800000">'</span></pre>

</div>

<h2 id="96customactivityoncrash"><a href="#96-CustomActivityOnCrash" class="headerlink" title="96.CustomActivityOnCrash"></a>96.CustomActivityOnCrash<a href="#96customactivityoncrash" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：一款当APP crash的时候自动载入某个Activity的框架（而不是显示Unfortunately, X has stopped）</span></p>
<p><span style="font-size: 15px">上榜理由：新奇的创意是榜单所需要的，所以它赢得了1.8K个star；作为开发者应该拥有考虑到各种潜伏的bug的能力，但我们不能总是面面俱到，其他系统端的同事也可能造成程序的意外crash，因此，如何让程序优雅的crash-&gt;重启值得我们思考，这款框架就提供了这种能力</span></p>
<p><span style="font-size: 15px">github  <a href="https://github.com/Ereza/CustomActivityOnCrash">https://github.com/Ereza/CustomActivityOnCrash</a></span></p>
<p><span style="font-size: 15px">作者：Eduard Ereza Martínez</span></p>
<p><span style="font-size: 15px">使用：</span></p>
<div class="cnblogs_code">

<pre><span style="color: #000000">dependencies {
    compile</span> <span style="color: #800000">'</span><span style="color: #800000">cat.ereza:customactivityoncrash:2.1.0</span><span style="color: #800000">'</span> <span style="color: #000000">}</span></pre>

</div>

<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">添加到 Application class:</span><br></pre></td></tr></table></figure></div>
<div class="cnblogs_code">

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

<pre> <span style="color: #000000">@Override</span> <span style="color: #0000ff">public</span> <span style="color: #0000ff">void</span> <span style="color: #000000">onCreate() {
    super.onCreate();

    CaocConfig.Builder.create()
        .backgroundMode(CaocConfig.BACKGROUND_MODE_SILENT)</span>
        .enabled(<span style="color: #0000ff">false</span>) <span style="color: #008000">//</span><span style="color: #008000">default: true</span>
        .showErrorDetails(<span style="color: #0000ff">false</span>) <span style="color: #008000">//</span><span style="color: #008000">default: true</span>
        .showRestartButton(<span style="color: #0000ff">false</span>) <span style="color: #008000">//</span><span style="color: #008000">default: true</span>
        .trackActivities(<span style="color: #0000ff">true</span>) <span style="color: #008000">//</span><span style="color: #008000">default: false</span>
        .minTimeBetweenCrashesMs(<span style="color: #800080">2000</span>) <span style="color: #008000">//</span><span style="color: #008000">default: 3000</span>
        .errorDrawable(R.drawable.ic_custom_drawable) <span style="color: #008000">//</span><span style="color: #008000">default: bug image</span>
        .restartActivity(YourCustomActivity.<span style="color: #0000ff">class</span>) <span style="color: #008000">//</span><span style="color: #008000">default: null (your app's launch activity)</span>
        .errorActivity(YourCustomErrorActivity.<span style="color: #0000ff">class</span>) <span style="color: #008000">//</span><span style="color: #008000">default: null (default error activity)</span>
        .eventListener(<span style="color: #0000ff">new</span> YourCustomEventListener()) <span style="color: #008000">//</span><span style="color: #008000">default: null</span>
 <span style="color: #000000">.apply();
}</span></pre>

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

</div>

<h2 id="97xhsemoticonskeyboard"><a href="#97-XhsEmoticonsKeyboard" class="headerlink" title="97.XhsEmoticonsKeyboard"></a>97.XhsEmoticonsKeyboard<a href="#97xhsemoticonskeyboard" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：最开心的开源表情解决方案</span></p>
<p><span style="font-size: 15px">上榜理由：如果你还在发愁如何为你的APP自制键盘，那么此框架非常适合你，而且还提供表情包展示能力，1.7个star证明了它的独特。此外作者还附赠了高仿微信键盘，QQ键盘的demo，分享给诸位</span></p>
<p><span style="font-size: 15px">github <a href="https://github.com/w446108264/XhsEmoticonsKeyboard">https://github.com/w446108264/XhsEmoticonsKeyboard</a></span></p>
<p><span style="font-size: 15px">作者：zhongdaxia</span></p>
<p><span style="font-size: 15px">使用：</span></p>
<div class="cnblogs_code">

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

<pre><span style="color: #000000">allprojects {
    repositories {
        jcenter()
        maven { url</span> <span style="color: #800000">"</span><span style="color: #800000">https://jitpack.io</span><span style="color: #800000">"</span> <span style="color: #000000">}
    }
}

dependencies {
    compile</span> <span style="color: #800000">'</span><span style="color: #800000">com.github.w446108264:XhsEmoticonsKeyboard:2.0.4</span><span style="color: #800000">'</span> <span style="color: #000000">}</span></pre>

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

</div>


<h2 id="98android-debug-database"><a href="#98-Android-Debug-Database" class="headerlink" title="98.Android Debug Database"></a>98.Android Debug Database<a href="#98android-debug-database" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：最简洁的数据库调试框架</span></p>
<p>span style=”font-size: 15px”&gt;上榜理由：调试数据库，是诸位日常工作中必不可少的环节，与榜单里出现过facebook的stetho，Android Debug Database最大的优势是简洁：集成简洁明了，观察、操作数据库简洁明了，还有一个不得不得推荐它的理由！stetho在数据表字段数超过50的时候阅读性非常差，今天推荐的这款，在UI界面上毫无疑问有着巨大的优势！</p>
<p>span style=”font-size: 15px”&gt;github [<a href="https://github.com/amitshekhariitbhu/Android-Debug-Database(https://github.com/amitshekhariitbhu/Android-Debug-Database)">https://github.com/amitshekhariitbhu/Android-Debug-Database(https://github.com/amitshekhariitbhu/Android-Debug-Database)</a></p>
<p><span style="font-size: 15px">作者：AMIT SHEKHAR</span></p>
<p><span style="font-size: 15px">使用：</span></p>
<div class="cnblogs_code">


<pre><span style="color: #000000">

build.gradle：

debugImplementation 'com.amitshekhar.android:debug-db:1.0.3'

//配置端口

 debug {
            debuggable true
            resValue("string", "PORT_NUMBER", "9081")
    }


adb forward tcp:9081 tcp:9081


查看Logcat的ip日志：D/DebugDB: Open http://XXX.XXX.X.XXX:8080 in your browser

boomb！

</span></pre>

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

</div>

<h1 id="三完整项目"><a href="#三-完整项目" class="headerlink" title="三.完整项目"></a>三.完整项目<a href="#三完整项目" class="header-anchor">#</a></h1><h2 id="1iosche"><a href="#1-iosche" class="headerlink" title="1.iosche"></a>1.iosche<a href="#1iosche" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：谷歌2016开发者大会的展示项目</span></p>
<p><span style="font-size: 15px">上榜理由：github上有13.4k个star，位居企业级项目排行榜第一位，牛逼的开发者，权威的设计模式，标准的项目写法，值得一试；笔者建议初学者down下源码，找到app入口，每个页面走一通，配合设计模式的概念加深理解。</span></p>
<p><span style="font-size: 15px">github <a href="https://github.com/google/iosched">https://github.com/google/iosched</a></span></p>
<p><span style="font-size: 15px">作者： Google</span></p>
<p><span style="font-size: 15px"> </span></p>
<h2 id="2plaid"><a href="#2-Plaid" class="headerlink" title="2.Plaid"></a>2.Plaid<a href="#2plaid" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：提供设计新闻和灵感的开源app</span></p>
<p><span style="font-size: 15px">上榜理由：标准的material design设计，新闻类app，github上9k的star量值得你摒弃市面上参差不齐的新闻app，快点下手研究它吧！</span></p>
<p><span style="font-size: 15px">github  <a href="https://github.com/nickbutcher/plaid">https://github.com/nickbutcher/plaid</a></span></p>
<p><span style="font-size: 15px"> 作者： Nick Butcher</span></p>
<h2 id="3pockethub"><a href="#3-PocketHub" class="headerlink" title="3.PocketHub"></a>3.PocketHub<a href="#3pockethub" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：Github的Android版</span></p>
<p><span style="font-size: 15px">上榜理由：8.7K的star数量，Github的亲生儿子，开放的源码值得各位一探究竟</span></p>
<p><span style="font-size: 15px">github <a href="https://github.com/pockethub/PocketHub">https://github.com/pockethub/PocketHub</a></span></p>
<p><span style="font-size: 15px">作者:Fadil Sutomo</span></p>
<p><span style="font-size: 15px">使用：</span></p>
<p><span style="font-size: 15px">down下所有源码</span></p>
<h2 id="4signal-android"><a href="#4-Signal-Android" class="headerlink" title="4.Signal Android"></a>4.Signal Android<a href="#4signal-android" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：Signal是一款安全通讯的短信类app，</span></p>
<p><span style="font-size: 15px">上榜理由：7.9K的star数量，工具类app的标签属性，让它在排行榜中独一无二，如果你对短信app有兴趣，可以深入探究一番</span></p>
<p><span style="font-size: 15px">github <a href="https://github.com/WhisperSystems/Signal-Android">https://github.com/WhisperSystems/Signal-Android</a></span></p>
<p><span style="font-size: 15px">作者：WhisperSystems</span></p>
<p><span style="font-size: 15px">使用：github上down源码</span></p>
<h2 id="5android-universalmusicplayer"><a href="#5-android-UniversalMusicPlayer" class="headerlink" title="5.android-UniversalMusicPlayer"></a>5.android-UniversalMusicPlayer<a href="#5android-universalmusicplayer" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：一款跨设备运行的多媒体app</span></p>
<p><span style="font-size: 15px">上榜理由：googlesamples良心推荐，github拥有7.9k个star，可以在Android手机，汽车，平板，穿戴设备上使用，对于仅仅体验过Android手机开发的程序员，会不会很新奇呢？你值得一试！</span></p>
<p><span style="font-size: 15px">github <a href="https://github.com/googlesamples/android-UniversalMusicPlayer">https://github.com/googlesamples/android-UniversalMusicPlayer</a></span></p>
<p><span style="font-size: 15px">作者：Google</span></p>
<p><span style="font-size: 15px">使用：github上down源码</span></p>
<h2 id="6homemirror"><a href="#6-HomeMirror" class="headerlink" title="6.HomeMirror"></a>6.HomeMirror<a href="#6homemirror" class="header-anchor">#</a></h2><p><span style="font-size: 15px"> 一句话介绍：如果你是个爱美的家伙那么你一定需要这面镜子！</span></p>
<p><span style="font-size: 15px">上榜理由：工具类App很难再github上有一席之地，除非它提供特别新奇的功能，比如HomeMirror，github上有用7599个star，仅仅因为它提供了镜子的功能。从现在起，Android 手机、pad，都将成为你旅游居家神器，值得拥有！</span></p>
<p><span style="font-size: 15px">github  <a href="https://github.com/HannahMitt/HomeMirror">https://github.com/HannahMitt/HomeMirror</a></span></p>
<p><span style="font-size: 15px">作者：Hannah Mittens </span></p>
<p><span style="font-size: 15px">HomeMirror初体验：</span></p>
<p><img src="http://images2015.cnblogs.com/blog/1149134/201706/1149134-20170616104729165-546624366.png"></p>
<h2 id="7exoplayer"><a href="#7-ExoPlayer" class="headerlink" title="7.ExoPlayer"></a>7.ExoPlayer<a href="#7exoplayer" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：一款 替代Android原生MediaPlayer的媒体播放器</span></p>
<p><span style="font-size: 15px">上榜理由：也许是Google对自家MediaPlayer API不甚满意，所以诞生了ExoPlayer，ExoPlayer提供了强大的扩展API，使用它来制作多媒体播放器更快捷，更容易扩展，对多媒体播放器感兴趣的同仁们可以用它来大展身手了！6.9K个star，证明它有多受开发者们喜爱，更难能可贵的是，google还在更新维护着！</span></p>
<p><span style="font-size: 15px">官网地址：<a href="https://google.github.io/ExoPlayer/">https://google.github.io/ExoPlayer/</a></span></p>
<p><span style="font-size: 15px">github  <a href="https://github.com/google/ExoPlayer">https://github.com/google/ExoPlayer</a></span></p>
<p><span style="font-size: 15px">作者：google</span></p>
<p><span style="font-size: 15px">使用：</span></p>
<div class="cnblogs_code">

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

<pre><span style="color: #000000">repositories {
    jcenter()
}
compile</span> <span style="color: #800000">'</span><span style="color: #800000">com.google.android.exoplayer:exoplayer:r2.X.X</span><span style="color: #800000">'</span> <span style="color: #000000">compile</span> <span style="color: #800000">'</span><span style="color: #800000">com.google.android.exoplayer:exoplayer-core:r2.X.X</span><span style="color: #800000">'</span> <span style="color: #000000">compile</span> <span style="color: #800000">'</span><span style="color: #800000">com.google.android.exoplayer:exoplayer-dash:r2.X.X</span><span style="color: #800000">'</span> <span style="color: #000000">compile</span> <span style="color: #800000">'</span><span style="color: #800000">com.google.android.exoplayer:exoplayer-ui:r2.X.X</span><span style="color: #800000">'</span></pre>

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

</div>

<h2 id="8cheesesquare"><a href="#8-cheesesquare" class="headerlink" title="8.cheesesquare"></a>8.cheesesquare<a href="#8cheesesquare" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：Android 材料设计的展示性项目</span></p>
<p><span style="font-size: 15px">上榜理由:作者被称为是Android Support Lib背后的男人，他写出的展示性项目，怎能不推荐上榜？材料设计已经炒了好几年了，但作为最权威的展示项目，你一定需要它，6.7个star证明了它是多么的受欢迎。</span></p>
<p><span style="font-size: 15px">github  <a href="https://github.com/chrisbanes/cheesesquare">https://github.com/chrisbanes/cheesesquare</a></span></p>
<p><span style="font-size: 15px">作者：Chris Banes</span></p>
<h2 id="9danmakuflamemaster"><a href="#9-DanmakuFlameMaster" class="headerlink" title="9.DanmakuFlameMaster"></a>9.DanmakuFlameMaster<a href="#9danmakuflamemaster" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：android端开源弹幕引擎</span></p>
<p><span style="font-size: 15px">上榜理由：bilibili出品，保证了它的纯种品质，并且ndk源码也一并开源，可谓业界良心，该弹幕引擎的开源节省了很多视频直播小伙伴的开发成本，笔者强力推荐！</span></p>
<p><span style="font-size: 15px">github <a href="https://github.com/Bilibili/DanmakuFlameMaster">https://github.com/Bilibili/DanmakuFlameMaster</a></span></p>
<p><span style="font-size: 15px">作者：bilibili</span></p>
<p><span style="font-size: 15px">使用</span>：</p>
<div class="cnblogs_code">

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

<pre><span style="color: #000000">repositories {
    jcenter()
}

dependencies {
    compile</span> <span style="color: #800000">'</span><span style="color: #800000">com.github.ctiao:DanmakuFlameMaster:0.8.3</span><span style="color: #800000">'</span> <span style="color: #000000">compile</span> <span style="color: #800000">'</span><span style="color: #800000">com.github.ctiao:ndkbitmap-armv7a:0.8.3</span><span style="color: #800000">'</span> <span style="color: #000000"># Other ABIs: optional
    compile</span> <span style="color: #800000">'</span><span style="color: #800000">com.github.ctiao:ndkbitmap-armv5:0.8.3</span><span style="color: #800000">'</span> <span style="color: #000000">compile</span> <span style="color: #800000">'</span><span style="color: #800000">com.github.ctiao:ndkbitmap-x86:0.8.3</span><span style="color: #800000">'</span> <span style="color: #000000">}</span></pre>

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

</div>

<h2 id="10facebook-android-sdk"><a href="#10-facebook-android-sdk" class="headerlink" title="10.facebook-android-sdk"></a>10.facebook-android-sdk<a href="#10facebook-android-sdk" class="header-anchor">#</a></h2><p><span class="pl-en" style="font-size: 15px"> 一句话介绍：一款提供<strong>接入facebook平台能力</strong>的框架</span></p>
<p><span style="font-size: 15px">上榜理由：无论是你有接入facebook的需求，还是有学习自制sdk的需求，这都是很棒的途径；如何开发一套企业级sdk，是进阶优秀开发工程师的必须之路，4.1k个star，facebook持久更新质量保证，你值得拥有！</span></p>
<p><span style="font-size: 15px">github <a href="https://github.com/facebook/facebook-android-sdk">https://github.com/facebook/facebook-android-sdk</a></span></p>
<p><span style="font-size: 15px">作者：facebook</span></p>
<p><span style="font-size: 15px">使用</span>：</p>
<div class="cnblogs_code">

<pre> https:<span style="color: #008000">//</span><span style="color: #008000">developers.facebook.com/docs/android</span></pre>

</div>

<h2 id="11android-oss"><a href="#11-android-oss" class="headerlink" title="11.android-oss"></a>11.android-oss<a href="#11android-oss" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：国外创意社区Kickstarter 开源的Android版客户端</span></p>
<p><span style="font-size: 15px">上榜理由：精致的企业级APP，每个页面处理得都很棒，如果你志在成为一个优雅工程师，这款开源项目一定适合你，3.8k个star证明了它不俗的生命力</span></p>
<p><span style="font-size: 15px">github：<a href="https://github.com/kickstarter/android-oss">https://github.com/kickstarter/android-oss</a></span></p>
<p><span style="font-size: 15px">作者：kickstarter</span></p>
<p><span style="font-size: 15px">使用;</span></p>
<p><span style="font-size: 15px">clone源码到本地</span></p>
<h2 id="12k-9"><a href="#12-k-9" class="headerlink" title="12.k-9"></a>12.k-9<a href="#12k-9" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：Android端客户端邮件App</span></p>
<p><span style="font-size: 15px">上榜理由：还记得张小龙的成名作——FoxMail吗？如果你想做一款移动端Email App，k-9具有很好的借鉴价值，此外对于应用层协议你也会有更深的认识</span></p>
<p><span style="font-size: 15px">官网地址： <a href="https://k9mail.github.io/">https://k9mail.github.io/</a></span></p>
<p><span style="font-size: 15px">github  <a href="https://github.com/k9mail/k-9">https://github.com/k9mail/k-9</a></span></p>
<p><span style="font-size: 15px">使用：</span></p>
<p><span style="font-size: 15px">clone项目到本地</span></p>
<h2 id="13timber"><a href="#13-Timber" class="headerlink" title="13.Timber"></a>13.Timber<a href="#13timber" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：一款音乐播放器类App</span></p>
<p><span style="font-size: 15px"> 上榜理由：3K个star，完全按照材料设计规范，提供十几种播放特性，而且还提供App的通用设置能力，这一点做的同样优秀，对于志在提升开发技术的同学值得一试</span></p>
<p><span style="font-size: 15px">github <a href="https://github.com/naman14/Timber">https://github.com/naman14/Timber</a></span></p>
<p><span style="font-size: 15px">作者：Naman Dwivedi</span></p>
<p><span style="font-size: 15px">使用：</span></p>
<p><span style="font-size: 15px">clone源码是一个好习惯</span></p>
<h2 id="14remusic"><a href="#14-remusic" class="headerlink" title="14.remusic"></a>14.remusic<a href="#14remusic" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：仿网易云音乐Android版App</span></p>
<p><span style="font-size: 15px">上榜理由：学习完Timer，是否还不太满足你的胃口？remusic可以满足你的胃口——它甚至可以拿去直接当上线项目了！2.9K个star，基于Timber的设计（入手的前提是先搞懂Timber）值得入手；有一个问题：如果由你重构，你会如何做呢？</span></p>
<p><span style="font-size: 15px">github <a href="https://github.com/aa112901/remusic">https://github.com/aa112901/remusic</a></span></p>
<p><span style="font-size: 15px">作者：MW</span></p>
<p><span style="font-size: 15px">使用：</span></p>
<p><span style="font-size: 15px">clone项目</span></p>
<h2 id="15douya"><a href="#15-Douya" class="headerlink" title="15.Douya"></a>15.Douya<a href="#15douya" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：开源豆瓣客户端</span></p>
<p><span style="font-size: 15px">上榜理由：一款功能全面、架构设计不俗的开源APP；仅仅是对豆瓣APP设计思路不满而进行的重构项目，可见作者对产品的痴迷和热爱，2.9K个star，证明该项目并不是头脑发热一时兴起的作品，如果每一个idea都能实现，那我们的世界将会多么美妙！</span></p>
<p><span style="font-size: 15px">github  <a href="https://github.com/DreaminginCodeZH/Douya">https://github.com/DreaminginCodeZH/Douya</a></span></p>
<p><span style="font-size: 15px">作者：Zhang Hai</span></p>
<p><span style="font-size: 15px">使用：</span></p>
<p><span style="font-size: 15px">clone项目到本地</span></p>
<h2 id="16bookreader"><a href="#16-BookReader" class="headerlink" title="16.BookReader"></a>16.BookReader<a href="#16bookreader" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：开源小说阅读器</span></p>
<p><span style="font-size: 15px">上榜理由：2.7K个star，榜单里第一款阅读器APP，具有很高的学习价值（针对有兴趣往阅读工具类方向发展的同学）</span></p>
<p><span style="font-size: 15px">github <a href="https://github.com/JustWayward/BookReader">https://github.com/JustWayward/BookReader</a></span></p>
<p><span style="font-size: 15px">作者：JustWayward 团队</span></p>
<p><span style="font-size: 15px">使用：</span></p>
<p><span style="font-size: 15px">clone到本地 </span></p>
<h2 id="17bilibili-android-client"><a href="#17-bilibili-android-client" class="headerlink" title="17.bilibili-android-client"></a>17.bilibili-android-client<a href="#17bilibili-android-client" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍:高仿bilibili的Android客户端</span></p>
<p><span style="font-size: 15px">上榜理由：2.5K个star，榜单里第一款视频直播开源App；适合对视频直播、社区互动感兴趣的同学；bilibili-android-client里使用了很多大型框架，此项目并不适合基础薄弱的同学，不要灰心，学习页面的布局设计也是值得的！</span></p>
<p><span style="font-size: 15px">github  <a href="https://github.com/HotBitmapGG/bilibili-android-client">https://github.com/HotBitmapGG/bilibili-android-client</a></span></p>
<p><span style="font-size: 15px">作者：Hcc</span></p>
<p><span style="font-size: 15px">使用：clone到本地</span></p>
<h2 id="18androidchromium"><a href="#18-AndroidChromium" class="headerlink" title="18.AndroidChromium"></a>18.AndroidChromium<a href="#18androidchromium" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：Android版chrome浏览器</span></p>
<p><span style="font-size: 15px">上榜理由：正如作者宣称的那样:</span></p>
<ul>
<li>  <span style="font-size: 15px">谷歌浏览器安卓版源码项目</span></li>
<li>  <span style="font-size: 15px">世界级的安卓架构</span></li>
<li>  <span style="font-size: 15px">理清本项目业务逻辑完全可以胜任国内一线公司工程师</span></li>
</ul>
<p><span style="font-size: 15px">　　对于志在梳理浏览器框架的你，值得拥有</span></p>
<p><span style="font-size: 15px">github <a href="https://github.com/JackyAndroid/AndroidChromium">https://github.com/JackyAndroid/AndroidChromium</a></span></p>
<p><span style="font-size: 15px">作者：JackYAndroid</span></p>
<p><span style="font-size: 15px">使用：</span></p>
<p><span style="font-size: 15px">clone源码到本地</span></p>
<h1 id="四开发框架"><a href="#四-开发框架：" class="headerlink" title="四.开发框架："></a>四.开发框架：<a href="#四开发框架" class="header-anchor">#</a></h1><h1 id="排名无先后-只按类型划分"><a href="#（排名无先后、只按类型划分）" class="headerlink" title="（排名无先后、只按类型划分）"></a><span style="font-size: 16px">（排名无先后、只按类型划分）</span><a href="#排名无先后-只按类型划分" class="header-anchor">#</a></h1><h2 id="1libgdxhttpsgithubcomlibgdxlibgdx"><a href="#1-libgdx-https-github-com-libgdx-libgdx" class="headerlink" title="1.libgdx(https://github.com/libgdx/libgdx)"></a>1.libgdx(<a href="https://github.com/libgdx/libgdx">https://github.com/libgdx/libgdx</a>)<a href="#1libgdxhttpsgithubcomlibgdxlibgdx" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：一款跨平台的android端游戏开发框架</span></p>
<p><span style="font-size: 15px">上榜理由：android端开发框架类第一名，11.7K的star量，游戏框架是它的专属标签，更重要的是它是跨平台的</span></p>
<p><span style="font-size: 15px">官网地址  <a href="http://libgdx.badlogicgames.com/">http://libgdx.badlogicgames.com/</a></span></p>
<p><span style="font-size: 15px">github <a href="https://github.com/libgdx/libgdx">https://github.com/libgdx/libgdx</a></span></p>
<h2 id="2xutils"><a href="#2-xUtils" class="headerlink" title="2.xUtils"></a>2.xUtils<a href="#2xutils" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：老牌企业级开发框架</span></p>
<p><span style="font-size: 15px">上榜理由：4.9K个star，xUtils作为上古时期程序员备受推崇的开发框架，最大的原因——省事。xUtls包含四大模块，与之而来的是提供四大操作能力：数据操作、UI操作、Http协议操作、图片操作。xUtils作为笔者初学Android框架设计的导师型项目，在笔者多年经验中，看到xUtils作为众多中小银行Android端框架方案首选，足以证明它的受欢迎程度。该框架现在已经更新到了xUtils3，如果你对Android框架涉及有一定的想法，可以从xUtils入手，进阶为框架大师行列。虽然框架中很多引擎已经过时，各个模块的做法都可以用其他框架替代，但xUtils作为国内开发者的骄傲，上古时期的框架宠儿，值得你拥有！</span></p>
<p><span style="font-size: 15px">github  <a href="https://github.com/wyouflf/xUtils">https://github.com/wyouflf/xUtils</a></span></p>
<p><span style="font-size: 15px">作者：wyouflf</span></p>
<p><span style="font-size: 15px">使用：</span></p>
<div class="cnblogs_code">

<pre>compile <span style="color: #800000">'</span><span style="color: #800000">org.xutils:xutils:3.5.0</span><span style="color: #800000">'</span></pre>

</div>

<h2 id="3android-common"><a href="#3-android-common" class="headerlink" title="3.android-common"></a>3.android-common<a href="#3android-common" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍： 一款android快速开发框架</span></p>
<p><span style="font-size: 15px">上榜理由：滴滴资深级Android工程师出品，历经多年开发者的检验，以4.3K屹立于快速开发框架榜第三名，该框架提供了图片缓存、Http缓存、DropDownListView、下载模块、开发常用工具类等，作为上古时期程序员最早的<strong>总结性开发框架</strong>，它是一代人智慧的结晶，值得我们为作者Trinea鼓掌喝彩</span></p>
<p><span style="font-size: 15px">github  <a href="https://github.com/Trinea/android-common">https://github.com/Trinea/android-common</a></span></p>
<p><span style="font-size: 15px">作者：Trinea</span></p>
<p><span style="font-size: 15px">使用：</span></p>
<p>clone代码到本地</p>
<h2 id="4vitamio"><a href="#4-Vitamio" class="headerlink" title="4.Vitamio"></a>4.Vitamio<a href="#4vitamio" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：一款支持跨平台的Android多媒体开发框架</span></p>
<p><span style="font-size: 15px">上榜理由：如果之前提到的exoplayer不能满足你开发多媒体的需求，那我保证vitamio值得你一试</span></p>
<p><span style="font-size: 15px">官网地址：<a href="https://www.vitamio.org/">https://www.vitamio.org/</a></span></p>
<p><span style="font-size: 15px">github <a href="https://github.com/yixia/VitamioBundle">https://github.com/yixia/VitamioBundle</a></span></p>
<p><span style="font-size: 15px">作者：yixia团队</span></p>
<p><span style="font-size: 15px">使用：</span></p>
<p><span style="font-size: 15px">clone源码到本地</span></p>
<p><span style="font-size: 15px"> </span></p>
<h2 id="5weex"><a href="#5-Weex" class="headerlink" title="5.Weex"></a>5.Weex<a href="#5weex" class="header-anchor">#</a></h2><p>一句话介绍：移动端跨平台开发的解决方案</p>
<p>上榜理由：14.4K个star，有成熟应用案例的企业级混合开发框架，阿里巴巴出品，为什么不试试呢？</p>
<p>官网地址：<a href="https://weex.apache.org/cn/">https://weex.apache.org/cn/</a></p>
<p>github  <a href="https://github.com/alibaba/weex">https://github.com/alibaba/weex</a></p>
<p>作者：alibaba</p>
<h2 id="6cordova-androidhybrid-开发框架-webapp开发框架"><a href="#6-cordova-android（Hybrid-开发框架、WebApp开发框架）" class="headerlink" title="6.cordova-android（Hybrid 开发框架、WebApp开发框架）"></a>6.cordova-android（Hybrid 开发框架、WebApp开发框架）<a href="#6cordova-androidhybrid-开发框架-webapp开发框架" class="header-anchor">#</a></h2><p>一句话介绍：跨平台的开发框架</p>
<p>上榜理由：cordova有足够的能力完成混合开发、WebApp开发的需求：不论你是Web开发者，或者是Native开发者，使用cordova都可以作出跨平台的App</p>
<p>官网地址：<a href="http://cordova.axuer.com/docs/zh-cn/latest/guide/overview/index.html">http://cordova.axuer.com/docs/zh-cn/latest/guide/overview/index.html</a></p>
<p>github <a href="https://github.com/apache/cordova-android">https://github.com/apache/cordova-android</a></p>
<h2 id="7react-native"><a href="#7-react-native" class="headerlink" title="7.react-native"></a>7.react-native<a href="#7react-native" class="header-anchor">#</a></h2><p>一句话介绍：一款以Javascript的语言来操作多个系统语言（Ios、Android）的框架</p>
<p>上榜理由：很难讲react-native属于什么类别，它适合前端工程师开发移动端App，也适合Native开发者进行跨平台的开发，但对于Navitve开发者来说陡峭的学习曲线会吓走一大批“框架爱好者”；前端界有一句名言：Web代表着未来，Native代表着现在，而我们处在现在与未来的道路上；49K个star，似乎让我们离未来更进一步</p>
<p>官网地址： <a href="http://facebook.github.io/react-native/docs/getting-started.html">http://facebook.github.io/react-native/docs/getting-started.html</a></p>
<p>github  <a href="https://github.com/facebook/react-native">https://github.com/facebook/react-native</a></p>
<p>作者：facebook</p>
<h1 id="五其他"><a href="#五-其他：" class="headerlink" title="五.其他："></a>五.其他：<a href="#五其他" class="header-anchor">#</a></h1><h2 id="1androidutilcode"><a href="#1-AndroidUtilCode" class="headerlink" title="1.AndroidUtilCode"></a>1.AndroidUtilCode<a href="#1androidutilcode" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：提供了数量庞大的工具类</span></p>
<p><span style="font-size: 15px">上榜理由：10.8K的star个数，足以证明它是多么受欢迎，欢迎你提供常用的工具类壮大它！</span></p>
<p><span style="font-size: 15px">github <a href="https://github.com/Blankj/AndroidUtilCode/blob/master/README-CN.md">https://github.com/Blankj/AndroidUtilCode/blob/master/README-CN.md</a></span></p>
<blockquote>
<p>File → Settings… → Plugins → Browse repositories…</p>
</blockquote>
<p>and search for <code>freeline</code>.</p>
<h2 id="2kotiln"><a href="#2-kotiln" class="headerlink" title="2.kotiln"></a><span>2.kotiln</span><a href="#2kotiln" class="header-anchor">#</a></h2><p>一句话介绍：Google推出的Android编程语言</p>
<p>上榜理由：就像AndroidStudio取代Eclipse那样，Google将kotiln作为Android的官方编程语言，也许此举是为了避免同Oracle的专利诉讼，但kotlin 100%兼容java，大幅精简java代码量，以及函数式编程的思想这些优异的特性同意值得我们注意，还记得在榜单之前说过的吗？未来是kotlin的，当下是java的，但我们处在当下通往未来的道路上——学习未来的编程语言，提升自己的工作效率，早点下班打豆豆，何乐而不为？</p>
<p>官网地址：<a href="http://kotlinlang.org/">http://kotlinlang.org/</a></p>
<p>github：<a href="https://github.com/JetBrains/kotlin">https://github.com/JetBrains/kotlin</a></p>
<p> 使用：</p>
<p><a href="http://kotlinlang.org/docs/reference/%20">http://kotlinlang.org/docs/reference/</a>   提供了 api-android用例-书籍等资源</p>
<h1 id="六书籍类项目"><a href="#六-书籍类项目" class="headerlink" title="六.书籍类项目"></a>六.书籍类项目<a href="#六书籍类项目" class="header-anchor">#</a></h1><h1 id="排序无先后"><a href="#（排序无先后）" class="headerlink" title="（排序无先后）"></a><span style="font-size: 16px">（排序无先后）</span><a href="#排序无先后" class="header-anchor">#</a></h1><h2 id="1android-developer中国官网培训课程"><a href="#1-Android-developer中国官网培训课程" class="headerlink" title="1.Android developer中国官网培训课程"></a>1.Android developer中国官网培训课程<a href="#1android-developer中国官网培训课程" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：符合中国国情的Google开发者官网的子产品——Android开发者官网</span></p>
<p><span style="font-size: 15px">上榜理由：这里有培训课程、API用例课程、Sample用例、依赖库介绍、AndroidStudio官网…等等一系列公开免费的课程，尽管大部分内容还是英文讲解，可是你肯靠着英语词典一篇一篇啃完，相信我，你的Android知识水平将秒杀国内市面上大部分的Android书籍</span></p>
<p><span style="font-size: 15px">官网地址：<a href="https://developer.android.google.cn/training/index.html">https://developer.android.google.cn/training/index.html</a></span></p>
<p><span style="font-size: 15px">作者：google</span></p>
<h2 id="2android-architecture"><a href="#2-android-architecture" class="headerlink" title="2.android-architecture"></a>2.android-architecture<a href="#2android-architecture" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：google提供的Android当下各种基本框架</span></p>
<p><span style="font-size: 15px">上榜理由：看完它，mvp，mvvm都将入切瓜砍菜，秋风扫落叶一般…</span></p>
<p><span style="font-size: 15px">github <a href="https://github.com/googlesamples/android-architecture">https://github.com/googlesamples/android-architecture</a></span></p>
<p><span style="font-size: 15px">作者：google</span></p>
<h2 id="3andorid-open-project"><a href="#3-andorid-open-project" class="headerlink" title="3.andorid-open-project"></a>3.andorid-open-project<a href="#3andorid-open-project" class="header-anchor">#</a></h2><p><span style="font-size: 15px">一句话介绍：囊括Android几乎所有的开源项目的导航类目录</span></p>
<p><span style="font-size: 15px">上榜理由：23k个star的导航类目录，与其盛名不符的是，该项目的导航、浏览阅读体验做的非常差，建议消遣之余阅读；推荐理由——中国人做的最全的Android 开源项目导航目录</span></p>
<p><span style="font-size: 15px">github <a href="https://github.com/Trinea/android-open-project">https://github.com/Trinea/android-open-project</a></span></p>
<p><span style="font-size: 15px">作者：Trinea</span></p>
<h2 id="4awesome-android-ui"><a href="#4-awesome-android-ui" class="headerlink" title="4.awesome-android-ui"></a>4.awesome-android-ui<a href="#4awesome-android-ui" class="header-anchor">#</a></h2><p>一句话介绍：Android的开源项目目录</p>
<p>上榜理由：国外的一款导航目录，23k个star</p>
<p>github  <a href="https://github.com/wasabeef/awesome-android-ui">https://github.com/wasabeef/awesome-android-ui</a></p>
<h1 id="笔者寄语"><a href="#笔者寄语" class="headerlink" title="笔者寄语:"></a>笔者寄语:<a href="#笔者寄语" class="header-anchor">#</a></h1><p><span style="font-size: 15px">今年我们的权威框架之旅就结束了，是否感觉到意犹未尽？那太好了，欢迎各位读者加入《Android百大框架排行榜》的讨论之中，可以来<a href="http://www.cnblogs.com/jincheng-yangchaofan/articles/7018780.html" title="Permalink to 2017年Android百大框架排行榜 - 杨超凡_金诚先生 - 博客园">原文链接</a>评论留言，也可以参与维护此项目：</span></p>
<p><span style="font-size: 15px">1.我认为XX框架应该上榜，理由XX</span></p>
<p><span style="font-size: 15px">2.我发现文章有几处错误，在XX部分</span></p>
<p><span style="font-size: 15px">3.对于笔者的某些观点我不能苟同，比如XX，我认为XX</span></p>
<p>…</p>
<p><span style="font-size: 15px">笔者希望收到<strong>有理有据</strong>的评论和未上榜的<strong>框架推荐</strong>，届时笔者会抽取一部分参与评论的小伙伴将，发放共计100RMB的物质奖励！</span></p>
<p>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　 　　　　　                                            2017-10-25   北京</p>

<link rel="stylesheet" href="/css/bilicard.css" type="text/css">]]></content>
      <categories>
        <category>Android</category>
        <category>项目架构</category>
        <category>开源框架</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>开源框架</tag>
      </tags>
  </entry>
</search>
